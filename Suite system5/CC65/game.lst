ca65 V2.17 - Git d13d068
Main file   : game.asm
Current file: game.asm

000000r 1               ;----------------------------------------------
000000r 1               ; Common AGD engine
000000r 1               ; Z80 conversion by Kees van Oss 2024
000000r 1               ;----------------------------------------------
000000r 1               	.DEFINE asm_code $2800
000000r 1               
000000r 1               	.include "game.cfg"
000000r 2               ; Flags saved by AGD Compiler
000000r 2               
000000r 2               cflag = 0 ;
000000r 2               dflag = 0 ;
000000r 2               lflag = 0 ;
000000r 2               mflag = 1 ;
000000r 2               oflag = 1 ;
000000r 2               pflag = 0 ;
000000r 2               sflag = 0 ;
000000r 2               clwflag = 0 ;
000000r 2               bigflag = 1 ;
000000r 2               rflag = 0 ;
000000r 2               
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1               	.include "z80-zp.inc"
000000r 2               ;.segment "ZEROPAGE"
000000r 2               
000000r 2               ws	 = $60
000000r 2               
000000r 2               z80_f	 = ws+$00
000000r 2               z80_a	 = ws+$01
000000r 2               z80_af	 = z80_f
000000r 2               
000000r 2               z80_c	 = ws+$02
000000r 2               z80_b	 = ws+$03
000000r 2               z80_bc	 = z80_c
000000r 2               
000000r 2               z80_e	 = ws+$04
000000r 2               z80_d	 = ws+$05
000000r 2               z80_de	 = z80_e
000000r 2               
000000r 2               z80_l	 = ws+$06
000000r 2               z80_h	 = ws+$07
000000r 2               z80_hl	 = z80_l
000000r 2               
000000r 2               z80_x    = ws+$08
000000r 2               z80_i    = ws+$09
000000r 2               z80_ix	 = z80_x
000000r 2               
000000r 2               z80_iy	 = ws+$0a
000000r 2               
000000r 2               z80_fp	 = ws+$0c
000000r 2               z80_ap	 = ws+$0d
000000r 2               
000000r 2               z80_cp	 = ws+$0e
000000r 2               z80_bp	 = ws+$0f
000000r 2               z80_bcp	 = z80_cp
000000r 2               
000000r 2               z80_ep	 = ws+$10
000000r 2               z80_dp	 = ws+$11
000000r 2               z80_dep	 = z80_ep
000000r 2               
000000r 2               z80_lp	 = ws+$12
000000r 2               z80_hp	 = ws+$13
000000r 2               z80_hlp	 = z80_lp
000000r 2               
000000r 2               z80_sp   = ws+$14
000000r 2               
000000r 2               z80_reg0 = ws+$16
000000r 2               z80_reg1 = ws+$17
000000r 2               z80_reg2 = ws+$18
000000r 2               z80_reg3 = ws+$19
000000r 2               
000000r 2               z80_r	 = ws+$1a
000000r 2               
000000r 2               
000000r 1               	.include "engine-zp.inc"
000000r 2               ;----------------------------------------------------------------------
000000r 2               ; AGD 6502 Engine Zero Page Variables
000000r 2               ;----------------------------------------------------------------------
000000r 2               
000000r 2               ; Variables start here.
000000r 2               
000000r 2  xx           scno:	.res 1			; present screen number.
000001r 2  xx           numlif:	.res 1			; number of lives.
000002r 2               
000002r 2  xx           vara:	.res 1			; general-purpose variable.
000003r 2  xx           varb:	.res 1			; general-purpose variable.
000004r 2  xx           varc:	.res 1			; general-purpose variable.
000005r 2  xx           vard:	.res 1			; general-purpose variable.
000006r 2  xx           vare:	.res 1			; general-purpose variable.
000007r 2  xx           varf:	.res 1			; general-purpose variable.
000008r 2  xx           varg:	.res 1			; general-purpose variable.
000009r 2  xx           varh:	.res 1			; general-purpose variable.
00000Ar 2  xx           vari:	.res 1			; general-purpose variable.
00000Br 2  xx           varj:	.res 1			; general-purpose variable.
00000Cr 2  xx           vark:	.res 1			; general-purpose variable.
00000Dr 2  xx           varl:	.res 1			; general-purpose variable.
00000Er 2  xx           varm:	.res 1			; general-purpose variable.
00000Fr 2  xx           varn:	.res 1			; general-purpose variable.
000010r 2  xx           varo:	.res 1			; general-purpose variable.
000011r 2  xx           varp:	.res 1			; general-purpose variable.
000012r 2  xx           varq:	.res 1			; general-purpose variable.
000013r 2  xx           varr:	.res 1			; general-purpose variable.
000014r 2  xx           vars:	.res 1			; general-purpose variable.
000015r 2  xx           vart:	.res 1			; general-purpose variable.
000016r 2  xx           varu:	.res 1			; general-purpose variable.
000017r 2  xx           varv:	.res 1			; general-purpose variable.
000018r 2  xx           varw:	.res 1			; general-purpose variable.
000019r 2  xx           varz:	.res 1			; general-purpose variable.
00001Ar 2               
00001Ar 2  xx           charx:	.res 1			; cursor x position.
00001Br 2  xx           chary:	.res 1			; cursor y position.
00001Cr 2               
00001Cr 2  xx           clock:	.res 1			; last clock reading.
00001Dr 2  xx           varrnd:	.res 1	        	; last random number.
00001Er 2  xx           varobj:	.res 1  	   	; last object number.
00001Fr 2  xx           varopt:	.res 1     		; last option chosen from menu.
000020r 2  xx           varblk:	.res 1  		; block type.
000021r 2  xx           nexlev:	.res 1			; next level flag.
000022r 2  xx           restfl:	.res 1			; restart screen flag.
000023r 2  xx           deadf:	.res 1			; dead flag.
000024r 2  xx           gamwon:	.res 1			; game won flag.
000025r 2  xx           dispx:	.res 1			; cursor x position.
000026r 2  xx           dispy:	.res 1			; cursor y position.
000027r 2               
000027r 2  xx           contrl:	.res 1			; control = keyboard, 1 = Kempston, 2 = Sinclair, 3 = Mouse.
000028r 2  xx           joyval:	.res 1			; joystick reading.
000029r 2  xx           frmno:	.res 1			; selected frame.
00002Ar 2               
00002Ar 2               ;----------------------------------------------------
00002Ar 2               ; Missing vars
00002Ar 2               ;----------------------------------------------------
00002Ar 2               
00002Ar 2  xx           loopa:	    .res 1
00002Br 2  xx           loopb:	    .res 1
00002Cr 2  xx           loopc:	    .res 1
00002Dr 2  xx xx        FontPtr:    .res 2
00002Fr 2               
00002Fr 2               ; Local vars
00002Fr 2               
00002Fr 2  xx xx        scraddr:    .res 2
000031r 2  xx xx        fntaddr:    .res 2
000033r 2  xx xx        tileaddr:   .res 2
000035r 2  xx xx        bufaddr:    .res 2
000037r 2  xx xx        advbuff:    .res 2
000039r 2               
000039r 2  xx xx        tmp:        .res 2
00003Br 2  xx xx        scr_l:      .res 2
00003Dr 2  xx xx        scr_r:      .res 2
00003Fr 2  xx xx        scr_txt:    .res 2
000041r 2               
000041r 2  xx           xtmp:	    .res 1
000042r 2  xx           ytmp:	    .res 1
000043r 2  xx           spcnt:	    .res 1
000044r 2  xx xx        spptr:	    .res 2		; spawned sprite pointer.
000046r 2  xx           seed:	    .res 1		; seed for random numbers.
000047r 2               
000047r 2  xx           ccnt:       .res 1
000048r 2  xx           flag:	    .res 1
000049r 2  xx           rcol:	    .res 1
00004Ar 2  xx           rrow:	    .res 1
00004Br 2               
00004Br 2  xx           combyt:	    .res 1		; byte type compressed.
00004Cr 2  xx           comcnt:	    .res 1		; compression counter.
00004Dr 2  xx           prtmod:	    .res 1      	; print mode, 0 = standard, 1 = double-height.
00004Er 2  xx           qscnt:	    .res 1
00004Fr 2               
00004Fr 2  xx           sprptr:	    .res 1      	; not a ptr
000050r 2  xx           sprcnt:	    .res 1
000051r 2               
000051r 2  xx xx        skptr:	    .res 2		; search pointer.
000053r 2  xx           sktptr:	    .res 1      	; not a ptr
000054r 2  xx           tmproom:    .res 1
000055r 2  xx xx        ogptr:	    .res 2		; original sprite pointer.
000057r 2               
000057r 2               .if mflag
000057r 2  xx xx        TmpAddr:    .res 2
000059r 2  xx           bwid:	    .res 1     		; box/menu width.
00005Ar 2  xx           blen:	    .res 1     		; box/menu height.
00005Br 2  xx           btop:	    .res 1    	 	; box coordinates.
00005Cr 2  xx           blft:	    .res 1
00005Dr 2               .endif
00005Dr 2               
00005Dr 2               .if sflag .or pflag
00005Dr 2               shrctr:	    .res 1
00005Dr 2               .endif
00005Dr 2               .if pflag
00005Dr 2               explcnt:    .res 1
00005Dr 2               seed3:	    .res 1
00005Dr 2               .endif
00005Dr 2               
00005Dr 2               .if aflag
00005Dr 2               pbptr:       .res 2
00005Dr 2               pbbuf:	     .res 2
00005Dr 2               .endif
00005Dr 2               
00005Dr 2               ;sndtyp:     .res 1
00005Dr 2               
00005Dr 2               ;.if rflag
00005Dr 2               ;sprshft:     .res 1
00005Dr 2               ;.endif
00005Dr 2               
00005Dr 1               
00005Dr 1               .segment "CODE"
000000r 1               
000000r 1               .org asm_code
002800  1               
002800  1               exec:
002800  1               start_asm:
002800  1               	.include "game.inc"
002800  2               .include "testobj.inc"
002800  3               ;--------------------------------------------------------------
002800  3               ; Arcade Game Designer.
002800  3               ; (C) 2008 Jonathan Cauldwell.
002800  3               ; ZX Spectrum Engine v0.7.
002800  3               ; System 5 port by K.v.Oss 2024
002800  3               ;--------------------------------------------------------------
002800  3               
002800  3               ; Conditional compilation flags
002800  3               ; Code is installed if flag is set
002800  3               ; Flags are set in commandline assembly or by the compiler
002800  3               
002800  3               ; Flags set by AGD compiler
002800  3               ;	mflag  			; MENU + INV
002800  3               ;	pflag 			; particle engine
002800  3               ;	sflag 			; scrollytext
002800  3               ;	dflag 			; digging mode
002800  3               ;	cflag			; collectable blocks
002800  3               ;	oflag			; objects
002800  3               ;	lflag			; ladders
002800  3               ;
002800  3               ; Flags set manually
002800  3               ;	aflag			; adventure mode
002800  3               ;	bflag			; big sprites (16x24)
002800  3               ;	fflag			; floppy version (skip #0axx)
002800  3               ;	gflag			; graphic colour mode
002800  3               ;	hflag			; hidden sprite mode
002800  3               ;	iflag			; invert mode
002800  3               
002800  3               .if mflag
002800  3               	.out "- MEN/INV enabled"
002800  3               .endif
002800  3               .if pflag
002800  3               	.out "- Particles enabled"
002800  3               .endif
002800  3               .if sflag
002800  3               	.out "- Scrolling enabled"
002800  3               .endif
002800  3               .if dflag
002800  3               	.out "- Digging enabled"
002800  3               .endif
002800  3               .if cflag
002800  3               	.out "- Collectable blocks enabled"
002800  3               .endif
002800  3               .if oflag
002800  3               	.out "- Objects enabled"
002800  3               .endif
002800  3               .if lflag
002800  3               	.out "- Ladders enabled"
002800  3               .endif
002800  3               .if aflag
002800  3               	.out "- Adventure mode enabled"
002800  3               .endif
002800  3               .if bflag
002800  3               	.out "- Big Sprites (8x12) enabled"
002800  3               .endif
002800  3               .if gflag
002800  3               	.out "- Colourmode enabled"
002800  3               .endif
002800  3               .if hflag
002800  3               	.out "- Hidden sprites/foregroundblocks enabled"
002800  3               .endif
002800  3               .if iflag
002800  3               	.out "- Invert mode enabled"
002800  3               .endif
002800  3               
002800  3               ; Global definitions
002800  3               
002800  3               	FONT 		= font	; Font address
002800  3               
002800  3               ; Block characteristics.
002800  3               
002800  3               	PLATFM	= 1		; platform.
002800  3               	WALL	= PLATFM + 1	; solid wall.
002800  3               	LADDER	= WALL + 1	; ladder.
002800  3               	FODDER	= LADDER + 1	; fodder block.
002800  3               	DEADLY	= FODDER + 1	; deadly block.
002800  3               	CUSTOM	= DEADLY + 1	; custom block.
002800  3               	WATER	= CUSTOM + 1	; water block.
002800  3                       COLECT	= WATER + 1	; collectable block.
002800  3                       NUMTYP	= COLECT + 1	; number of types.
002800  3               
002800  3               ; Sprites.
002800  3               
002800  3               .if bflag
002800  3               	SPR_HGT	= 12		; Sprite height
002800  3               	SPR_WID = 8		; Sprite width
002800  3               	NUMSPR	= 12		; number of sprites.
002800  3               .else				; 16x16 sprites
002800  3               	SPR_HGT = 9		; Sprite height
002800  3               	SPR_WID = 8		; Sprite width
002800  3               	NUMSPR	= 12		; number of sprites.
002800  3               .endif
002800  3               
002800  3               	TABSIZ = 17		; size of each entry.
002800  3               	SPRBUF = NUMSPR * TABSIZ; size of entire table.
002800  3               	NMESIZ = 4		; bytes stored in nmetab for each sprite.
002800  3               	var_X  = 8		; new x coordinate of sprite.
002800  3               	var_Y  = var_X + 1	; new y coordinate of sprite.
002800  3               	PAM1ST = 5		; first sprite parameter, old x (ix+5).
002800  3               
002800  3               ; Particle engine.
002800  3               
002800  3               	NUMSHR = 55		; pieces of shrapnel.
002800  3               	SHRSIZ = 6		; bytes per particle.
002800  3               
002800  3               .if iflag
002800  3               	TxtInvert   = $ff	; Invert byte for character printing
002800  3               	ScrFillByte = $ff	; Screen fill byte for CLS
002800  3               .else
002800  3               	TxtInvert   = $00	; Invert byte for character printing
002800  3               	ScrFillByte = $00	; Screen fill byte for CLS
002800  3               .endif
002800  3               
002800  3               .if gflag
002800  3               	ScrMode     = $d0	;  $d0 = CLEAR4a colour
002800  3               .else
002800  3               	ScrMode     = $f0	;  $f0 = CLEAR4  mono
002800  3               .endif
002800  3               
002800  3               ;===============================================================
002800  3               ; Game starts here
002800  3               ;===============================================================
002800  3               
002800  3               .segment "CODE"
002800  3               
002800  3               
002800  3               ; Clear zp variables
002800  3               
002800  3  A9 00        	lda #0
002802  3  A2 00        	ldx #0
002804  3               clrloop:
002804  3  95 00        	sta 0,x
002806  3  E8           	inx
002807  3  D0 FB        	bne clrloop
002809  3               
002809  3               gameloop:
002809  3  20 12 2B     	jsr game	 	; start the game.
00280C  3  4C 09 28     	jmp gameloop
00280F  3               
00280F  3               ; Definition of variables
00280F  3               ; Make sure pointers are arranged in the same order as the data itself.
00280F  3               
00280F  3  29 3E        msgptr:		.word msgdat	; messages
002811  3  AD 3E        blkptr:		.word chgfx	; block graphics.
002813  3  B1 3E        proptr:		.word bprop	; address of char properties.
002815  3  B3 3E        sptptr:		.word sprgfx	; sprite graphics
002817  3  93 40        frmptr:		.word frmlst	; sprite frames.
002819  3  97 40        scrptr:		.word scdat	; address of screens.
00281B  3  07 41        nmeptr:		.word nmedat	; enemy start positions.
00281D  3  0C 41        objptr:		.word objdta	; object graphics
00281F  3               
00281F  3               ;TxtFilter:	.byte $ff
00281F  3               ;txtcol:		.byte green,yellow,blue,red
00281F  3               
00281F  3               ; Don't change the order of these four.
00281F  3               ; Menu routine relies on winlft following wintop.
00281F  3               
00281F  3  02           wintop:		.byte WINDOWTOP	; top of window.
002820  3  01           winlft:		.byte WINDOWLFT	; left edge.
002821  3  17           winhgt:		.byte WINDOWHGT	; window height.
002822  3  27           winwid:		.byte WINDOWWID	; window width.
002823  3  08           numob:		.byte NUMOBJ	; number of objects in game.
002824  3               
002824  3               ; Variables start here.
002824  3               ; Pixel versions of wintop, winlft, winhgt, winwid.
002824  3               
002824  3  06           wntopx:		.byte (3 * WINDOWTOP)
002825  3  02           wnlftx:		.byte (2 * WINDOWLFT)
002826  3  42           wnbotx:		.byte ((WINDOWTOP * 3) + (WINDOWHGT * 3) - 9)
002827  3  46           wnrgtx:		.byte ((WINDOWLFT * 2) + (WINDOWWID * 2) - 8)-2
002828  3               
002828  3               ; Assorted game routines which can go in contended memory.
002828  3               
002828  3               ;--------------------------------------------------------------
002828  3               ; Entry for inventory called by the INV command
002828  3               ;
002828  3               ; Input:
002828  3               ;  X   = message nr with objects seperated with ,
002828  3               ;
002828  3               ; Output:
002828  3               ;  OPT = selected objectnr of INV menu
002828  3               ;--------------------------------------------------------------
002828  3               
002828  3               .if mflag
002828  3               minve:
002828  3               .if gflag
002828  3               	lda #$ff		; blue frontcolour
002828  3               	sta andeor
002828  3               	lda #$aa		; yellow backcoloour
002828  3               	sta andeor+1
002828  3               .endif
002828  3  A9 2F        	lda #<(invdis)		; routine address.
00282A  3  8D 10 29     	sta mod0+1		; set up menu routine.
00282D  3  8D 81 28     	sta mod2+1		; set up count routine.
002830  3  A9 2A        	lda #>(invdis)
002832  3  8D 11 29     	sta mod0+2
002835  3  8D 82 28     	sta mod2+2
002838  3  A9 45        	lda #<(fopt)		; find option from available objects.
00283A  3  8D C0 29     	sta mod1+1		; set up routine.
00283D  3  A9 2A        	lda #>(fopt)
00283F  3  8D C1 29     	sta mod1+1+1
002842  3  4C 5F 28     	jmp dbox		; do menu routine.
002845  3               
002845  3               ;--------------------------------------------------------------
002845  3               ; Entry for menu called by the MENU command
002845  3               ;
002845  3               ; Input:
002845  3               ;  X   = message nr with menu items seperated with ,
002845  3               ;
002845  3               ; Output:
002845  3               ;  OPT = selected line nr of MENU menu
002845  3               ;--------------------------------------------------------------
002845  3               
002845  3               mmenu:
002845  3  A9 5C        	lda #<(always)		; routine address.
002847  3  8D 10 29     	sta mod0+1		; set up routine.
00284A  3  8D 81 28     	sta mod2+1		; set up count routine.
00284D  3  A9 32        	lda #>(always)
00284F  3  8D 11 29     	sta mod0+2
002852  3  8D 82 28     	sta mod2+2
002855  3               
002855  3  A9 EC        	lda #<(fstd)		; standard option selection.
002857  3  8D C0 29     	sta mod1+1		; set up routine.
00285A  3  A9 29        	lda #>(fstd)
00285C  3  8D C1 29     	sta mod1+2
00285F  3               
00285F  3               ; Drop through into box routine.
00285F  3               
00285F  3               ;--------------------------------------------------------------
00285F  3               ; Work out size of box for message or menu.
00285F  3               ;--------------------------------------------------------------
00285F  3               
00285F  3               dbox:
00285F  3  A9 29        	lda #<(msgdat)		; pointer to messages.
002861  3  85 66        	sta z80_l
002863  3  A9 3E        	lda #>(msgdat)
002865  3  85 67        	sta z80_h
002867  3               
002867  3  20 7F 34     	jsr getwrd		; get message number.
00286A  3               
00286A  3  A5 67        	lda z80_h		; store pointer to message.
00286C  3  85 rr        	sta TmpAddr
00286E  3  A5 66        	lda z80_l
002870  3  85 rr        	sta TmpAddr+1
002872  3               
002872  3  A9 01        	lda #1			; height.
002874  3  85 65        	sta z80_d
002876  3  A9 00        	lda #0			; start at object zero.
002878  3  85 rr        	sta combyt		; store number of object in combyt.
00287A  3  85 64        	sta z80_e		; maximum width.
00287C  3               dbox5:
00287C  3  A9 00        	lda #0			; this line"s width.
00287E  3  85 63        	sta z80_b
002880  3               mod2:
002880  3  20 5C 32     	jsr always		; item in player"s possession?
002883  3  C9 FF        	cmp #255
002885  3  D0 02        	bne dbox6		; not in inventory, skip this line.
002887  3  E6 65        	inc z80_d		; add to tally.
002889  3               dbox6:
002889  3  A0 00        	ldy #0			; get character.
00288B  3  B1 66        	lda (z80_hl),y
00288D  3  85 61        	sta z80_a
00288F  3  E6 66        	inc z80_l		; next character.
002891  3  D0 02        	bne :+
002893  3  E6 67        	inc z80_h
002895  3               :
002895  3  A5 61        	lda z80_a		; reached end of line?
002897  3  C9 2C        	cmp #','
002899  3  F0 0D        	beq dbox3		; yes.
00289B  3  C9 0D        	cmp #13
00289D  3  F0 09        	beq dbox3		; yes.
00289F  3  E6 63        	inc z80_b		; add to this line"s width.
0028A1  3  A5 61        	lda z80_a
0028A3  3  30 10        	bmi dbox4		; end of message? yes, end count.
0028A5  3  4C 89 28     	jmp dbox6		; repeat until we find the end.
0028A8  3               dbox3:
0028A8  3  A5 64        	lda z80_e		; maximum line width.
0028AA  3  C5 63        	cmp z80_b		; have we exceeded longest so far?
0028AC  3  10 CE        	bpl dbox5		; no, carry on looking.
0028AE  3  A5 63        	lda z80_b		; make this the widest so far.
0028B0  3  85 64        	sta z80_e
0028B2  3  4C 7C 28     	jmp dbox5		; keep looking.
0028B5  3               dbox4:
0028B5  3  A5 64        	lda z80_e		; maximum line width.
0028B7  3  C5 63        	cmp z80_b		; have we exceeded longest so far?
0028B9  3  10 04        	bpl dbox8		; no, carry on looking.
0028BB  3  A5 63        	lda z80_b		; final line is the longest so far.
0028BD  3  85 64        	sta z80_e
0028BF  3               dbox8:
0028BF  3  C6 65        	dec z80_d		; decrement items found.
0028C1  3  D0 07        	bne :+			; total was zero.
0028C3  3  A9 FF        	lda #255
0028C5  3  85 rr        	sta varopt
0028C7  3  4C 16 2A     	jmp dbox15
0028CA  3               :
0028CA  3  A5 64        	lda z80_e		; longest line.
0028CC  3  D0 03        	bne :+			; was it zero?
0028CE  3  4C 16 2A     	jmp dbox15		; total was zero.
0028D1  3               :
0028D1  3  85 rr        	sta bwid		; set up size.
0028D3  3  A5 65        	lda z80_d
0028D5  3  85 rr        	sta blen
0028D7  3               
0028D7  3               ;--------------------------------------------------------------
0028D7  3               ; That's set up our box size.
0028D7  3               ;--------------------------------------------------------------
0028D7  3               
0028D7  3  AD 21 28     	lda winhgt		; window height in characters.
0028DA  3  38           	sec
0028DB  3  E5 65        	sbc z80_d		; subtract height of box.
0028DD  3  4A           	lsr a			; divide by 2.
0028DE  3  18           	clc
0028DF  3  6D 1F 28     	adc wintop		; add top edge of window.
0028E2  3  85 rr        	sta btop		; set up box top.
0028E4  3               
0028E4  3  AD 22 28     	lda winwid		; window width in characters.
0028E7  3  38           	sec
0028E8  3  E5 64        	sbc z80_e		; subtract box width.
0028EA  3  4A           	lsr a			; divide by 2.
0028EB  3  18           	clc
0028EC  3  6D 20 28     	adc winlft		; add left edge of window.
0028EF  3  85 rr        	sta blft		; box left.
0028F1  3               
0028F1  3  A9 9C        	lda #<(FONT-256)		; font.
0028F3  3  8D BF 2E     	sta grbase		; set up for text display.
0028F6  3  A9 40        	lda #>(FONT-256)
0028F8  3  8D C0 2E     	sta grbase+1
0028FB  3               
0028FB  3  A5 rr        	lda TmpAddr+1		; restore message pointer.
0028FD  3  85 66        	sta z80_l
0028FF  3  A5 rr        	lda TmpAddr
002901  3  85 67        	sta z80_h
002903  3               
002903  3  A5 rr        	lda btop		; box top.
002905  3  85 rr        	sta dispy		; set display coordinate.
002907  3  A9 00        	lda #0			; start at object zero.
002909  3  85 rr        	sta combyt		; store number of object in combyt.
00290B  3               dbox2:
00290B  3  A5 rr        	lda combyt		; get object number.
00290D  3  85 61        	sta z80_a
00290F  3               mod0:
00290F  3  20 5C 32     	jsr always		; check inventory for display.
002912  3  C9 FF        	cmp #255
002914  3  F0 03        	beq :+
002916  3  4C F6 29     	jmp dbox13		; not in inventory, skip this line.
002919  3               :
002919  3  A5 rr        	lda blft		; box left.
00291B  3  85 rr        	sta dispx		; set left display position.
00291D  3  A5 rr        	lda bwid		; box width.
00291F  3  85 63        	sta z80_b		; store width.
002921  3               
002921  3  AD 1D 3C     	lda fcolour		; Set textcolour
002924  3  20 47 30     	jsr pchar
002927  3  20 4C 34     	jsr nexpos
00292A  3               dbox0:
00292A  3  A0 00        	ldy #0
00292C  3  B1 66        	lda (z80_hl),y		; get character.
00292E  3  C9 2C        	cmp #','		; end of line?
002930  3  F0 5C        	beq dbox1		; yes, next one.
002932  3  C9 0D        	cmp #13			; end of line?
002934  3  F0 58        	beq dbox1		; yes, next one.
002936  3               
002936  3  C9 8D        	cmp #141			; end of line?
002938  3  D0 05        	bne :+
00293A  3  C6 rr        	dec bwid
00293C  3  4C 9C 29     	jmp dbox7		; yes, next one.
00293F  3               :
00293F  3  C6 63        	dec z80_b		; one less to display.
002941  3  29 7F        	and #127		; remove terminator.
002943  3               
002943  3  20 A6 30     	jsr pchr		; display on screen.
002946  3               
002946  3  A0 00        	ldy #0
002948  3  B1 66        	lda (z80_hl),y		; get character.
00294A  3  85 61        	sta z80_a
00294C  3  E6 66        	inc z80_l		; next character.
00294E  3  D0 02        	bne :+
002950  3  E6 67        	inc z80_h
002952  3               :
002952  3  A5 61        	lda z80_a
002954  3  C9 80        	cmp #128		; end of message?
002956  3  30 06        	bmi :+
002958  3  20 14 2F     	jsr dscor2
00295B  3  4C 9C 29     	jmp dbox7		; yes, job done.
00295E  3               :
00295E  3  A5 63        	lda z80_b		; chars remaining.
002960  3  F0 03        	beq :+			; are any left?
002962  3  4C 2A 29     	jmp dbox0		; yes, continue.
002965  3               :
002965  3               ;---------------------------------------------------
002965  3               ; Reached limit of characters per line.
002965  3               ;---------------------------------------------------
002965  3               
002965  3               dbox9:
002965  3  A0 00        	ldy #0
002967  3  B1 66        	lda (z80_hl),y		; get character.
002969  3  E6 66        	inc z80_l		; next one.
00296B  3  D0 02        	bne :+
00296D  3  E6 67        	inc z80_h
00296F  3               :
00296F  3  C9 2C        	cmp #','		; another line?
002971  3  F0 24        	beq dbox10		; yes, do next line.
002973  3  C9 0D        	cmp #13			; another line?
002975  3  F0 20        	beq dbox10		; yes, do next line.
002977  3  C9 80        	cmp #128		; end of message?
002979  3  B0 03        	bcs :+
00297B  3  4C A6 29     	jmp dbox11		; yes, finish message.
00297E  3               :
00297E  3  4C 65 29     	jmp dbox9
002981  3               
002981  3               ;---------------------------------------------------
002981  3               ; Fill box to end of line.
002981  3               ;---------------------------------------------------
002981  3               
002981  3               dboxf:
002981  3  A9 20        	lda #32			; space character.
002983  3  20 A6 30     	jsr pchr		; display character.
002986  3  C6 63        	dec z80_b
002988  3  F0 03        	beq :+
00298A  3  4C 81 29     	jmp dboxf		; repeat for remaining chars on line.
00298D  3               :
00298D  3  60           	rts
00298E  3               dbox1:
00298E  3  E6 66        	inc z80_l		; skip character.
002990  3  D0 02        	bne :+
002992  3  E6 67        	inc z80_h
002994  3               :
002994  3  20 81 29     	jsr dboxf		; fill box out to right side.
002997  3               dbox10:
002997  3  E6 rr        	inc dispy		; y coordinate down a line next position.
002999  3  4C 0B 29     	jmp dbox2		; next line.
00299C  3               dbox7:
00299C  3  A5 63        	lda z80_b		; chars remaining.
00299E  3  D0 03        	bne :+			; are any left?
0029A0  3  4C A6 29     	jmp dbox11		; no, nothing to draw.
0029A3  3               :
0029A3  3  20 81 29     	jsr dboxf		; fill message to line.
0029A6  3               
0029A6  3               ;------------------------------------------------------
0029A6  3               ; Drawn the box menu, now select option.
0029A6  3               ;------------------------------------------------------
0029A6  3               
0029A6  3               dbox11:
0029A6  3  A5 rr        	lda btop		; box top.
0029A8  3  85 rr        	sta dispy		; set bar position.
0029AA  3               dbox14:
0029AA  3  20 46 33     	jsr joykey		; get controls.
0029AD  3  C9 7F        	cmp #$7f		; anything pressed?
0029AF  3  D0 F9        	bne dbox14		; yes, debounce it.
0029B1  3  20 1F 2A     	jsr dbar		; draw bar.
0029B4  3               dbox12:
0029B4  3  20 46 33     	jsr joykey		; get controls.
0029B7  3  C9 7F        	cmp #$7f		; anything pressed?
0029B9  3  F0 F9        	beq dbox12		; no, nothing.
0029BB  3  29 10        	and #16			; fire button pressed?
0029BD  3  D0 03        	bne :+
0029BF  3               mod1:
0029BF  3  4C EC 29     	jmp fstd		; yes, job done.
0029C2  3               :
0029C2  3  20 1F 2A     	jsr dbar		; delete bar.
0029C5  3               
0029C5  3  A5 rr        	lda joyval		; joystick reading.
0029C7  3  29 08        	and #8			; going up?
0029C9  3  F0 13        	beq dboxu		; yes, go up.
0029CB  3               
0029CB  3  A6 rr        	ldx dispy		; vertical position of bar.
0029CD  3  E8           	inx			; look down.
0029CE  3  8A           	txa
0029CF  3  38           	sec
0029D0  3  E5 rr        	sbc btop		; find distance from top.
0029D2  3  C5 rr        	cmp blen		; top of box.
0029D4  3  D0 03        	bne :+
0029D6  3  4C AA 29     	jmp dbox14		; yes, go no further.
0029D9  3               :
0029D9  3  E6 rr        	inc dispy		; move bar.
0029DB  3  4C AA 29     	jmp dbox14		; continue.
0029DE  3               dboxu:
0029DE  3  A5 rr        	lda dispy		; vertical position of bar.
0029E0  3  C5 rr        	cmp btop		; are we at the top?
0029E2  3  D0 03        	bne :+
0029E4  3  4C AA 29     	jmp dbox14		; yes, go no further.
0029E7  3               :
0029E7  3  C6 rr        	dec dispy		; move bar.
0029E9  3  4C AA 29     	jmp dbox14		; continue.
0029EC  3               fstd:
0029EC  3  A5 rr        	lda dispy		; bar position.
0029EE  3  38           	sec
0029EF  3  E5 rr        	sbc btop		; find selected option.
0029F1  3  85 rr        	sta varopt		; store the option.
0029F3  3  4C CC 2A     	jmp redraw		; redraw the screen.
0029F6  3               
0029F6  3               ;------------------------------------------------------
0029F6  3               ; Option not available.  Skip this line.
0029F6  3               ;------------------------------------------------------
0029F6  3               
0029F6  3               dbox13:
0029F6  3  A0 00        	ldy #0
0029F8  3  B1 66        	lda (z80_hl),y		; get character.
0029FA  3  E6 66        	inc z80_l		; next one.
0029FC  3  D0 02        	bne :+
0029FE  3  E6 67        	inc z80_h
002A00  3               :
002A00  3  C9 2C        	cmp #','		; another line?
002A02  3  D0 03        	bne :+
002A04  3  4C 0B 29     	jmp dbox2		; yes, do next line.
002A07  3               :
002A07  3  C9 0D        	cmp #13			; another line?
002A09  3  D0 03        	bne :+
002A0B  3  4C 0B 29     	jmp dbox2		; yes, do next line.
002A0E  3               :
002A0E  3               
002A0E  3  10 03        	bpl :+			; end of message?
002A10  3  4C A6 29     	jmp dbox11		; yes, finish message.
002A13  3               :
002A13  3  4C F6 29     	jmp dbox13
002A16  3               dbox15:
002A16  3  A5 rr        	lda TmpAddr		; pop message pointer from the stack.
002A18  3  85 67        	sta z80_h
002A1A  3  A5 rr        	lda TmpAddr+1
002A1C  3  85 66        	sta z80_l
002A1E  3  60           	rts
002A1F  3               
002A1F  3               ;------------------------------------------------------
002A1F  3               ; Invert bar
002A1F  3               ;------------------------------------------------------
002A1F  3               
002A1F  3               dbar:
002A1F  3  A5 rr        	lda blft		; box left.
002A21  3  85 rr        	sta dispx		; set display coordinate.
002A23  3  20 17 30     	jsr gprad		; get printing address.
002A26  3               
002A26  3               ;	lda bwid		; box width.
002A26  3               ;	sta z80_c		; loop counter in c.
002A26  3               ;	lda z80_h
002A26  3               ;	sta z80_d		; store screen address high byte.
002A26  3               ;dbar1:
002A26  3               ;	ldx #7			; pixel height in b.
002A26  3               ;dbar0:
002A26  3               ;	ldy scrtab,x
002A26  3               ;	lda (scraddr),y		; get screen byte.
002A26  3               ;	eor #255		; reverse all bits.
002A26  3               ;	sta (scraddr),y		; write back to screen.
002A26  3               ;	dex			; next line down.
002A26  3               ;	bpl dbar0		; draw rest of character.
002A26  3               
002A26  3               ;	inc scraddr		; one char right.
002A26  3               ;	dec z80_c		; decrement character counter.
002A26  3               ;	bne dbar1		; repeat for whole line.
002A26  3               
002A26  3  A0 00        	ldy #0
002A28  3  B1 rr        	lda (scraddr),y
002A2A  3  49 07        	eor #7
002A2C  3  91 rr        	sta (scraddr),y
002A2E  3               
002A2E  3  60           	rts
002A2F  3               
002A2F  3               ;------------------------------------------------------
002A2F  3               ; Point to object
002A2F  3               ;
002A2F  3               ; Input:
002A2F  3               ;  combyt
002A2F  3               ;
002A2F  3               ; Output:
002A2F  3               ;  A = object number, A=255 if already in possession
002A2F  3               ;------------------------------------------------------
002A2F  3               
002A2F  3               invdis:
002A2F  3  A5 66        	lda z80_l		; store message text pointer.
002A31  3  48           	pha
002A32  3  A5 67        	lda z80_h
002A34  3  48           	pha
002A35  3  A5 rr        	lda combyt		; object number.
002A37  3  E6 rr        	inc combyt		; ready for next one.
002A39  3  20 6F 2D     	jsr gotob		; check if we have object.
002A3C  3  A8           	tay
002A3D  3  68           	pla
002A3E  3  85 67        	sta z80_h
002A40  3  68           	pla
002A41  3  85 66        	sta z80_l
002A43  3  98           	tya
002A44  3  60           	rts
002A45  3               
002A45  3               ;------------------------------------------------------
002A45  3               ; Find option selected.
002A45  3               ;
002A45  3               ; Input:
002A45  3               ;  -
002A45  3               ;
002A45  3               ; Output:
002A45  3               ;  OPT = selected object
002A45  3               ;------------------------------------------------------
002A45  3               
002A45  3               fopt:
002A45  3  A5 rr        	lda dispy
002A47  3  38           	sec
002A48  3  E5 rr        	sbc btop		; find selected option.
002A4A  3  85 rr        	sta tmp+2		; option selected in b register.
002A4C  3  E6 rr        	inc tmp+2
002A4E  3               
002A4E  3  A9 00        	lda #0			; set to first item.
002A50  3  85 rr        	sta combyt		; object number.
002A52  3               fopt0:
002A52  3  20 62 2A     	jsr fobj		; find next object in inventory.
002A55  3  C6 rr        	dec tmp+2
002A57  3  D0 F9        	bne fopt0		; repeat for relevant steps down the list.
002A59  3               
002A59  3  A5 rr        	lda combyt		; get option.
002A5B  3  85 rr        	sta varopt		; store the option.
002A5D  3  C6 rr        	dec varopt		; one less, due to where we increment combyt.
002A5F  3  4C CC 2A     	jmp redraw		; redraw the screen.
002A62  3               fobj:
002A62  3  A4 rr        	ldy combyt		; object number.
002A64  3  E6 rr        	inc combyt		; ready for next item.
002A66  3  98           	tya
002A67  3  20 6F 2D     	jsr gotob		; do we have this item?
002A6A  3  C9 FF        	cmp #255
002A6C  3  D0 01        	bne :+
002A6E  3  60           	rts
002A6F  3               :
002A6F  3  4C 62 2A     	jmp fobj		; yes, it's on the list.
002A72  3               .endif
002A72  3               
002A72  3               ;----------------------------------------------------
002A72  3               ; Delay routine A * 1/25 sec
002A72  3               ;----------------------------------------------------
002A72  3               
002A72  3               delay:
002A72  3  85 rr        	sta xtmp
002A74  3               
002A74  3               del_start:
002A74  3  A9 00        	lda #0
002A76  3  8D 31 45     	sta frames_passed
002A79  3               del_loop:
002A79  3  20 11 2B     	jsr proshr
002A7C  3               
002A7C  3  AD 31 45     	lda frames_passed
002A7F  3  C9 02        	cmp #2
002A81  3  90 F6        	bcc del_loop
002A83  3               
002A83  3  A9 00        	lda #0
002A85  3  8D 31 45     	sta frames_passed
002A88  3  C6 rr        	dec xtmp
002A8A  3  D0 E8        	bne del_start
002A8C  3  60           	rts
002A8D  3               
002A8D  3               ;----------------------------------------------------
002A8D  3               ; Clear sprite table.
002A8D  3               ;
002A8D  3               ; sprtab[0] - sprtab[SPRBUF-1] = 255
002A8D  3               ;----------------------------------------------------
002A8D  3               
002A8D  3               xspr:
002A8D  3  A9 FF        	lda #255		; clear byte.
002A8F  3  A2 00        	ldx #0			; length of table.
002A91  3               xspr0:
002A91  3  9D 2F 3B     	sta sprtab,x		; sprite table.
002A94  3  E8           	inx			; move to next byte.
002A95  3  E0 CC        	cpx #SPRBUF
002A97  3  D0 F8        	bne xspr0		; repeat for rest of table.
002A99  3  60           	rts
002A9A  3               
002A9A  3               ;-------------------------------------------------------------
002A9A  3               ; Initialise all objects.
002A9A  3               ;
002A9A  3               ; Reset current room,y,x to start room,y,x for all objects
002A9A  3               ;-------------------------------------------------------------
002A9A  3               
002A9A  3               .if oflag
002A9A  3               iniob:
002A9A  3  A9 0C        	lda #<objdta 		; objects table.
002A9C  3  85 68        	sta z80_x
002A9E  3  A9 41        	lda #>objdta
002AA0  3  85 69        	sta z80_i
002AA2  3               
002AA2  3  AE 23 28     	ldx numob 		; number of objects in the game.
002AA5  3               iniob0:
002AA5  3  A0 0F        	ldy #15
002AA7  3  B1 68        	lda (z80_ix),y 		; start screen.
002AA9  3  A0 0C        	ldy #12
002AAB  3  91 68        	sta (z80_ix),y 		; set start screen.
002AAD  3               
002AAD  3  A0 10        	ldy #16
002AAF  3  B1 68        	lda (z80_ix),y 		; find start y.
002AB1  3  A0 0D        	ldy #13
002AB3  3  91 68        	sta (z80_ix),y 		; set start y.
002AB5  3               
002AB5  3  A0 11        	ldy #17
002AB7  3  B1 68        	lda (z80_ix),y 		; get initial x.
002AB9  3  A0 0E        	ldy #14
002ABB  3  91 68        	sta (z80_ix),y 		; set x coord.
002ABD  3               
002ABD  3  18           	clc 			; point to next object.
002ABE  3  A5 68        	lda z80_x
002AC0  3  69 12        	adc #18			; distance between objects.
002AC2  3  85 68        	sta z80_x
002AC4  3  90 02        	bcc :+
002AC6  3  E6 69        	inc z80_i
002AC8  3               :
002AC8  3  CA           	dex 			; repeat.
002AC9  3  D0 DA        	bne iniob0
002ACB  3               
002ACB  3  60           	rts
002ACC  3               .endif
002ACC  3               
002ACC  3               ;-----------------------------------------------
002ACC  3               ; Redraw the screen.
002ACC  3               ;
002ACC  3               ; Remove old copy of all sprites for redraw.
002ACC  3               ;-----------------------------------------------
002ACC  3               
002ACC  3               redraw:
002ACC  3               .if gflag
002ACC  3               	lda #$ff
002ACC  3               	sta andeor
002ACC  3               	lda #$00
002ACC  3               	sta andeor+1
002ACC  3               .endif
002ACC  3  A5 69        	lda z80_i 		; place sprite pointer on stack.
002ACE  3  48           	pha
002ACF  3  A5 68        	lda z80_x
002AD1  3  48           	pha
002AD2  3               
002AD2  3  20 12 31     	jsr droom		; show screen layout.
002AD5  3               .if oflag
002AD5  3  20 F3 2C     	jsr shwob		; draw objects.
002AD8  3               .endif
002AD8  3               numsp0:
002AD8  3  A9 0C        	lda #NUMSPR		; sprites to draw.
002ADA  3  8D 0F 2B     	sta tmpbyte
002ADD  3               
002ADD  3  A9 2F        	lda #<sprtab		; sprite table.
002ADF  3  85 68        	sta z80_x
002AE1  3  A9 3B        	lda #>sprtab
002AE3  3  85 69        	sta z80_i
002AE5  3               redrw0:
002AE5  3  A0 00        	ldy #0
002AE7  3  B1 68        	lda (z80_ix),y		; old sprite type.
002AE9  3  C9 FF        	cmp #255		; is it enabled?
002AEB  3  F0 0B        	beq redrw1 		; no, find next one.
002AED  3               
002AED  3  A0 03        	ldy #3
002AEF  3  B1 68        	lda (z80_ix),y 		; sprite y.
002AF1  3  C9 B1        	cmp #177		; beyond maximum?
002AF3  3  B0 03        	bcs redrw1		; yes, nothing to draw.
002AF5  3               
002AF5  3  20 05 46     	jsr sspria		; show single sprite.
002AF8  3               redrw1:
002AF8  3  18           	clc			; next sprite.
002AF9  3  A5 68        	lda z80_x
002AFB  3  69 11        	adc #TABSIZ		; distance to next odd/even entry.
002AFD  3  85 68        	sta z80_x
002AFF  3  90 02        	bcc :+
002B01  3  E6 69        	inc z80_i
002B03  3               :
002B03  3  CE 0F 2B     	dec tmpbyte			; repeat for remaining sprites.
002B06  3  D0 DD        	bne redrw0
002B08  3               rpblc1:
002B08  3               ;	jsr dshrp		; redraw shrapnel.
002B08  3               
002B08  3               .if aflag
002B08  3               	jsr rbloc		; draw blocks for this screen
002B08  3               .endif
002B08  3  68           	pla			; retrieve sprite pointer.
002B09  3  85 68        	sta z80_x
002B0B  3  68           	pla
002B0C  3  85 69        	sta z80_i
002B0E  3               
002B0E  3  60           	rts
002B0F  3               
002B0F  3  00           tmpbyte:	.byte 0
002B10  3               ;----------------------------------------------------------------------
002B10  3               ; Atomic palette is static
002B10  3               ;----------------------------------------------------------------------
002B10  3               
002B10  3               setpal:
002B10  3  60           	rts
002B11  3               
002B11  3               ;----------------------------------------------------------------------
002B11  3               ; FODDER check
002B11  3               ;----------------------------------------------------------------------
002B11  3               
002B11  3               .if pflag .or dflag
002B11  3               fdchk:
002B11  3               	cmp #FODDER 		; is it fodder?
002B11  3               	beq :+
002B11  3               	rts 			; no.
002B11  3               :
002B11  3               	lda #0			; wipe fodder in MAP
002B11  3               	ldy #0
002B11  3               	sta (bufaddr),y 	; rewrite block type.
002B11  3               
002B11  3               	lda bufaddr		; calculate screenaddr
002B11  3               	sta scraddr
002B11  3               	sec
002B11  3               	lda bufaddr+1
002B11  3               	sbc #>(MAP-ScreenAddr)	;$d4
002B11  3               	sta scraddr+1
002B11  3               
002B11  3               	lda #0
002B11  3               	ldy #0			; erase block on screen
002B11  3               	sta (scraddr),y
002B11  3               
002B11  3               	rts
002B11  3               .endif
002B11  3               
002B11  3               ;----------------------------------------------------
002B11  3               ; Scrolly text and puzzle variables.
002B11  3               ;----------------------------------------------------
002B11  3               
002B11  3               .if sflag
002B11  3               txtbit:	.byte 128		; bit to write.
002B11  3               txtwid:	.byte 16		; width of ticker message.
002B11  3               txtpos:	.word msgdat
002B11  3               txtini:	.word msgdat
002B11  3               txtscr:	.word ScreenAddr
002B11  3               .endif
002B11  3               
002B11  3               ;----------------------------------------------------
002B11  3               ; Specialist routines.
002B11  3               ; Process shrapnel.
002B11  3               ;----------------------------------------------------
002B11  3               proshr:
002B11  3               .if pflag
002B11  3               	lda #<SHRAPN		; table.
002B11  3               	sta z80_x
002B11  3               	lda #>SHRAPN
002B11  3               	sta z80_i
002B11  3               
002B11  3               	lda #NUMSHR		; shrapnel pieces to process.
002B11  3               	sta shrctr
002B11  3               prosh0:
002B11  3               	ldy #0
002B11  3               	lda (z80_ix),y		; on/off marker.
002B11  3               	asl a
002B11  3               proshx:
002B11  3               	bcs :+
002B11  3               	jsr prosh1 		; on, so process it.
002B11  3               :
002B11  3               	clc
002B11  3               	lda z80_x
002B11  3               	adc #SHRSIZ
002B11  3               	sta z80_x
002B11  3               	bcc :+
002B11  3               	inc z80_i
002B11  3               :
002B11  3               	dec shrctr		; round again.
002B11  3               	bne prosh0
002B11  3               .endif
002B11  3               .if sflag
002B11  3               	jsr scrly
002B11  3               .endif
002B11  3  60           	rts
002B12  3               
002B12  3               .if pflag
002B12  3               ;shrctr:	.byte 0
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Proces shrapnel piece
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               prosh1:
002B12  3               	jsr plot 		; delete the pixel.
002B12  3               
002B12  3               	lda #<shrptr		; shrapnel routine pointers.
002B12  3               	sta z80_l
002B12  3               	lda #>shrptr
002B12  3               	sta z80_h
002B12  3               
002B12  3               	ldy #0
002B12  3               	lda (z80_ix),y		; restore shrapnel type.
002B12  3               	jsr prosh2 		; run the routine.
002B12  3               	jsr chkxy		; check x and y are good before we redisplay.
002B12  3               
002B12  3               	lda #<SHRSIZ 		; distance to next.
002B12  3               	sta z80_e
002B12  3               	lda #>SHRSIZ
002B12  3               	sta z80_d
002B12  3               	rts
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Run the routine
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               prosh2:
002B12  3               	asl a 			; 2 bytes per address.
002B12  3               	tay
002B12  3               	lda shrptr,y
002B12  3               	sta z80_l
002B12  3               	lda shrptr+1,y 		; fetch high byte from table.
002B12  3               	sta z80_h
002B12  3               	jmp (z80_hl) 		; jump to routine.
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Paricle routine table
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               shrptr:	.word laser		; laser.
002B12  3               	.word trail		; vapour trail.
002B12  3               	.word shrap		; shrapnel from explosion.
002B12  3               	.word dotl		; horizontal starfield left.
002B12  3               	.word dotr		; horizontal starfield right.
002B12  3               	.word dotu		; vertical starfield up.
002B12  3               	.word dotd		; vertical starfield down.
002B12  3               	.word ptcusr		; user particle.
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Explosion shrapnel.
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               shrap:
002B12  3               	ldy #1
002B12  3               	lda (z80_ix),y 		; get the angle.
002B12  3               	clc
002B12  3               	adc #<shrsin		; shrapnel sine table.
002B12  3               	sta z80_l
002B12  3               	lda #>shrsin
002B12  3               	adc #0
002B12  3               	sta z80_h
002B12  3               
002B12  3               	ldy #0
002B12  3               	lda (z80_hl),y 		; fetch value from table.
002B12  3               	sta z80_e
002B12  3               	inc z80_l 		; next byte of table.
002B12  3               	bne :+
002B12  3               	inc z80_h
002B12  3               :
002B12  3               	ldy #0
002B12  3               	lda (z80_hl),y		; fetch value from table.
002B12  3               	sta z80_d
002B12  3               	inc z80_l		; next byte of table.
002B12  3               	bne :+
002B12  3               	inc z80_h
002B12  3               :
002B12  3               	ldy #0
002B12  3               	lda (z80_hl),y 		; fetch value from table.
002B12  3               	sta z80_c
002B12  3               	inc z80_l 		; next byte of table.
002B12  3               	bne :+
002B12  3               	inc z80_h
002B12  3               :
002B12  3               	ldy #0
002B12  3               	lda (z80_hl),y 		; fetch value from table.
002B12  3               	sta z80_b
002B12  3               
002B12  3               	ldy #2
002B12  3               	lda (z80_ix),y 		; x coordinate in hl.
002B12  3               	clc
002B12  3               	adc z80_e		; add sine lb
002B12  3               	sta (z80_ix),y		; store new coordinate lb.
002B12  3               	ldy #3
002B12  3               	lda (z80_ix),y
002B12  3               	adc z80_d		; add sine hb
002B12  3               	sta (z80_ix),y		; store new coordinate hb.
002B12  3               
002B12  3               	ldy #4
002B12  3               	lda (z80_ix),y	 	; y coordinate in hl.
002B12  3               	clc
002B12  3               	adc z80_c		; add cosine lb
002B12  3               	sta (z80_ix),y		; store new coordinate lb.
002B12  3               	ldy #5
002B12  3               	lda (z80_ix),y
002B12  3               	adc z80_b		; add cosine lb
002B12  3               	sta (z80_ix),y		; store new coordinate hb.
002B12  3               
002B12  3               	rts
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Move dots
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               dotl:
002B12  3               	ldy #5
002B12  3               	lda (z80_ix),y
002B12  3               	sec
002B12  3               	sbc #1		 	; move left.
002B12  3               	sta (z80_ix),y
002B12  3               	rts
002B12  3               dotr:
002B12  3               	ldy #5
002B12  3               	lda (z80_ix),y
002B12  3               	clc
002B12  3               	adc #1		 	; move left.
002B12  3               	sta (z80_ix),y
002B12  3               	rts
002B12  3               dotu:
002B12  3               	ldy #3
002B12  3               	lda (z80_ix),y
002B12  3               	sec
002B12  3               	sbc #1		 	; move up.
002B12  3               	sta (z80_ix),y
002B12  3               	rts
002B12  3               dotd:
002B12  3               	ldy #3
002B12  3               	lda (z80_ix),y
002B12  3               	clc
002B12  3               	adc #1			; move down.
002B12  3               	sta (z80_ix),y
002B12  3               	rts
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Check if coordinates are ok before redrawing at new position.
002B12  3               ;
002B12  3               ; left:   X>L		X=L	Ok
002B12  3               ; right:  R+15>X	X=R	Ok
002B12  3               ; top:    Y>T		Y=T	Ok
002B12  3               ; bottom: B+15>Y	Y=B	Ok
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               chkxy:
002B12  3               
002B12  3               ; top:    Y>T		Y=T	Ok
002B12  3               
002B12  3               	ldy #3
002B12  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
002B12  3               	cmp wntopx		; window top.
002B12  3               	bcs :+			; compare with top window limit.
002B12  3               	jmp kilshr		; out of window, kill shrapnel.
002B12  3               :
002B12  3               ; left:   X>L		X=L	Ok
002B12  3               
002B12  3               	ldy #5
002B12  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
002B12  3               	cmp wnlftx		; left edge.
002B12  3               	bcs :+			; compare with left window limit.
002B12  3               	jmp kilshr		; out of window, kill shrapnel.
002B12  3               :
002B12  3               ; bottom: B+15>Y	Y=B	Ok
002B12  3               
002B12  3               	lda wnbotx		; point to bottom.
002B12  3               	ldy #3
002B12  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
002B12  3               	bcs :+			; compare with shrapnel x coordinate.
002B12  3               	jmp kilshr		; off screen, kill shrapnel..
002B12  3               :
002B12  3               ; right:  R+15>X	X=R	Ok
002B12  3               	lda wnrgtx		; point to right edge.
002B12  3               	ldy #5
002B12  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
002B12  3               	bcs :+			; compare with window limit.
002B12  3               	jmp kilshr		; off screen, kill shrapnel.
002B12  3               :
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Drop through.
002B12  3               ; Display shrapnel.
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               plot:
002B12  3               	ldy #3
002B12  3               	lda (z80_ix),y		; y integer.
002B12  3               	sta dispy	 	; workspace coordinates.
002B12  3               	ldy #5
002B12  3               	lda (z80_ix),y	 	; x integer.
002B12  3               	sta dispx 		; workspace coordinates.
002B12  3               
002B12  3               	ldy #0
002B12  3               	lda (z80_ix),y 		; type.
002B12  3               	bne :+			; is it a laser?
002B12  3               	jmp plot1 		; yes, draw laser instead.
002B12  3               :
002B12  3               plot0:
002B12  3               	lda dispx		; which pixel within byte do we
002B12  3               	and #1			; want to set first?
002B12  3               	tay
002B12  3               	lda dots,y 		; table of small pixel positions.
002B12  3               	sta z80_e 		; get value.
002B12  3               
002B12  3               	jsr scadd 		; screen address.
002B12  3               	ldy #0
002B12  3               	lda (scraddr),y		; see what's already there.
002B12  3               	eor z80_e
002B12  3               	ora #$20
002B12  3               	sta (scraddr),y 	; put back on screen.
002B12  3               	rts
002B12  3               
002B12  3               plot1:
002B12  3               	jsr scadd 		; screen address.
002B12  3               	ldy #0
002B12  3               	lda (scraddr),y 	; fetch byte there.
002B12  3               	eor #12 		; toggle all bits.
002B12  3               	ora #$20
002B12  3               	sta (scraddr),y 	; new byte.
002B12  3               	rts
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Switch off shrapnel
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               kilshr:
002B12  3               	lda #128
002B12  3               	ldy #0
002B12  3               	sta (z80_ix),y	; switch off shrapnel.
002B12  3               	rts
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Sine/cosine table
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               shrsin:	.word 0,1024,391,946,724,724,946,391
002B12  3               	.word 1024,0,946,65144,724,64811,391,64589
002B12  3               	.word 0,64512,65144,64589,64811,64811,64589,65144
002B12  3               	.word 64512,0,64589,391,64811,724,65144,946
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Create trail
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               trail:
002B12  3               	ldy #1
002B12  3               	lda (z80_ix),y 	; time remaining.
002B12  3               	sec
002B12  3               	sbc #1
002B12  3               	sta (z80_ix),y
002B12  3               	bne :+
002B12  3               	jmp trailk		; time to switch it off.
002B12  3               :
002B12  3               	jsr qrand		; get a random number.
002B12  3               	lsr a 			; x or y axis?
002B12  3               	bcc :+
002B12  3               	jmp trailv		; use y.
002B12  3               :
002B12  3               ; Trail horizontal
002B12  3               
002B12  3               	lsr a 			; which direction?
002B12  3               	bcc :+
002B12  3               	jmp traill		; go left.
002B12  3               :
002B12  3               ; Trail right
002B12  3               
002B12  3               	ldy #5
002B12  3               	lda (z80_ix),y
002B12  3               	clc
002B12  3               	adc #1	 		; go right.
002B12  3               	sta (z80_ix),y
002B12  3               	rts
002B12  3               
002B12  3               ; Trail left
002B12  3               
002B12  3               traill:
002B12  3               	ldy #5
002B12  3               	lda (z80_ix),y
002B12  3               	sec
002B12  3               	sbc #1 			; go left.
002B12  3               	sta (z80_ix),y
002B12  3               	rts
002B12  3               
002B12  3               ; Trail vertical
002B12  3               
002B12  3               trailv:
002B12  3               	lsr a		 	; which direction?
002B12  3               	bcc :+
002B12  3               	jmp trailu		; go up.
002B12  3               :
002B12  3               ; Trail down
002B12  3               
002B12  3               	ldy #3
002B12  3               	lda (z80_ix),y
002B12  3               	clc
002B12  3               	adc #1 			; go down.
002B12  3               	sta (z80_ix),y
002B12  3               	rts
002B12  3               
002B12  3               ; Trail up
002B12  3               
002B12  3               trailu:
002B12  3               	ldy #3
002B12  3               	lda (z80_ix),y
002B12  3               	sec
002B12  3               	sbc #1 			; go up.
002B12  3               	sta (z80_ix),y
002B12  3               	rts
002B12  3               
002B12  3               ; Kill trail
002B12  3               
002B12  3               trailk:
002B12  3               	lda #200		; set off-screen to kill vapour trail.
002B12  3               	ldy #3
002B12  3               	sta (z80_ix),y
002B12  3               	rts
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Create laser beam
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               laser:
002B12  3               	ldy #1
002B12  3               	lda (z80_ix),y 		; direction.
002B12  3               	ror a 			; left or right?
002B12  3               	bcc :+
002B12  3               	jmp laserl		; move left.
002B12  3               :
002B12  3               ; Laser right
002B12  3               
002B12  3               	lda #2			; distance to travel.
002B12  3               	sta z80_b
002B12  3               	jmp laserm		; move laser.
002B12  3               
002B12  3               ; Laser left
002B12  3               
002B12  3               laserl:
002B12  3               	lda #254		; distance to travel.
002B12  3               	sta z80_b
002B12  3               laserm:
002B12  3               	ldy #5
002B12  3               	lda (z80_ix),y		; x position.
002B12  3               	clc
002B12  3               	adc z80_b		; add distance.
002B12  3               	sta (z80_ix),y		; set new x coordinate.
002B12  3               
002B12  3               ; Test new block.
002B12  3               
002B12  3               	sta dispx 		; set x for block collision detection purposes.
002B12  3               	ldy #3
002B12  3               	lda (z80_ix),y 		; get y.
002B12  3               	sta dispy		; set coordinate for collision test.
002B12  3               	jsr tstbl 		; get block type there.
002B12  3               	cmp #WALL		; is it solid?
002B12  3               	bne :+
002B12  3               	jmp trailk		; yes, it cannot pass.
002B12  3               :
002B12  3               .if pflag .or dflag
002B12  3                       cmp #FODDER             ; is it fodder?
002B12  3                       bne :+
002B12  3                       jsr fdchk               ; remove fodder block.
002B12  3                       jmp trailk              ; destroy laser.
002B12  3               :
002B12  3               .endif
002B12  3                       rts                     ; no, ignore it.
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Dots mask
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               dots:	.byte 2,1
002B12  3               
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Plot, preserving de.
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               plotde:
002B12  3               	lda z80_d 		; put de on stack.
002B12  3               	pha
002B12  3               	lda z80_e
002B12  3               	pha
002B12  3               
002B12  3               	jsr plot 		; plot pixel.
002B12  3               
002B12  3               	pla			; restore de from stack.
002B12  3               	sta z80_e
002B12  3               	pla
002B12  3               	sta z80_d
002B12  3               
002B12  3               	rts
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Shoot a laser.
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               shoot:
002B12  3               	sta z80_c		; store type in c register.
002B12  3               	ldy #8
002B12  3               	lda (z80_ix),y 		; y coordinate.
002B12  3               	clc
002B12  3               shoot1:
002B12  3               	adc #(SPR_HGT/2)	; down 4 pixels.
002B12  3               	sta z80_l 		; y coordinate in l.
002B12  3               
002B12  3               	ldy #9
002B12  3               	lda (z80_ix),y 		; x coordinate in h.
002B12  3               	sta z80_h
002B12  3               
002B12  3               	lda z80_i		; store pointer to sprite.
002B12  3               	pha
002B12  3               	lda z80_x
002B12  3               	pha
002B12  3               
002B12  3               	jsr fpslot 		; find particle slot.
002B12  3               	bcs :+
002B12  3               	jmp vapou2		; failed, restore ix.
002B12  3               :
002B12  3               	lda #0
002B12  3               	ldy #0
002B12  3               	sta (z80_ix),y 		; set up type laser.
002B12  3               
002B12  3               	lda z80_c
002B12  3               	ldy #1
002B12  3               	sta (z80_ix),y 		; set the direction.
002B12  3               
002B12  3               	lda z80_l
002B12  3               	ldy #3
002B12  3               	sta (z80_ix),y		; set y coordinate.
002B12  3               
002B12  3               	ror z80_c		; check direction we want.
002B12  3               	bcs :+
002B12  3               	jmp shootr		; shoot right.
002B12  3               :
002B12  3               	lda z80_h		; X position.
002B12  3               shoot0:
002B12  3               	and #$fe		; align on character boundary.
002B12  3               	ldy #5
002B12  3               	sta (z80_ix),y		; set x coordinate.
002B12  3               	jmp vapou0 		; draw first image.
002B12  3               shootr:
002B12  3               	lda z80_h		; x position.
002B12  3               	clc
002B12  3               	adc #SPR_WID-1		; look right.
002B12  3               	jmp shoot0		; align and continue.
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Create a bit of vapour trail.
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               vapour:
002B12  3               	lda z80_i		; store pointer to sprite.
002B12  3               	pha
002B12  3               	lda z80_x
002B12  3               	pha
002B12  3               
002B12  3               	ldy #8
002B12  3               	lda (z80_ix),y 		; y coordinate.
002B12  3               	clc
002B12  3               vapou3:
002B12  3               	adc #(SPR_HGT/2-1)	; mid-point of sprite.
002B12  3               	sta z80_l
002B12  3               
002B12  3               	ldy #9
002B12  3               	lda (z80_ix),y 		; x coordinate.
002B12  3               	adc #7
002B12  3               	sta z80_h
002B12  3               
002B12  3               	jsr fpslot 		; find particle slot.
002B12  3               	bcc :+
002B12  3               	jmp vapou1		; no, we can use it.
002B12  3               :
002B12  3               vapou2:
002B12  3               	pla
002B12  3               	sta z80_x
002B12  3               	pla
002B12  3               	sta z80_i
002B12  3               	rts
002B12  3               vapou1:
002B12  3               	lda z80_l
002B12  3               	ldy #3
002B12  3               	sta (z80_ix),y		; set up y.
002B12  3               
002B12  3               	lda z80_h
002B12  3               	ldy #5
002B12  3               	sta (z80_ix),y 		; set up x coordinate.
002B12  3               
002B12  3               	jsr qrand		; get quick random number.
002B12  3               	and #15			; random time.
002B12  3               	clc
002B12  3               	adc #15			; minimum time on screen.
002B12  3               	ldy #1
002B12  3               	sta (z80_ix),y		; set time on screen.
002B12  3               
002B12  3               	lda #1
002B12  3               	ldy #0
002B12  3               	sta (z80_ix),y		; define particle as vapour trail.
002B12  3               vapou0:
002B12  3               	jsr chkxy		; plot first position.
002B12  3               	jmp vapou2
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Create a user particle.
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               ptusr:
002B12  3               	sta z80_f		; store timer.
002B12  3               
002B12  3               	ldy #8
002B12  3               	lda (z80_ix),y 		; y coordinate.
002B12  3               	clc
002B12  3               	adc #7			; mid-point of sprite.
002B12  3               	sta z80_l
002B12  3               
002B12  3               	ldy #9
002B12  3               	lda (z80_ix),y 		; x coordinate.
002B12  3               	clc
002B12  3               	adc #7			; mid-point of sprite.
002B12  3               	sta z80_h
002B12  3               
002B12  3               	jsr fpslot 		; find particle slot.
002B12  3               	bcs ptusr1
002B12  3               	rts 			; out of slots, can't generate anything.
002B12  3               ptusr1:
002B12  3               	lda z80_l
002B12  3               	ldy #3
002B12  3               	sta (z80_ix),y 		; set up y.
002B12  3               
002B12  3               	lda z80_h
002B12  3               	ldy #5
002B12  3               	sta (z80_ix),y		; set up x coordinate.
002B12  3               
002B12  3               	lda z80_f 		; restore timer.
002B12  3               	ldy #1
002B12  3               	sta (z80_ix),y		; set time on screen.
002B12  3               
002B12  3               	lda #7
002B12  3               	ldy #0
002B12  3               	sta (z80_ix),y		; define particle as user particle.
002B12  3               
002B12  3               	jmp chkxy		; plot first position.
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Create a vertical or horizontal star.
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               star:
002B12  3               	lda z80_i		; store pointer to sprite.
002B12  3               	pha
002B12  3               	lda z80_x
002B12  3               	pha
002B12  3               
002B12  3               	jsr fpslot 		; find particle slot.
002B12  3               	bcs star7		; found one we can use.
002B12  3               star0:
002B12  3               	pla 			; restore sprite pointer.
002B12  3               	sta z80_x
002B12  3               	pla
002B12  3               	sta z80_i
002B12  3               	rts 			; out of slots, can't generate anything.
002B12  3               star7:
002B12  3               	lda z80_c		; direction.
002B12  3               	and #3 			; is it left?
002B12  3               	bne :+
002B12  3               	jmp star1 		; yes, it's left.
002B12  3               :
002B12  3               	cmp #1 			; is it right?
002B12  3               	bne :+
002B12  3               	jmp star2 		; yes, it's right.
002B12  3               :
002B12  3               	cmp #2 			; is it up?
002B12  3               	bne :+
002B12  3               	jmp star3 		; yes, it's up.
002B12  3               :
002B12  3               	ldy wntopx 		; get edge of screen.
002B12  3               	iny			; down one pixel.
002B12  3               	tya
002B12  3               star8:
002B12  3               	ldy #3
002B12  3               	sta (z80_ix),y 		; set y coord.
002B12  3               	jsr qrand 		; get quick random number.
002B12  3               star9:
002B12  3               	ldy #5
002B12  3               	sta (z80_ix),y		; set x position.
002B12  3               
002B12  3               	lda z80_c		; direction.
002B12  3               	and #3			; zero to three.
002B12  3               	clc
002B12  3               	adc #3			; 3 to 6 for starfield.
002B12  3               	ldy #0
002B12  3               	sta (z80_ix),y		; define particle as star.
002B12  3               	jsr chkxy		; plot first position.
002B12  3               	jmp star0
002B12  3               star1:
002B12  3               	jsr qrand		; get quick random number.
002B12  3               	ldy #3
002B12  3               	sta (z80_ix),y 		; set y coord.
002B12  3               
002B12  3               	lda wnrgtx 		; get edge of screen.
002B12  3               	clc
002B12  3               	adc #15			; add width of sprite minus 1.
002B12  3               	jmp star9
002B12  3               star2:
002B12  3               	jsr qrand 		; get quick random number.
002B12  3               	ldy #3
002B12  3               	sta (z80_ix),y		; set y coord.
002B12  3               
002B12  3               	lda wnlftx		; get edge of screen.
002B12  3               	jmp star9
002B12  3               star3:
002B12  3               	lda wnbotx 		; get edge of screen.
002B12  3               	clc
002B12  3               	adc #15 		; height of sprite minus one pixel.
002B12  3               	jmp star8
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Find particle slot for lasers or vapour trail.
002B12  3               ; can't use alternate accumulator.
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               fpslot:
002B12  3               	lda #<SHRAPN 		; shrapnel table.
002B12  3               	sta z80_x
002B12  3               	lda #>SHRAPN
002B12  3               	sta z80_i
002B12  3               
002B12  3               	lda #NUMSHR		; number of pieces in table.
002B12  3               	sta z80_b
002B12  3               fpslt0:
002B12  3               	ldy #0
002B12  3               	lda (z80_ix),y		; get type.
002B12  3               	asl a  			; is this slot in use?
002B12  3               	bcc :+
002B12  3               	rts			; no, we can use it.
002B12  3               :
002B12  3               	clc			; point to more shrapnel.
002B12  3               	lda z80_x
002B12  3               	adc #SHRSIZ
002B12  3               	sta z80_x
002B12  3               	bcc :+
002B12  3               	inc z80_i
002B12  3               :
002B12  3               	dec z80_b		; repeat for all shrapnel.
002B12  3               	bne fpslt0
002B12  3               
002B12  3               	clc
002B12  3               	rts 			; out of slots, can't generate anything.
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Create an explosion at sprite position.
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               explod:
002B12  3               	sta z80_c 		; particles to create.
002B12  3               
002B12  3               	lda z80_i 		; store pointer to sprite.
002B12  3               	pha
002B12  3               	lda z80_x
002B12  3               	pha
002B12  3               
002B12  3               	ldy #8
002B12  3               	lda (z80_ix),y 		; y coordinate.
002B12  3               	sta z80_l
002B12  3               	ldy #9
002B12  3               	lda (z80_ix),y		; x coordinate.
002B12  3               	sta z80_h
002B12  3               
002B12  3               	lda #<SHRAPN		; shrapnel table.
002B12  3               	sta z80_x
002B12  3               	lda #>SHRAPN
002B12  3               	sta z80_i
002B12  3               
002B12  3               	lda #NUMSHR		; number of pieces in table.
002B12  3               	sta explcnt
002B12  3               expld0:
002B12  3               	ldy #0
002B12  3               	lda (z80_ix),y		; get type.
002B12  3               	asl a 			; is this slot in use?
002B12  3               	bcs expld1		; no, we can use it.
002B12  3               expld2:
002B12  3               	clc
002B12  3               	lda z80_x
002B12  3               	adc #SHRSIZ
002B12  3               	sta z80_x
002B12  3               	bcc :+
002B12  3               	inc z80_i
002B12  3               :
002B12  3               	dec explcnt		; repeat for all shrapnel.
002B12  3               	bne expld0
002B12  3               expld3:
002B12  3               	pla			; restore sprite pointer.
002B12  3               	sta z80_x
002B12  3               	pla
002B12  3               	sta z80_i
002B12  3               	rts 			; out of slots, can't generate any more.
002B12  3               
002B12  3               expld1:
002B12  3               	lda z80_c		; shrapnel counter.
002B12  3               	and #15			; 0 to 15.
002B12  3               	clc			; add to x.
002B12  3               	adc z80_l
002B12  3               	ldy #3
002B12  3               	sta (z80_ix),y		; y coord.
002B12  3               
002B12  3               	lda seed3 		; crap random number.
002B12  3               	and #15			; 0 to 15.
002B12  3               	clc 			; add to y.
002B12  3               	adc z80_h
002B12  3               	ldy #5
002B12  3               	sta (z80_ix),y		; x coord.
002B12  3               
002B12  3               	lda #2
002B12  3               	ldy #0
002B12  3               	sta (z80_ix),y		; switch it on.
002B12  3               
002B12  3               	jsr chkxy		; plot first position.
002B12  3               	jsr qrand		; quick random angle.
002B12  3               	and #60 		; keep within range.
002B12  3               	ldy #1
002B12  3               	sta (z80_ix),y		; angle.
002B12  3               
002B12  3               	dec z80_c		; one less piece of shrapnel to generate.
002B12  3               	bne expld2 		; back to main explosion loop.
002B12  3               	jmp expld3 		; restore sprite pointer and exit.
002B12  3               
002B12  3               ;explcnt:	.byte 0
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Quick random
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               qrand:
002B12  3               	jsr random		; r register.
002B12  3               	eor seed3		; combine with seed.
002B12  3               	sta seed3 		; new seed.
002B12  3               	rts
002B12  3               
002B12  3               ;seed3:	.byte 0
002B12  3               
002B12  3               ;----------------------------------------------------
002B12  3               ; Display all shrapnel.
002B12  3               ;----------------------------------------------------
002B12  3               
002B12  3               dshrp:
002B12  3               	lda #<plotde		; display routine.
002B12  3               	sta proshx+1
002B12  3               	lda #>plotde
002B12  3               	sta proshx+2
002B12  3               	jsr proshr		; process shrapnel.
002B12  3               
002B12  3               	lda #<prosh1		; processing routine.
002B12  3               	sta proshx+1
002B12  3               	lda #>prosh1
002B12  3               	sta proshx+2
002B12  3               	rts
002B12  3               
002B12  3               ;------------------------------------------------------
002B12  3               ; Particle engine.
002B12  3               ;
002B12  3               ; Init particle data for 55 particles in SHRAPN table.
002B12  3               ; Every particle has 6 bytes.
002B12  3               ;
002B12  3               ; global:	-
002B12  3               ; local:	x,y,hl
002B12  3               ; calls:	-
002B12  3               ;------------------------------------------------------
002B12  3               
002B12  3               inishr:
002B12  3               	lda #<SHRAPN 		; table.
002B12  3               	sta z80_l
002B12  3               	lda #>SHRAPN
002B12  3               	sta z80_h
002B12  3               
002B12  3               	ldy #0
002B12  3               	ldx #NUMSHR		; shrapnel pieces to process.
002B12  3               inish0:
002B12  3               	lda #255 		; kill the shrapnel.
002B12  3               	sta (z80_hl),y
002B12  3               
002B12  3               	clc 			; point there.
002B12  3               	lda z80_l
002B12  3               	adc #SHRSIZ		; distance to next.
002B12  3               	sta z80_l
002B12  3               	bcc :+
002B12  3               	inc z80_h
002B12  3               :
002B12  3               	dex
002B12  3               	bne inish0 		; round again.
002B12  3               	rts
002B12  3               
002B12  3               ;------------------------------------------------------
002B12  3               ; Check for collision between laser and sprite.
002B12  3               ;------------------------------------------------------
002B12  3               
002B12  3               lcol:
002B12  3               	lda #<SHRAPN		; shrapnel table.
002B12  3               	sta z80_l
002B12  3               	lda #>SHRAPN
002B12  3               	sta z80_h
002B12  3               
002B12  3               	lda #NUMSHR		; number of pieces in table.
002B12  3               	sta z80_b
002B12  3               lcol0:
002B12  3               	ldy #0
002B12  3               	lda (z80_hl),y 		; get type.
002B12  3               	beq lcol1		; yes, check collision.
002B12  3               lcol3:
002B12  3               	clc			; point to more shrapnel.
002B12  3               	lda z80_l
002B12  3               	adc #SHRSIZ
002B12  3               	sta z80_l
002B12  3               	bcc :+
002B12  3               	inc z80_h
002B12  3               :
002B12  3               	dec z80_b		; repeat for all shrapnel.
002B12  3               	bne lcol0
002B12  3               	rts 			; no collision, carry not set.
002B12  3               lcol1:
002B12  3               	ldy #3
002B12  3               	lda (z80_hl),y		; get y.
002B12  3               	sec
002B12  3               	ldy #8
002B12  3               	sbc (z80_ix),y		; subtract sprite y.
002B12  3               lcolh:
002B12  3               	cmp #SPR_HGT 		; within range?
002B12  3               	bcc :+
002B12  3               	jmp lcol2		; no, missed.
002B12  3               :
002B12  3               	ldy #5
002B12  3               	lda (z80_hl),y 		; get x.
002B12  3               	sec
002B12  3               	ldy #9
002B12  3               	sbc (z80_ix),y 		; subtract sprite y.
002B12  3               	cmp #SPR_WID		; within range?
002B12  3               	bcs :+
002B12  3               	jmp lcol4 		; yes, collision occurred.
002B12  3               :
002B12  3               lcol2:
002B12  3               	jmp lcol3
002B12  3               lcol4:
002B12  3               	sec
002B12  3               	rts 			; return with carry set for collision.
002B12  3               .endif
002B12  3               
002B12  3               ;------------------------------------------------------
002B12  3               ; Main game engine code starts here.
002B12  3               ; After initialisation, mloop is the main loop
002B12  3               ;------------------------------------------------------
002B12  3               
002B12  3               game:
002B12  3               
002B12  3               
002B12  3               ; Init hardware and graphics mode
002B12  3               
002B12  3  20 A8 44     	jsr init 		; Init hardware
002B15  3               
002B15  3               ; Init joystick
002B15  3               
002B15  3  20 B4 45     	jsr joyinit		; Init joystick
002B18  3               
002B18  3               rpblc2:
002B18  3               .if pflag
002B18  3               	jsr inishr 		; initialise particle engine.
002B18  3               .endif
002B18  3               evintr:
002B18  3  20 C0 3D     	jsr evnt12 		; call intro/menu event.
002B1B  3               
002B1B  3  A9 02        	lda #WALL 		; write default property.
002B1D  3  A2 00        	ldx #0
002B1F  3               clrmap:
002B1F  3  9D 00 D8     	sta MAP,x 		; block properties.
002B22  3  9D 00 D9     	sta MAP+256,x
002B25  3  9D 00 DA     	sta MAP+512,x
002B28  3  9D 00 DB     	sta MAP+768,x
002B2B  3  E8           	inx			; next byte.
002B2C  3  D0 F1        	bne clrmap
002B2E  3               
002B2E  3               .if oflag
002B2E  3  20 9A 2A     	jsr iniob 		; initialise objects.
002B31  3               .endif
002B31  3  A9 00        	lda #0			; put zero in accumulator.
002B33  3  85 rr        	sta gamwon		; reset game won flag.
002B35  3               
002B35  3  20 A3 2C     	jsr inisc 		; init the score.
002B38  3               mapst:
002B38  3  AD 29 3C     	lda stmap 		; start position on map.
002B3B  3  8D 0C 3C     	sta roomtb		; set up position in table, if there is one.
002B3E  3               
002B3E  3               inipbl:
002B3E  3               .if aflag
002B3E  3               	lda #<eop		; reset blockpointer
002B3E  3               	sta pbptr
002B3E  3               	lda #>eop
002B3E  3               	sta pbptr+1
002B3E  3               .endif
002B3E  3               
002B3E  3  20 F4 37     	jsr initsc 		; set up first screen.
002B41  3               
002B41  3  A9 FB        	lda #<ssprit 		; default to spare sprite in table.
002B43  3  85 68        	sta z80_x
002B45  3  A9 3B        	lda #>ssprit
002B47  3  85 69        	sta z80_i
002B49  3               evini:
002B49  3  20 C1 3D     	jsr evnt13 		; initialisation.
002B4C  3               
002B4C  3               ; Two restarts.
002B4C  3               ; First restart - clear all sprites and initialise everything.
002B4C  3               
002B4C  3               rstrt:
002B4C  3  20 43 2C     	jsr rsevt 		; restart events.
002B4F  3  20 8D 2A     	jsr xspr 		; clear sprite table.
002B52  3  20 60 39     	jsr sprlst 		; fetch pointer to screen sprites.
002B55  3  20 E9 39     	jsr ispr 		; initialise sprite table.
002B58  3               
002B58  3  4C 67 2B     	jmp rstrt0
002B5B  3               
002B5B  3               ; Second restart - clear all but player, and don't initialise him.
002B5B  3               
002B5B  3               rstrtn:
002B5B  3  20 43 2C     	jsr rsevt		; restart events.
002B5E  3  20 8D 39     	jsr nspr 		; clear all non-player sprites.
002B61  3  20 60 39     	jsr sprlst 		; fetch pointer to screen sprites.
002B64  3  20 26 3A     	jsr kspr 		; initialise sprite table, no more players.
002B67  3               
002B67  3               ; Set up the player and/or enemy sprites.
002B67  3               
002B67  3               rstrt0:
002B67  3  A9 00        	lda #0 			; zero in accumulator.
002B69  3  85 rr        	sta nexlev 		; reset next level flag.
002B6B  3  85 rr        	sta restfl 		; reset restart flag.
002B6D  3  85 rr        	sta deadf 		; reset dead flag.
002B6F  3               
002B6F  3  20 12 31     	jsr droom 		; show screen layout.
002B72  3               
002B72  3               rpblc0:
002B72  3               .if pflag
002B72  3               	jsr inishr 		; initialise particle engine.
002B72  3               .endif
002B72  3               .if aflag
002B72  3               	jsr rbloc		; draw blocks for this screen
002B72  3               .endif
002B72  3               .if oflag
002B72  3  20 F3 2C     	jsr shwob		; draw objects.
002B75  3               .endif
002B75  3               
002B75  3  A9 2F        	lda #<sprtab 		; address of sprite table, even sprites.
002B77  3  85 68        	sta z80_x
002B79  3  A9 3B        	lda #>sprtab
002B7B  3  85 69        	sta z80_i
002B7D  3  20 A4 35     	jsr dspr 		; display sprites.
002B80  3               
002B80  3  A9 40        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
002B82  3  85 68        	sta z80_x
002B84  3  A9 3B        	lda #>(sprtab+TABSIZ)
002B86  3  85 69        	sta z80_i
002B88  3  20 A4 35     	jsr dspr 		; display sprites.
002B8B  3               
002B8B  3               
002B8B  3               mloop:
002B8B  3  20 90 45     	jsr vsync 		; synchronise with display.
002B8E  3  A9 2F        	lda #<sprtab 		; address of sprite table, even sprites.
002B90  3  85 68        	sta z80_x
002B92  3  A9 3B        	lda #>sprtab
002B94  3  85 69        	sta z80_i
002B96  3  20 A4 35     	jsr dspr 		; display even sprites.
002B99  3               
002B99  3               ;	jsr plsnd 		; play sounds.
002B99  3               
002B99  3  20 11 2B     	jsr proshr
002B9C  3  A9 40        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
002B9E  3  85 68        	sta z80_x
002BA0  3  A9 3B        	lda #>(sprtab+TABSIZ)
002BA2  3  85 69        	sta z80_i
002BA4  3  20 A4 35     	jsr dspr 		; display odd sprites.
002BA7  3               
002BA7  3  A9 FB        	lda #<(ssprit) 		; point to spare sprite for spawning purposes.
002BA9  3  85 68        	sta z80_x
002BAB  3  A9 3B        	lda #>(ssprit)
002BAD  3  85 69        	sta z80_i
002BAF  3               evlp1:
002BAF  3  20 BE 3D     	jsr evnt10 		; called once per main loop.
002BB2  3               
002BB2  3  20 22 35     	jsr pspr 		; process sprites.
002BB5  3               
002BB5  3               ; Main loop events.
002BB5  3               
002BB5  3  A9 FB        	lda #<ssprit 		; point to spare sprite for spawning purposes.
002BB7  3  85 68        	sta z80_x
002BB9  3  A9 3B        	lda #>ssprit
002BBB  3  85 69        	sta z80_i
002BBD  3               evlp2:
002BBD  3  20 BF 3D     	jsr evnt11 		; called once per main loop.
002BC0  3               bsortx:
002BC0  3  20 98 34     	jsr bsort 		; sort sprites.
002BC3  3               
002BC3  3  A5 rr        	lda nexlev		; finished level flag.
002BC5  3  F0 03        	beq :+
002BC7  3  4C EF 2B     	jmp newlev		; is set, go to next level.
002BCA  3               :
002BCA  3  A5 rr        	lda gamwon		; finished game flag.
002BCC  3  F0 03        	beq :+
002BCE  3  4C FE 2B     	jmp evwon		; is set, finish the game.
002BD1  3               :
002BD1  3  A5 rr        	lda restfl 		; finished level flag.
002BD3  3  C9 01        	cmp #1			; has it been set?
002BD5  3  D0 03        	bne :+
002BD7  3  4C 4C 2B     	jmp rstrt		; yes, go to next level.
002BDA  3               :
002BDA  3  C9 02        	cmp #2			; has it been set?
002BDC  3  D0 03        	bne :+
002BDE  3  4C 5B 2B     	jmp rstrtn		; yes, go to next level.
002BE1  3               :
002BE1  3  A5 rr        	lda deadf 		; dead flag.
002BE3  3  F0 03        	beq :+
002BE5  3  4C 04 2C     	jmp pdead		; yes, player dead.
002BE8  3               :
002BE8  3               ; back to start of main loop.
002BE8  3               
002BE8  3  E6 rr        	inc frmno
002BEA  3  E6 rr        	inc clock
002BEC  3  4C 8B 2B     	jmp mloop		; switched to a jmp mloop during test mode.
002BEF  3               
002BEF  3               ;----------------------------------------------------------
002BEF  3               ; Read blocks from list and update screen accordingly.
002BEF  3               ;----------------------------------------------------------
002BEF  3               
002BEF  3               .if aflag
002BEF  3               rbloc:
002BEF  3               	lda #<eop		; reset temp blockpointer
002BEF  3               	sta pbbuf
002BEF  3               	lda #>eop
002BEF  3               	sta pbbuf+1
002BEF  3               
002BEF  3               rbloc2:
002BEF  3               	lda pbbuf			; check for last block
002BEF  3               	cmp pbptr
002BEF  3               	bne rbloc1
002BEF  3               	lda pbbuf+1
002BEF  3               	cmp pbptr+1
002BEF  3               	bne rbloc1
002BEF  3               	rts
002BEF  3               rbloc1:
002BEF  3               	ldy #0
002BEF  3               	lda (pbbuf),y		; check if block for this scno
002BEF  3               	cmp scno
002BEF  3               	bne rbloc0		; if not, skip
002BEF  3               	iny
002BEF  3               	lda (pbbuf),y		; get y
002BEF  3               	sta dispy
002BEF  3               	iny
002BEF  3               	lda (pbbuf),y		; get x
002BEF  3               	sta dispx
002BEF  3               	iny
002BEF  3               	lda (pbbuf),y		; get blocknr
002BEF  3               	jsr pattr2		; draw block
002BEF  3               rbloc0:
002BEF  3               	clc			; point to next block
002BEF  3               	lda pbbuf
002BEF  3               	adc #4
002BEF  3               	sta pbbuf
002BEF  3               	bcc rbloc2
002BEF  3               	inc pbbuf+1
002BEF  3               	jmp rbloc2
002BEF  3               .endif
002BEF  3               
002BEF  3               ;----------------------------------------------------------
002BEF  3               ; New level
002BEF  3               ;----------------------------------------------------------
002BEF  3               
002BEF  3               newlev:
002BEF  3  A5 rr        	lda scno 			; current screen.
002BF1  3  18           	clc
002BF2  3  69 01        	adc #1				; next screen.
002BF4  3  CD 06 41     	cmp numsc			; total number of screens.
002BF7  3  B0 05        	bcs evwon			; yes, game finished.
002BF9  3  85 rr        	sta scno			; set new level number.
002BFB  3  4C 4C 2B     	jmp rstrt			; restart, clearing all aliens.
002BFE  3               
002BFE  3               evwon:
002BFE  3  20 18 3E     	jsr evnt18		 	; game completed.
002C01  3  4C 18 2C     	jmp tidyup			; tidy up and return to BASIC/calling routine.
002C04  3               
002C04  3               ;----------------------------------------------------------
002C04  3               ; Player dead.
002C04  3               ;----------------------------------------------------------
002C04  3               
002C04  3               pdead:
002C04  3  A9 00        	lda #0				; zeroise accumulator.
002C06  3  85 rr        	sta deadf			; reset dead flag.
002C08  3               evdie:
002C08  3  20 EE 3D     	jsr evnt16 			; death subroutine.
002C0B  3  A5 rr        	lda numlif			; number of lives.
002C0D  3  F0 03        	beq :+
002C0F  3  4C 4C 2B     	jmp rstrt 			; restart game.
002C12  3               :
002C12  3               evfail:
002C12  3  20 EF 3D     	jsr evnt17 			; failure event.
002C15  3  4C 12 2B     	jmp game			; restart game
002C18  3               
002C18  3               ;----------------------------------------------------------
002C18  3               ; Tidy things up
002C18  3               ;----------------------------------------------------------
002C18  3               
002C18  3               tidyup:
002C18  3  A0 00        	ldy #0				; digits to check.
002C1A  3               tidyu2:
002C1A  3  B9 AD 2E     	lda score,y 			; get score digit.
002C1D  3  CD B3 2E     	cmp hiscor 			; are we larger than high score digit?
002C20  3  90 07        	bcc tidyu0			; high score is bigger.
002C22  3  D0 0E        	bne tidyu1			; score is greater, record new high score.
002C24  3  C8           	iny				; next digit of high score.
002C25  3  C0 06        	cpy #6
002C27  3  D0 F1        	bne tidyu2			; repeat for all digits
002C29  3               tidyu0:
002C29  3  A9 AD        	lda #<score			; return pointing to score.
002C2B  3  85 62        	sta z80_c
002C2D  3  A9 2E        	lda #>score
002C2F  3  85 63        	sta z80_b
002C31  3  60           	rts
002C32  3               tidyu1:
002C32  3  A0 05        	ldy #5
002C34  3               tidyu3:
002C34  3  B9 AD 2E     	lda score,y			; score.
002C37  3  99 B3 2E     	sta hiscor,y			; high score.
002C3A  3  88           	dey
002C3B  3  10 F7        	bpl tidyu3 			; copy score to high score.
002C3D  3               evnewh:
002C3D  3  20 19 3E     	jsr evnt19			; new high score event.
002C40  3  4C 29 2C     	jmp tidyu0			; tidy up.
002C43  3               
002C43  3               ;--------------------------------------------------
002C43  3               ; Restart event.
002C43  3               ;--------------------------------------------------
002C43  3               
002C43  3               rsevt:
002C43  3  A9 FB        	lda #<ssprit 			; default to spare element in table.
002C45  3  85 68        	sta z80_x
002C47  3  A9 3B        	lda #>ssprit
002C49  3  85 69        	sta z80_i
002C4B  3               evrs:
002C4B  3  4C C2 3D     	jmp evnt14	 		; call restart event.
002C4E  3               
002C4E  3               ;------------------------------------------------------------------
002C4E  3               ; Copy number passed in a to string position bc, right-justified.
002C4E  3               ;
002C4E  3               ; Input:
002C4E  3               ;  A  = number
002C4E  3               ;  BC = string address
002C4E  3               ;
002C4E  3               ; Output:
002C4E  3               ;  BC = string with number
002C4E  3               ;-----------------------------------------------------------------
002C4E  3               
002C4E  3               num2ch:
002C4E  3  85 65        	sta z80_d		; Save number
002C50  3               
002C50  3  A9 00        	lda #0
002C52  3  85 rr        	sta flag
002C54  3               numdg3:
002C54  3  A2 64        	ldx #100		; hundreds column.
002C56  3  86 64        	stx z80_e
002C58  3  20 68 2C     	jsr numdg		; show digit.
002C5B  3               numdg2:
002C5B  3  A2 0A        	ldx #10			; tens column.
002C5D  3  86 64        	stx z80_e
002C5F  3  20 68 2C     	jsr numdg		; show digit.
002C62  3               
002C62  3  E6 rr        	inc flag
002C64  3  A2 01        	ldx #1			; units column.
002C66  3  86 64        	stx z80_e
002C68  3               numdg:
002C68  3  A9 30        	lda #48			; clear digit.
002C6A  3  85 61        	sta z80_a
002C6C  3               numdg1:
002C6C  3  A5 65        	lda z80_d
002C6E  3  C5 64        	cmp z80_e
002C70  3  90 0E        	bcc numdg0		; nothing to show.
002C72  3  38           	sec
002C73  3  A5 65        	lda z80_d
002C75  3  E5 64        	sbc z80_e		; subtract from column.
002C77  3  85 65        	sta z80_d
002C79  3  E6 61        	inc z80_a		; increment digit.
002C7B  3  E6 rr        	inc flag
002C7D  3  4C 6C 2C     	jmp numdg1		; repeat until column is zero.
002C80  3               numdg0:
002C80  3  A0 00        	ldy #0
002C82  3  A5 61        	lda z80_a
002C84  3  91 62        	sta (z80_bc),y		; write digit to buffer.
002C86  3  A5 rr        	lda flag
002C88  3  F0 06        	beq :+
002C8A  3  E6 62        	inc z80_c		; next buffer position.
002C8C  3  D0 02        	bne :+
002C8E  3  E6 63        	inc z80_b
002C90  3               :
002C90  3  60           	rts
002C91  3               num2dd:
002C91  3  85 65        	sta z80_d		; Save number
002C93  3               
002C93  3  A9 01        	lda #1
002C95  3  85 rr        	sta flag
002C97  3               
002C97  3  4C 5B 2C     	jmp numdg2
002C9A  3               num2td:
002C9A  3  85 65        	sta z80_d		; Save number
002C9C  3               
002C9C  3  A9 01        	lda #1
002C9E  3  85 rr        	sta flag
002CA0  3  4C 54 2C     	jmp numdg3
002CA3  3               
002CA3  3               ;flag:	.byte 0
002CA3  3               
002CA3  3               ;---------------------------------------------------------
002CA3  3               ; Reset score to "000000"
002CA3  3               ;---------------------------------------------------------
002CA3  3               
002CA3  3               inisc:
002CA3  3  A9 30        	lda #'0'
002CA5  3  A2 05        	ldx #5			; digits to initialise.
002CA7  3               inisc0:
002CA7  3  9D AD 2E     	sta score,x 		; write zero digit.
002CAA  3  CA           	dex			; next column.
002CAB  3  10 FA        	bpl inisc0		; repeat for all digits.
002CAD  3               
002CAD  3  60           	rts
002CAE  3               
002CAE  3               ;-----------------------------------------------------
002CAE  3               ; Multiply h by d and return in hl.
002CAE  3               ;
002CAE  3               ; Input:
002CAE  3               ;  H = first number
002CAE  3               ;  D = second number
002CAE  3               ;
002CAE  3               ; Output:
002CAE  3               ;  HL = result H x D
002CAE  3               ;-----------------------------------------------------
002CAE  3               
002CAE  3               imul:
002CAE  3  A5 65        	lda z80_d		; HL = H * D
002CB0  3  85 64        	sta z80_e
002CB2  3  A5 67        	lda z80_h
002CB4  3  85 62        	sta z80_c		; make c first multiplier.
002CB6  3               imul0:
002CB6  3  A9 00        	lda #0			; zeroise total.
002CB8  3  85 66        	sta z80_l
002CBA  3  85 67        	sta z80_h
002CBC  3               
002CBC  3  A5 67        	lda z80_h
002CBE  3  85 65        	sta z80_d		; zeroise high byte.
002CC0  3               
002CC0  3  A9 08        	lda #8			; repeat 8 times.
002CC2  3  85 63        	sta z80_b
002CC4  3               imul1:
002CC4  3  46 62        	lsr z80_c		; rotate rightmost bit into carry.
002CC6  3  90 0E        	bcc imul2		; wasn't set.
002CC8  3  18           	clc			; bit was set, so add de.
002CC9  3  A5 66        	lda z80_l
002CCB  3  65 64        	adc z80_e
002CCD  3  85 66        	sta z80_l
002CCF  3  A5 67        	lda z80_h
002CD1  3  65 65        	adc z80_d
002CD3  3  85 67        	sta z80_h
002CD5  3  18           	clc 			; reset carry.
002CD6  3               imul2:
002CD6  3  06 64        	asl z80_e 		; shift de 1 bit left.
002CD8  3  26 65        	rol z80_d
002CDA  3  C6 63        	dec z80_b
002CDC  3  D0 E6        	bne imul1		; repeat 8 times.
002CDE  3               
002CDE  3  60           	rts
002CDF  3               
002CDF  3               ;-----------------------------------------------
002CDF  3               ; Divide d by e and return in d, remainder in a.
002CDF  3               ;
002CDF  3               ; Input:
002CDF  3               ;  D = first number
002CDF  3               ;  E = second number
002CDF  3               ;
002CDF  3               ; Output:
002CDF  3               ;  D = result D/E
002CDF  3               ;  A = remainder
002CDF  3               ;-----------------------------------------------
002CDF  3               
002CDF  3               idiv:
002CDF  3  A9 00        	lda #0
002CE1  3  A0 08        	ldy #8		 	; bits to shift.
002CE3  3  06 65        	asl z80_d
002CE5  3               idiv0:
002CE5  3  2A           	rol a 			; multiply d by 2.
002CE6  3  C5 64        	cmp z80_e 		; test if e is smaller.
002CE8  3  90 02        	bcc idiv1		; e is greater, no division this time.
002CEA  3  E5 64        	sbc z80_e		; subtract it.
002CEC  3               idiv1:
002CEC  3  26 65        	rol z80_d		; rotate into d.
002CEE  3  88           	dey
002CEF  3  D0 F4        	bne idiv0		; repeat
002CF1  3  60           	rts
002CF2  3               
002CF2  3               ;---------------------------------------------------
002CF2  3               ; Play AY sound effect
002CF2  3               ;---------------------------------------------------
002CF2  3               
002CF2  3               plsnd:
002CF2  3  60           	rts
002CF3  3               
002CF3  3               ;---------------------------------------------------
002CF3  3               ; Objects handling.
002CF3  3               ; 32 bytes for image
002CF3  3               ; 3 for room, y and x
002CF3  3               ; 3 for starting room, y and x.
002CF3  3               ; 254 = disabled.
002CF3  3               ; 255 = object in player"s pockets.
002CF3  3               ;---------------------------------------------------
002CF3  3               
002CF3  3               ;---------------------------------------------------
002CF3  3               ; Show items present.
002CF3  3               ;---------------------------------------------------
002CF3  3               
002CF3  3               .if oflag
002CF3  3               shwob:
002CF3  3  A9 0C        	lda #<objdta 			; objects table.
002CF5  3  85 66        	sta z80_l
002CF7  3  A9 41        	lda #>objdta
002CF9  3  85 67        	sta z80_h
002CFB  3               
002CFB  3  AD 23 28     	lda numob 			; number of objects in the game.
002CFE  3  85 rr        	sta sprcnt
002D00  3               shwob0:
002D00  3  A0 0C        	ldy #12 			; distance to room number.
002D02  3  B1 66        	lda (z80_hl),y 			; same as an item?
002D04  3  C5 rr        	cmp scno 			; current location.
002D06  3  D0 03        	bne :+
002D08  3  20 1D 2D     	jsr dobj 			; yes, display object.
002D0B  3               :
002D0B  3  18           	clc
002D0C  3  A5 66        	lda z80_l
002D0E  3  69 12        	adc #18 			; distance to next item.
002D10  3  85 66        	sta z80_l
002D12  3  A5 67        	lda z80_h
002D14  3  69 00        	adc #0
002D16  3  85 67        	sta z80_h	 		; point to it.
002D18  3  C6 rr        	dec sprcnt
002D1A  3  D0 E4        	bne shwob0 			; repeat for others.
002D1C  3  60           	rts
002D1D  3               
002D1D  3               ;---------------------------------------------------
002D1D  3               ; Display object.
002D1D  3               ; hl must point to object's start address.
002D1D  3               ;
002D1D  3               ; Input:
002D1D  3               ;  HL = object address
002D1D  3               ;---------------------------------------------------
002D1D  3               
002D1D  3               dobj:
002D1D  3  A0 0D        	ldy #13
002D1F  3  B1 66        	lda (z80_hl),y 			; point to y.
002D21  3  85 rr        	sta dispy
002D23  3  C8           	iny
002D24  3  B1 66        	lda (z80_hl),y 			; point to x.
002D26  3  85 rr        	sta dispx
002D28  3               dobj1:
002D28  3  4C AC 30     	jmp sprite 			; draw this sprite.
002D2B  3               
002D2B  3               ;--------------------------------------
002D2B  3               ; Remove an object.
002D2B  3               ;
002D2B  3               ; Input:
002D2B  3               ;  A = object number
002D2B  3               ;--------------------------------------
002D2B  3               
002D2B  3               remob:
002D2B  3  CD 23 28     	cmp numob			; number of objects in game.
002D2E  3  90 01        	bcc :+				; are we checking past the end?
002D30  3  60           	rts				; yes, can't get non-existent item.
002D31  3               :
002D31  3  48           	pha				; remember object.
002D32  3  20 40 2D     	jsr getob			; pick it up if we haven't already got it.
002D35  3  68           	pla				; retrieve object number.
002D36  3  20 6F 2D     	jsr gotob			; get its address.
002D39  3  A9 FE        	lda #254
002D3B  3  A0 0C        	ldy #12
002D3D  3  91 66        	sta (z80_hl),y			; remove it.
002D3F  3  60           	rts
002D40  3               
002D40  3               ;---------------------------------------------------
002D40  3               ; Pick up object number held in the accumulator.
002D40  3               ;
002D40  3               ; Input:
002D40  3               ;  A = object number
002D40  3               ;---------------------------------------------------
002D40  3               
002D40  3               getob:
002D40  3  CD 23 28     	cmp numob 		; number of objects in game.
002D43  3  90 01        	bcc :+			; are we checking past the end?
002D45  3  60           	rts			; yes, can't get non-existent item.
002D46  3               :
002D46  3  20 6F 2D     	jsr gotob 		; check if we already have it.
002D49  3  C9 FF        	cmp #255
002D4B  3  D0 01        	bne :+
002D4D  3  60           	rts			; we already do.
002D4E  3               :
002D4E  3  A0 0C        	ldy #12
002D50  3  B1 66        	lda (z80_hl),y		; is it on this screen?
002D52  3  C5 rr        	cmp scno 		; current screen.
002D54  3  D0 14        	bne getob0		; not on screen, so nothing to delete.
002D56  3               
002D56  3  A9 FF        	lda #255
002D58  3  91 66        	sta (z80_hl),y		; pick it up.
002D5A  3  C8           	iny 			; point to y coord.
002D5B  3               getob1:
002D5B  3  A0 0D        	ldy #13
002D5D  3  B1 66        	lda (z80_hl),y		; y coord.
002D5F  3  85 rr        	sta dispy
002D61  3  A0 0E        	ldy #14
002D63  3  B1 66        	lda (z80_hl),y 		; x coord.
002D65  3  85 rr        	sta dispx
002D67  3  4C 28 2D     	jmp dobj1 		; delete object sprite.
002D6A  3               getob0:
002D6A  3  A9 FF        	lda #255
002D6C  3  91 66        	sta (z80_hl),y 		; pick it up.
002D6E  3  60           	rts
002D6F  3               .endif
002D6F  3               
002D6F  3               ;-----------------------------------------------------------------
002D6F  3               ; Got object check.
002D6F  3               ; Call with object in accumulator, returns zero set if in pockets.
002D6F  3               ;
002D6F  3               ; Input:
002D6F  3               ;  A = object number
002D6F  3               ;-----------------------------------------------------------------
002D6F  3               .if oflag .or mflag
002D6F  3               gotob:
002D6F  3  CD 23 28     	cmp numob 		; number of objects in game.
002D72  3  90 03        	bcc :+ 			; are we checking past the end?
002D74  3  4C 7B 2D     	jmp gotob0 		; yes, we can't have a non-existent object.
002D77  3               :
002D77  3  20 80 2D     	jsr findob		; find the object.
002D7A  3               gotob1:
002D7A  3  60           	rts
002D7B  3               
002D7B  3               gotob0:
002D7B  3  A9 FE        	lda #254 		; missing.
002D7D  3  4C 7A 2D     	jmp gotob1
002D80  3               
002D80  3               findob:
002D80  3  48           	pha			; save object number
002D81  3  A9 0C        	lda #<objdta 		; objects.
002D83  3  85 66        	sta z80_l
002D85  3  A9 41        	lda #>objdta
002D87  3  85 67        	sta z80_h
002D89  3  68           	pla			; retreive object number
002D8A  3  F0 0F        	beq fndob1 		; is it zero? yes, skip loop.
002D8C  3  AA           	tax 			; loop counter
002D8D  3               fndob2:
002D8D  3  18           	clc
002D8E  3  A5 66        	lda z80_l
002D90  3  69 12        	adc #18 		; size of each object.
002D92  3  85 66        	sta z80_l
002D94  3  90 02        	bcc :+
002D96  3  E6 67        	inc z80_h
002D98  3               :
002D98  3  CA           	dex 			; repeat until we find address.
002D99  3  D0 F2        	bne fndob2
002D9B  3               fndob1:
002D9B  3  A0 0C        	ldy #12			; distance to room it's in.
002D9D  3  B1 66        	lda (z80_hl),y		; fetch status.
002D9F  3  60           	rts
002DA0  3               .endif
002DA0  3               
002DA0  3               ;---------------------------------------------
002DA0  3               ; Drop object number at (dispx, dispy).
002DA0  3               ;
002DA0  3               ; Input:
002DA0  3               ;  A = object number
002DA0  3               ;---------------------------------------------
002DA0  3               
002DA0  3               .if oflag
002DA0  3               drpob:
002DA0  3  CD 23 28     	cmp numob 		; are we checking past the end?
002DA3  3  90 01        	bcc :+
002DA5  3  60           	rts			; yes, can't drop non-existent item.
002DA6  3               :
002DA6  3  20 6F 2D     	jsr gotob		; make sure object is in inventory.
002DA9  3  C5 rr        	cmp scno		; already on this screen?
002DAB  3  D0 01        	bne :+
002DAD  3  60           	rts			; yes, nothing to do.
002DAE  3               :
002DAE  3  A0 0C        	ldy #12
002DB0  3  A5 rr        	lda scno
002DB2  3  91 66        	sta (z80_hl),y		; bring onto screen.
002DB4  3  A5 rr        	lda dispy		; sprite y coordinate.
002DB6  3  C8           	iny
002DB7  3  91 66        	sta (z80_hl),y		; point to object y.
002DB9  3  A5 rr        	lda dispx 		; sprite x coordinate.
002DBB  3  C8           	iny
002DBC  3  91 66        	sta (z80_hl),y 		; point to object x
002DBE  3  4C 1D 2D     	jmp dobj		; draw the object sprite.
002DC1  3               
002DC1  3               ;-----------------------------------------------
002DC1  3               ; Seek objects at sprite position.
002DC1  3               ;
002DC1  3               ; Output:
002DC1  3               ;  A = object number, if not found A=255
002DC1  3               ;-----------------------------------------------
002DC1  3               
002DC1  3               skobj:
002DC1  3  A9 0C        	lda #<objdta 		; pointer to objects.
002DC3  3  85 66        	sta z80_l
002DC5  3  A9 41        	lda #>objdta
002DC7  3  85 67        	sta z80_h
002DC9  3               
002DC9  3  AD 23 28     	lda numob 		; number of objects in game.
002DCC  3  85 63        	sta z80_b 		; set up the loop counter.
002DCE  3               skobj0:
002DCE  3  A5 rr        	lda scno		; current room number.
002DD0  3  A0 0C        	ldy #12
002DD2  3  D1 66        	cmp (z80_hl),y		; is object in here?
002DD4  3  D0 03        	bne :+
002DD6  3  20 EB 2D     	jsr skobj1		; yes, check coordinates.
002DD9  3               :
002DD9  3  18           	clc			; point to next object in table.
002DDA  3  A5 66        	lda z80_l
002DDC  3  69 12        	adc #18			; size of each object.
002DDE  3  85 66        	sta z80_l
002DE0  3  90 02        	bcc :+
002DE2  3  E6 67        	inc z80_h
002DE4  3               :
002DE4  3  C6 63        	dec z80_b
002DE6  3  D0 E6        	bne skobj0		; repeat for all objects.
002DE8  3               
002DE8  3  A9 FF        	lda #255		; end of list and nothing found, return 255.
002DEA  3  60           	rts
002DEB  3               
002DEB  3               skobj1:
002DEB  3  A0 0D        	ldy #13			; point to y coordinate.
002DED  3  B1 66        	lda (z80_hl),y		; point to y coordinate.
002DEF  3  38           	sec
002DF0  3  A0 08        	ldy #8
002DF2  3  F1 68        	sbc (z80_ix),y 		; subtract sprite y.
002DF4  3  18           	clc
002DF5  3  69 08        	adc #8			; add sprite height minus one.
002DF7  3  C9 11        	cmp #17			; within range?
002DF9  3  B0 18        	bcs skobj2		; no, ignore object.
002DFB  3               
002DFB  3  A0 0E        	ldy #14			; point to x coordinate now.
002DFD  3  B1 66        	lda (z80_hl),y 		; get coordinate.
002DFF  3  38           	sec
002E00  3  A0 09        	ldy #9
002E02  3  F1 68        	sbc (z80_ix),y 		; subtract the sprite x.
002E04  3  18           	clc			; add sprite width minus one.
002E05  3  69 07        	adc #7
002E07  3  C9 0F        	cmp #15			; within range?
002E09  3  B0 08        	bcs skobj2		; no, ignore object.
002E0B  3               
002E0B  3  68           	pla			; remove return address from stack.
002E0C  3  68           	pla
002E0D  3               
002E0D  3  AD 23 28     	lda numob 		; objects in game.
002E10  3  38           	sec
002E11  3  E5 63        	sbc z80_b		; subtract loop counter.
002E13  3               skobj2:
002E13  3  60           	rts			; accumulator now points to object.
002E14  3               .endif
002E14  3               
002E14  3               ;---------------------------------------------------------------------
002E14  3               ; Spawn a new sprite.
002E14  3               ;---------------------------------------------------------------------
002E14  3               
002E14  3               .if gflag
002E14  3                 offset = 0
002E14  3               .else
002E14  3                 offset = 20
002E14  3               .endif
002E14  3               
002E14  3               spawn:
002E14  3  A9 2F        	lda #<sprtab		; sprite table.
002E16  3  85 66        	sta z80_l
002E18  3  A9 3B        	lda #>sprtab
002E1A  3  85 67        	sta z80_h
002E1C  3               numsp1:
002E1C  3  A9 0C        	lda #NUMSPR		; number of sprites.
002E1E  3  85 rr        	sta spcnt
002E20  3               spaw0:
002E20  3  A0 00        	ldy #0
002E22  3  B1 66        	lda (z80_hl),y		; get sprite type.
002E24  3  C9 FF        	cmp #255		; is it an unused slot?
002E26  3  F0 0F        	beq spaw1 		; yes, we can use this one.
002E28  3               
002E28  3  18           	clc 			; point to next sprite in table.
002E29  3  A5 66        	lda z80_l
002E2B  3  69 11        	adc #TABSIZ		; size of each entry.
002E2D  3  85 66        	sta z80_l
002E2F  3  90 02        	bcc :+
002E31  3  E6 67        	inc z80_h
002E33  3               :
002E33  3  C6 rr        	dec spcnt		; one less iteration.
002E35  3  D0 E9        	bne spaw0		; keep going until we find a slot.
002E37  3               
002E37  3               ; Didn't find one but drop through and set up a dummy sprite instead.
002E37  3               
002E37  3               spaw1:
002E37  3  A5 69        	lda z80_i		; address of original sprite.
002E39  3  48           	pha
002E3A  3  A5 68        	lda z80_x
002E3C  3  48           	pha
002E3D  3               
002E3D  3  A5 66        	lda z80_l		; store spawned sprite address.
002E3F  3  85 rr        	sta spptr
002E41  3  A5 67        	lda z80_h
002E43  3  85 rr        	sta spptr+1
002E45  3               
002E45  3  A5 62        	lda z80_c
002E47  3  A0 00        	ldy #0
002E49  3  91 66        	sta (z80_hl),y 		; set the type.
002E4B  3  A0 05        	ldy #5
002E4D  3  91 66        	sta (z80_hl),y		; copy
002E4F  3               
002E4F  3  A5 63        	lda z80_b
002E51  3  A0 01        	ldy #1
002E53  3  91 66        	sta (z80_hl),y		; set the image.
002E55  3  A0 06        	ldy #6
002E57  3  91 66        	sta (z80_hl),y		; copy
002E59  3               
002E59  3  A9 00        	lda #0 			; frame zero.
002E5B  3  A0 02        	ldy #2
002E5D  3  91 66        	sta (z80_hl),y		; set frame.
002E5F  3  A0 07        	ldy #7
002E61  3  91 66        	sta (z80_hl),y		; copy
002E63  3               
002E63  3  A0 08        	ldy #8
002E65  3  B1 68        	lda (z80_ix),y 		; x coordinate.
002E67  3  A0 03        	ldy #3
002E69  3  91 66        	sta (z80_hl),y		; set sprite coordinate.
002E6B  3  A0 08        	ldy #8
002E6D  3  91 66        	sta (z80_hl),y		; copy
002E6F  3               
002E6F  3  A0 09        	ldy #9
002E71  3  B1 68        	lda (z80_ix),y 		; y coordinate.
002E73  3  A0 04        	ldy #4
002E75  3  91 66        	sta (z80_hl),y		; set sprite coordinate.
002E77  3  A0 09        	ldy #9
002E79  3  91 66        	sta (z80_hl),y		; copy
002E7B  3               
002E7B  3  A0 0A        	ldy #10			; direction of original.
002E7D  3  B1 68        	lda (z80_ix),y
002E7F  3  91 66        	sta (z80_hl),y		; direction
002E81  3               
002E81  3  A9 00        	lda #0
002E83  3  A0 0B        	ldy #11
002E85  3  91 66        	sta (z80_hl),y		; reset parameter.
002E87  3  C8           	iny
002E88  3  91 66        	sta (z80_hl),y		; reset parameter.
002E8A  3  C8           	iny
002E8B  3  91 66        	sta (z80_hl),y		; reset parameter.
002E8D  3  C8           	iny
002E8E  3  91 66        	sta (z80_hl),y		; reset parameter.
002E90  3               rtssp:
002E90  3  A5 rr        	lda spptr		; address of new sprite.
002E92  3  85 68        	sta z80_x
002E94  3  A5 rr        	lda spptr+1
002E96  3  85 69        	sta z80_i
002E98  3               evis1:
002E98  3  20 BD 3D     	jsr evnt09 		; call sprite initialisation event.
002E9B  3               
002E9B  3  A5 rr        	lda spptr 		; address of new sprite.
002E9D  3  85 68        	sta z80_x
002E9F  3  A5 rr        	lda spptr+1
002EA1  3  85 69        	sta z80_i
002EA3  3  20 05 46     	jsr sspria 		; display the new sprite.
002EA6  3               
002EA6  3  68           	pla			; address of original sprite.
002EA7  3  85 68        	sta z80_x
002EA9  3  68           	pla
002EAA  3  85 69        	sta z80_i
002EAC  3               
002EAC  3  60           	rts
002EAD  3               
002EAD  3               ;spcnt:	.byte 0
002EAD  3               ;spptr:	.word 0			; spawned sprite pointer.
002EAD  3               ;seed:	.byte 0			; seed for random numbers.
002EAD  3  30 30 30 30  score:	.byte "000000"		; player"s score.
002EB1  3  30 30        
002EB3  3  30 30 30 30  hiscor:	.byte "000000"		; high score.
002EB7  3  30 30        
002EB9  3  30 30 30 30  bonus:	.byte "000000"		; bonus.
002EBD  3  30 30        
002EBF  3  00 04        grbase:	.word ScreenAddr	; graphics base address.
002EC1  3               
002EC1  3               ;----------------------------------------------------
002EC1  3               ; Check y-pos
002EC1  3               ;----------------------------------------------------
002EC1  3               
002EC1  3               checkx:
002EC1  3  A5 rr        	lda dispy		; y position.
002EC3  3  C9 19        	cmp #ScrHeight			; off screen?
002EC5  3  B0 01        	bcs :+
002EC7  3  60           	rts			; no, it's okay.
002EC8  3               :
002EC8  3  68           	pla			; remove return address from stack.
002EC9  3  85 66        	sta z80_l
002ECB  3  68           	pla
002ECC  3  85 67        	sta z80_h
002ECE  3  60           	rts
002ECF  3               
002ECF  3               ;-----------------------------------------------
002ECF  3               ; Displays the current high score.
002ECF  3               ;-----------------------------------------------
002ECF  3               
002ECF  3               dhisc:
002ECF  3  A9 B3        	lda #<hiscor 		; high score text.
002ED1  3  8D 06 2F     	sta dscor3+1
002ED4  3  8D 32 2F     	sta bscor3+1
002ED7  3  A9 2E        	lda #>hiscor
002ED9  3  8D 07 2F     	sta dscor3+2
002EDC  3  8D 33 2F     	sta bscor3+2
002EDF  3  4C F2 2E     	jmp dscor1		; check in printable range then show 6 digits.
002EE2  3               
002EE2  3               ;------------------------------------------------------
002EE2  3               ; Displays the current score.
002EE2  3               ;------------------------------------------------------
002EE2  3               
002EE2  3               dscor:
002EE2  3  A9 AD        	lda #<score		; score text.
002EE4  3  8D 06 2F     	sta dscor3+1
002EE7  3  8D 32 2F     	sta bscor3+1
002EEA  3  A9 2E        	lda #>score
002EEC  3  8D 07 2F     	sta dscor3+2
002EEF  3  8D 33 2F     	sta bscor3+2
002EF2  3               dscor1:
002EF2  3  8C 2E 2F     	sty tmpscr
002EF5  3  20 76 34     	jsr preprt		; set up font and print position.
002EF8  3  20 C1 2E     	jsr checkx		; make sure we're in a printable range.
002EFB  3               
002EFB  3               ;	lda #6			; digits to display.
002EFB  3               ;	sta z80_b
002EFB  3  A5 rr        	lda prtmod		; get print mode.
002EFD  3  F0 03        	beq :+			; standard size text?
002EFF  3  4C 2F 2F     	jmp bscor0		; no, show double-height.
002F02  3               :
002F02  3               dscor0:
002F02  3               ;	ldy #0
002F02  3               ;	lda (z80_hl),y 		; fetch character.
002F02  3  AC 2E 2F     	ldy tmpscr
002F05  3               dscor3:
002F05  3  B9 AD 2E     	lda score,y
002F08  3  20 47 30     	jsr pchar 		; display character.
002F0B  3  E6 rr        	inc dispx		; move along x coordinate
002F0D  3               
002F0D  3               ;	inc z80_l		; next score column.
002F0D  3               ;	bne :+
002F0D  3               ;	inc z80_h
002F0D  3               ;:
002F0D  3  EE 2E 2F     	inc tmpscr
002F10  3  C6 63        	dec z80_b
002F12  3  D0 EE        	bne dscor0 		; repeat for all digits.
002F14  3               dscor2:
002F14  3  A9 0C        	lda #12
002F16  3  20 47 30     	jsr pchar
002F19  3  20 4C 34     	jsr nexpos
002F1C  3               
002F1C  3  AD 1E 3C     	lda bcolour
002F1F  3  20 47 30     	jsr pchar
002F22  3  20 4C 34     	jsr nexpos
002F25  3               
002F25  3  A5 rr        	lda dispx 		; set up display coordinates.
002F27  3  85 rr        	sta charx
002F29  3  A5 rr        	lda dispy
002F2B  3  85 rr        	sta chary
002F2D  3  60           	rts
002F2E  3               
002F2E  3  00           tmpscr:	.byte 0
002F2F  3               ;------------------------------------------------------
002F2F  3               ; Displays the current score in double-height characters.
002F2F  3               ;
002F2F  3               ; Input:
002F2F  3               ;  B  = digit number
002F2F  3               ;  HL = score string
002F2F  3               ;------------------------------------------------------
002F2F  3               
002F2F  3               bscor0:
002F2F  3               ;	ldy #0
002F2F  3               
002F2F  3               ;	lda (z80_hl),y 		; fetch character.
002F2F  3  A4 rr        	ldy tmp
002F31  3               bscor3:
002F31  3  B9 AD 2E     	lda score,y
002F34  3  20 1D 34     	jsr bchar 		; display big char.
002F37  3               
002F37  3               ;	inc z80_l 		; next score column.
002F37  3               ;	bne :+
002F37  3               ;	inc z80_h
002F37  3               ;:
002F37  3  E6 rr        	inc tmp
002F39  3  C6 63        	dec z80_b
002F3B  3  F0 03        	beq :+
002F3D  3  4C 2F 2F     	jmp bscor0 		; repeat for all digits.
002F40  3               :
002F40  3  4C 14 2F     	jmp dscor2 		; tidy up line and column variables.
002F43  3               
002F43  3               ;-----------------------------------------------------
002F43  3               ; Adds number in the hl pair to the score.
002F43  3               ;-----------------------------------------------------
002F43  3               
002F43  3               addsc:
002F43  3  A9 AE        	lda #<(score+1) 	; ten thousands column.
002F45  3  85 64        	sta z80_e
002F47  3  A9 2E        	lda #>(score+1)
002F49  3  85 65        	sta z80_d
002F4B  3  A9 10        	lda #<10000		; amount to add each time.
002F4D  3  85 62        	sta z80_c
002F4F  3  A9 27        	lda #>10000
002F51  3  85 63        	sta z80_b
002F53  3  20 97 2F     	jsr incsc		; add to score.
002F56  3               
002F56  3  E6 64        	inc z80_e		; thousands column.
002F58  3  D0 02        	bne :+
002F5A  3  E6 65        	inc z80_d
002F5C  3               :
002F5C  3  A9 E8        	lda #<1000		; amount to add each time.
002F5E  3  85 62        	sta z80_c
002F60  3  A9 03        	lda #>1000
002F62  3  85 63        	sta z80_b
002F64  3  20 97 2F     	jsr incsc 		; add to score.
002F67  3               
002F67  3  E6 64        	inc z80_e		; hundreds column.
002F69  3  D0 02        	bne :+
002F6B  3  E6 65        	inc z80_d
002F6D  3               :
002F6D  3  A9 64        	lda #<100		; amount to add each time.
002F6F  3  85 62        	sta z80_c
002F71  3  A9 00        	lda #>100
002F73  3  85 63        	sta z80_b
002F75  3  20 97 2F     	jsr incsc		; add to score.
002F78  3               
002F78  3  E6 64        	inc z80_e 		; tens column.
002F7A  3  D0 02        	bne :+
002F7C  3  E6 65        	inc z80_d
002F7E  3               :
002F7E  3  A9 0A        	lda #<10		; amount to add each time.
002F80  3  85 62        	sta z80_c
002F82  3  A9 00        	lda #>10
002F84  3  85 63        	sta z80_b
002F86  3  20 97 2F     	jsr incsc 		; add to score.
002F89  3               
002F89  3  E6 64        	inc z80_e		; units column.
002F8B  3  D0 02        	bne :+
002F8D  3  E6 65        	inc z80_d
002F8F  3               :
002F8F  3  A9 01        	lda #<1			; units.
002F91  3  85 62        	sta z80_c
002F93  3  A9 00        	lda #>1
002F95  3  85 63        	sta z80_b
002F97  3               incsc:
002F97  3  A5 67        	lda z80_h		; store amount to add.
002F99  3  48           	pha
002F9A  3  A5 66        	lda z80_l
002F9C  3  48           	pha
002F9D  3               
002F9D  3  38           	sec			; subtract from amount to add.
002F9E  3  A5 66        	lda z80_l
002FA0  3  E5 62        	sbc z80_c
002FA2  3  85 66        	sta z80_l
002FA4  3  A5 67        	lda z80_h
002FA6  3  E5 63        	sbc z80_b
002FA8  3  85 67        	sta z80_h
002FAA  3  90 14        	bcc incsc0		; too much, restore value.
002FAC  3               
002FAC  3  68           	pla			; delete the previous amount from the stack.
002FAD  3  68           	pla
002FAE  3               
002FAE  3  A5 65        	lda z80_d 		; store column position.
002FB0  3  48           	pha
002FB1  3  A5 64        	lda z80_e
002FB3  3  48           	pha
002FB4  3  20 C7 2F     	jsr incsc2		; do the increment.
002FB7  3               
002FB7  3  68           	pla			; restore column.
002FB8  3  85 64        	sta z80_e
002FBA  3  68           	pla
002FBB  3  85 65        	sta z80_d
002FBD  3  4C 97 2F     	jmp incsc		; repeat until all added.
002FC0  3               
002FC0  3               incsc0:
002FC0  3  68           	pla			; restore previous value.
002FC1  3  85 66        	sta z80_l
002FC3  3  68           	pla
002FC4  3  85 67        	sta z80_h
002FC6  3  60           	rts
002FC7  3               incsc2:
002FC7  3  A0 00        	ldy #0
002FC9  3  B1 64        	lda (z80_de),y 		; get amount.
002FCB  3  18           	clc
002FCC  3  69 01        	adc #1			; add one to column.
002FCE  3  91 64        	sta (z80_de),y		; write new column total.
002FD0  3  C9 3A        	cmp #'9'+1		; gone beyond range of digits?
002FD2  3  B0 01        	bcs :+
002FD4  3  60           	rts			; no, carry on.
002FD5  3               :
002FD5  3  A9 30        	lda #'0'		; make it zero.
002FD7  3  91 64        	sta (z80_de),y		; write new column total.
002FD9  3  C6 64        	dec z80_e		; back one column.
002FDB  3  D0 02        	bne :+
002FDD  3  C6 65        	dec z80_d
002FDF  3               :
002FDF  3  4C C7 2F     	jmp incsc2
002FE2  3               
002FE2  3               ;------------------------------------
002FE2  3               ; Add bonus to score and reset bonus
002FE2  3               ;------------------------------------
002FE2  3               
002FE2  3               addbo:
002FE2  3  A2 05        	ldx #5			; last digit.
002FE4  3  18           	clc
002FE5  3               addbo0:
002FE5  3  BD AD 2E     	lda score,x		; get score.
002FE8  3  7D B9 2E     	adc bonus,x		; add bonus.
002FEB  3  38           	sec			; 0 to 18.
002FEC  3  E9 30        	sbc #48
002FEE  3  48           	pha
002FEF  3  A9 30        	lda #'0'
002FF1  3  9D B9 2E     	sta bonus,x
002FF4  3  68           	pla
002FF5  3  C9 3A        	cmp #58
002FF7  3  90 03        	bcc addbo1
002FF9  3  38           	sec
002FFA  3  E9 0A        	sbc #10
002FFC  3               addbo1:
002FFC  3  9D AD 2E     	sta score,x		; zeroise bonus.
002FFF  3  CA           	dex			; next digit.
003000  3  10 E3        	bpl addbo0		; repeat for all 6 digits.
003002  3  60           	rts
003003  3               
003003  3               ;------------------------------------
003003  3               ; Swap score and bonus.
003003  3               ;------------------------------------
003003  3               
003003  3               swpsb:
003003  3  A2 05        	ldx #5			; digits to add.
003005  3               swpsb0:
003005  3  BD AD 2E     	lda score,x 		; get score digits.
003008  3  48           	pha			; save digit
003009  3  BD B9 2E     	lda bonus,x 		; get bonus digits.
00300C  3  9D AD 2E     	sta score,x		; switch score-bonus
00300F  3  68           	pla
003010  3  9D B9 2E     	sta bonus,x
003013  3  CA           	dex 			; repeat for all 6 digits.
003014  3  10 EF        	bpl swpsb0
003016  3  60           	rts
003017  3               
003017  3               ;----------------------------------------------------
003017  3               ; Get print address.
003017  3               ;----------------------------------------------------
003017  3               
003017  3               gprad:
003017  3  A5 rr        	lda dispy
003019  3  85 rr        	sta tmp
00301B  3  0A           	asl a
00301C  3  18           	clc
00301D  3  65 rr        	adc tmp
00301F  3  A8           	tay
003020  3  B9 00 DC     	lda SCADTB_lb,y
003023  3  18           	clc
003024  3  65 rr        	adc dispx
003026  3  85 rr        	sta scraddr
003028  3  B9 00 DD     	lda SCADTB_hb,y
00302B  3  69 00        	adc #0
00302D  3  85 rr        	sta scraddr+1
00302F  3  60           	rts
003030  3               
003030  3               ;--------------------------------------------------------------
003030  3               ; Get property buffer address of char at (dispx, dispy) in hl.
003030  3               ;
003030  3               ; Output:
003030  3               ;  bufaddr = MAP + dispy*40 + dispx
003030  3               ;--------------------------------------------------------------
003030  3               
003030  3               pradd:
003030  3  A5 rr        	lda dispy 		; y coordinate.
003032  3  0A           	asl a
003033  3  18           	clc
003034  3  65 rr        	adc dispy
003036  3  AA           	tax
003037  3               
003037  3  18           	clc
003038  3  BD 00 DC     	lda SCADTB_lb,x
00303B  3  65 rr        	adc dispx
00303D  3  85 rr        	sta bufaddr
00303F  3               
00303F  3  BD 00 DD     	lda SCADTB_hb,x
003042  3  69 D4        	adc #(>MAP->ScreenAddr)
003044  3  85 rr        	sta bufaddr+1
003046  3  60           	rts
003047  3               
003047  3               ;----------------------------------------------------
003047  3               ; Display character in A at dispx,dispy.
003047  3               ;
003047  3               ; Input:
003047  3               ;  A 	   = character to print
003047  3               ;----------------------------------------------------
003047  3               
003047  3               pchar:
003047  3  48           	pha
003048  3  20 17 30     	jsr gprad		; get screen address.
00304B  3               .if gflag
00304B  3               	and andeor
00304B  3               	eor andeor+1
00304B  3               .endif
00304B  3               .if iflag
00304B  3               	eor #$ff
00304B  3               .endif
00304B  3  68           	pla
00304C  3  A0 00        	ldy #0
00304E  3  91 rr        	sta (scraddr),y 	; copy to screen.
003050  3  60           	rts
003051  3               
003051  3  E0 C0 A0 80  scrtab:		.byte $e0,$c0,$a0,$80,$60,$40,$20,$00
003055  3  60 40 20 00  
003059  3               
003059  3               ;----------------------------------------------
003059  3               
003059  3               ; Print attributes, properties and pixels.
003059  3               ;
003059  3               ; Input:
003059  3               ;  A	= tile number
003059  3               ;----------------------------------------------
003059  3               
003059  3               pbpattr:			; entry PUTBLOCK command
003059  3  A4 rr        	ldy charx
00305B  3  84 rr        	sty dispx
00305D  3  A4 rr        	ldy chary
00305F  3  84 rr        	sty dispy
003061  3               pattr:
003061  3               .if aflag
003061  3               	pha
003061  3               	jsr wbloc		; save blockinfo
003061  3               	pla
003061  3               .endif
003061  3               
003061  3               pattr2:
003061  3  85 63        	sta z80_b		; store cell in b register for now.
003063  3  AA           	tax
003064  3  BD B1 3E     	lda bprop,x 		; block properties.
003067  3  85 62        	sta z80_c
003069  3  C9 08        	cmp #COLECT
00306B  3  D0 05        	bne :+
00306D  3  A5 63        	lda z80_b
00306F  3  8D 80 30     	sta colpatt
003072  3               :
003072  3  20 30 30     	jsr pradd 		; get property buffer address.
003075  3  A5 62        	lda z80_c
003077  3  A0 00        	ldy #0
003079  3  91 rr        	sta (bufaddr),y 	; write property.
00307B  3  A5 63        	lda z80_b 		; restore cell.
00307D  3  4C 81 30     	jmp panp
003080  3               ; Print attributes, no properties.
003080  3               
003080  3  00           colpatt:	.byte 0
003081  3               
003081  3               panp:
003081  3  85 64        	sta z80_e		; displacement in e.
003083  3  A9 00        	lda #0
003085  3  85 65        	sta z80_d		; no high byte.
003087  3  06 64        	asl z80_e  		; multiply char by 8.
003089  3  26 65        	rol z80_d
00308B  3  18           	clc
00308C  3  A5 64        	lda z80_e
00308E  3  69 AD        	adc #<chgfx 		; address of graphics.
003090  3  85 rr        	sta tileaddr
003092  3  A5 65        	lda z80_d
003094  3  69 3E        	adc #>chgfx
003096  3  85 rr        	sta tileaddr+1
003098  3  20 17 30     	jsr gprad 		; get screen address.
00309B  3               panp0:
00309B  3  A0 00        	ldy #0
00309D  3  B1 rr        	lda (tileaddr),y 	; get image byte.
00309F  3               .if iflag
00309F  3               	eor #$ff		; Invert
00309F  3               .endif
00309F  3  91 rr        	sta (scraddr),y 	; copy to screen.
0030A1  3  E6 rr        	inc dispx 		; move along one.
0030A3  3  E6 rr        	inc charx
0030A5  3  60           	rts
0030A6  3               
0030A6  3               ;----------------------------------------------
0030A6  3               ; Write block
0030A6  3               ;----------------------------------------------
0030A6  3               
0030A6  3               .if aflag
0030A6  3               wbloc:
0030A6  3               	ldy #3
0030A6  3               	sta (pbptr),y		; store block number
0030A6  3               	dey
0030A6  3               	lda dispx
0030A6  3               	sta (pbptr),y		; write x position of block.
0030A6  3               	dey
0030A6  3               	lda dispy
0030A6  3               	sta (pbptr),y		; write y position of block.
0030A6  3               	dey
0030A6  3               	lda scno
0030A6  3               	sta (pbptr),y		; write screen.
0030A6  3               	clc			; point to next free location
0030A6  3               	lda pbptr
0030A6  3               	adc #4
0030A6  3               	sta pbptr
0030A6  3               	bcc :+
0030A6  3               	inc pbptr+1
0030A6  3               :
0030A6  3               	rts
0030A6  3               .endif
0030A6  3               
0030A6  3               ;----------------------------------------------
0030A6  3               ; Print character pixels, no more.
0030A6  3               ;
0030A6  3               ; Input:
0030A6  3               ;  A	= character to print
0030A6  3               ;----------------------------------------------
0030A6  3               
0030A6  3               pchr:
0030A6  3  20 47 30     	jsr pchar 		; show character in accumulator.
0030A9  3  E6 rr        	inc dispx		; move along one.
0030AB  3  60           	rts
0030AC  3               
0030AC  3               ;----------------------------------------------------
0030AC  3               ; Draw sprite
0030AC  3               ;----------------------------------------------------
0030AC  3               
0030AC  3               .if oflag
0030AC  3               
0030AC  3               sprite:
0030AC  3  20 C2 36     	jsr scadd 		; get screen address in scraddr.
0030AF  3               
0030AF  3  A5 66        	lda z80_l		; store sprite graphic address.
0030B1  3  8D BE 30     	sta sprit1+1
0030B4  3  A5 67        	lda z80_h
0030B6  3  8D BF 30     	sta sprit1+2
0030B9  3               
0030B9  3  A2 00        	ldx #0			; pixel height.
0030BB  3  A0 00        	ldy #0
0030BD  3               sprit1:
0030BD  3  BD 0C 41     	lda objdta,x		; fetch first byte.
0030C0  3  BC CF 30     	ldy spritetab,x
0030C3  3  51 rr        	eor (scraddr),y		; merge with screen image.
0030C5  3  09 20        	ora #$20
0030C7  3  91 rr        	sta (scraddr),y		; write to screen.
0030C9  3  E8           	inx			; next screen byte.
0030CA  3  E0 0C        	cpx #12
0030CC  3  D0 EF        	bne sprit1		; repeat
0030CE  3               
0030CE  3  60           	rts
0030CF  3               
0030CF  3               spritetab:
0030CF  3  00 01 02 03  	.byte $00,$01,$02,$03
0030D3  3  28 29 2A 2B  	.byte $28,$29,$2a,$2b
0030D7  3  50 51 52 53  	.byte $50,$51,$52,$53
0030DB  3               
0030DB  3  00 00        spr:	.byte 0,0
0030DD  3               
0030DD  3               .endif
0030DD  3               
0030DD  3               ;-----------------------------------------------------------
0030DD  3               ; Get room address.
0030DD  3               ;-----------------------------------------------------------
0030DD  3               
0030DD  3               groom:
0030DD  3  A6 rr        	ldx scno 		; screen number.
0030DF  3  A0 00        	ldy #0
0030E1  3               groomx:
0030E1  3  A9 97        	lda #<scdat 		; pointer to screens.
0030E3  3  85 66        	sta z80_l
0030E5  3  A9 40        	lda #>scdat
0030E7  3  85 67        	sta z80_h
0030E9  3               groom1:
0030E9  3  E0 00        	cpx #0			; is it the first one?
0030EB  3  F0 15        	beq groom0 		; no more screens to skip.
0030ED  3               
0030ED  3  18           	clc
0030EE  3  A5 66        	lda z80_l
0030F0  3  79 97 40     	adc scdat,y 		; low byte of screen size.
0030F3  3  85 66        	sta z80_l
0030F5  3  C8           	iny			; point to high byte.
0030F6  3  A5 67        	lda z80_h
0030F8  3  79 97 40     	adc scdat,y 		; high byte of screen size.
0030FB  3  85 67        	sta z80_h
0030FD  3  C8           	iny			; next address.
0030FE  3               
0030FE  3  CA           	dex 			; one less iteration.
0030FF  3  4C E9 30     	jmp groom1 		; loop until we reach the end.
003102  3               groom0:
003102  3  AD 06 41     	lda numsc 		; add displacement.
003105  3  0A           	asl a
003106  3  18           	clc			; add double displacement to address.
003107  3  65 66        	adc z80_l
003109  3  85 66        	sta z80_l
00310B  3  A5 67        	lda z80_h
00310D  3  69 00        	adc #0
00310F  3  85 67        	sta z80_h
003111  3  60           	rts
003112  3               
003112  3               ;-----------------------------------------------------------
003112  3               ; Draw present room.
003112  3               ;-----------------------------------------------------------
003112  3               
003112  3               droom:
003112  3  AD 1F 28     	lda wintop 		; window top.
003115  3  85 rr        	sta dispy		; set cursor y position.
003117  3               droom2:
003117  3  20 DD 30     	jsr groom 		; get address of current room.
00311A  3  A9 00        	lda #0	 		; zero in accumulator.
00311C  3  85 rr        	sta comcnt 		; reset compression counter.
00311E  3  AD 21 28     	lda winhgt 		; height of window.
003121  3  85 rr        	sta rrow		; set row counter
003123  3               droom0:
003123  3  AD 20 28     	lda winlft 		; window left edge.
003126  3  85 rr        	sta dispx 		; set cursor x position.
003128  3  AD 22 28     	lda winwid 		; width of window.
00312B  3  85 rr        	sta rcol		; set column counter
00312D  3               droom1:
00312D  3  20 3E 31     	jsr flbyt 		; decompress next byte on the fly.
003130  3  20 61 30     	jsr pattr2 		; show attributes and block.
003133  3  C6 rr        	dec rcol		; one less column.
003135  3  D0 F6        	bne droom1 		; repeat for entire line.
003137  3  E6 rr        	inc dispy		; move down one line.
003139  3  C6 rr        	dec rrow 		; one less row.
00313B  3  D0 E6        	bne droom0 		; repeat for all rows.
00313D  3  60           	rts
00313E  3               
00313E  3               ;rcol:	.byte 0
00313E  3               ;rrow:	.byte 0
00313E  3               
00313E  3               ;----------------------------------------------
00313E  3               ; Decompress bytes on-the-fly.
00313E  3               ;----------------------------------------------
00313E  3               
00313E  3               flbyt:
00313E  3  A5 rr        	lda comcnt 		; compression counter.
003140  3  D0 21        	bne flbyt1		; any more to decompress?  yes.
003142  3               
003142  3  A0 00        	ldy #0
003144  3  B1 66        	lda (z80_hl),y 		; fetch next byte.
003146  3  E6 66        	inc z80_l 		; point to next cell.
003148  3  D0 02        	bne :+
00314A  3  E6 67        	inc z80_h
00314C  3               :
00314C  3  C9 FF        	cmp #255 		; is this byte a control code?
00314E  3  F0 01        	beq :+
003150  3  60           	rts 			; no, this byte is uncompressed.
003151  3               :
003151  3  B1 66        	lda (z80_hl),y 		; fetch byte type.
003153  3  85 rr        	sta combyt 		; set up the type.
003155  3  E6 66        	inc z80_l 		; point to quantity.
003157  3  D0 02        	bne :+
003159  3  E6 67        	inc z80_h
00315B  3               :
00315B  3  B1 66        	lda (z80_hl),y 		; get quantity.
00315D  3  E6 66        	inc z80_l 		; point to next byte.
00315F  3  D0 02        	bne :+
003161  3  E6 67        	inc z80_h
003163  3               :
003163  3               flbyt1:
003163  3  85 rr        	sta comcnt 		; store new quantity.
003165  3  C6 rr        	dec comcnt		; one less.
003167  3  A5 rr        	lda combyt 		; byte to expand.
003169  3  60           	rts
00316A  3               
00316A  3               ;combyt:	.byte 0			; byte type compressed.
00316A  3               ;comcnt:	.byte 0			; compression counter.
00316A  3               
00316A  3               ;------------------------------------------
00316A  3               ; Ladder down check.
00316A  3               ;
00316A  3               ; Input:
00316A  3               ;  IX = sprite pointer
00316A  3               ;------------------------------------------
00316A  3               
00316A  3               .if lflag
00316A  3               laddd:
00316A  3               	ldy #9
00316A  3               	lda (z80_ix),y		; x coordinate.
00316A  3               	sta dispx
00316A  3               
00316A  3               	ldy #8
00316A  3               	lda (z80_ix),y		; y coordinate.
00316A  3               	and #254		; make it even.
00316A  3               	sta (z80_ix),y 		; reset it.
00316A  3               	clc 			; look down 16 pixels.
00316A  3               numsp5:
00316A  3               	adc #SPR_HGT
00316A  3               	sta dispy		; coords in dispx,dispy.
00316A  3               	jmp laddv
00316A  3               
00316A  3               ;------------------------------------------
00316A  3               ; Ladder up check.
00316A  3               ;
00316A  3               ; Input:
00316A  3               ;  IX = sprite pointer
00316A  3               ;
00316A  3               ; Output:
00316A  3               ;  A  = 0 is ok, A <>0 is not ok
00316A  3               ;------------------------------------------
00316A  3               
00316A  3               laddu:
00316A  3               	ldy #9
00316A  3               	lda (z80_ix),y		; x coordinate.
00316A  3               	sta dispx
00316A  3               
00316A  3               	ldy #8
00316A  3               	lda (z80_ix),y		; y coordinate.
00316A  3               	and #254 		; make it even.
00316A  3               	sta (z80_ix),y		; reset it.
00316A  3               	clc 			; look 2 pixels above feet.
00316A  3               numsp6:
00316A  3               	adc #SPR_HGT-2
00316A  3               	sta dispy		; coords in dispx,dispy.
00316A  3               laddv:
00316A  3               	jsr tstbl 		; get map address.
00316A  3               	jsr ldchk 		; standard ladder check.
00316A  3               	beq :+
00316A  3               	rts 			; no way through.
00316A  3               :
00316A  3               	inc bufaddr 		; look right one cell.
00316A  3               	bne :+
00316A  3               	inc bufaddr+1
00316A  3               :
00316A  3               	jsr ldchk 		; do the check.
00316A  3               	beq :+
00316A  3               	rts 			; impassable.
00316A  3               :
00316A  3               	lda dispx 		; y coordinate.
00316A  3               	and #7 			; position straddling block cells.
00316A  3               	bne :+
00316A  3               	rts 			; no more checks needed.
00316A  3               :
00316A  3               	inc bufaddr 		; look to third cell.
00316A  3               	bne :+
00316A  3               	inc bufaddr+1
00316A  3               :
00316A  3               	jsr ldchk 		; do the check.
00316A  3               	rts  			; return with zero flag set accordingly.
00316A  3               .endif
00316A  3               
00316A  3               ;---------------------------------------------------------
00316A  3               ; Can go up check.
00316A  3               ;
00316A  3               ; Input:
00316A  3               ;  IX = sprite pointer
00316A  3               ;
00316A  3               ; Output:
00316A  3               ;  A  = 0 is ok, A <>0 is not ok
00316A  3               ;---------------------------------------------------------
00316A  3               
00316A  3               cangu:
00316A  3  A0 09        	ldy #9
00316C  3  B1 68        	lda (z80_ix),y		; x coordinate.
00316E  3  85 rr        	sta dispx
003170  3  A0 08        	ldy #8
003172  3  B1 68        	lda (z80_ix),y 		; y coordinate.
003174  3  38           	sec
003175  3  E9 01        	sbc #1
003177  3  85 rr        	sta dispy		; coords in dispx,dispy.
003179  3  20 EA 32     	jsr tstbl 		; get map address.
00317C  3  20 4D 32     	jsr lrchk 		; standard left/right check.
00317F  3  F0 01        	beq :+
003181  3  60           	rts			; no way through.
003182  3               :
003182  3  E6 rr        	inc bufaddr		; look right one cell.
003184  3  D0 02        	bne :+
003186  3  E6 rr        	inc bufaddr+1
003188  3               :
003188  3  20 4D 32     	jsr lrchk 		; do the check.
00318B  3  F0 01        	beq :+
00318D  3  60           	rts			; impassable.
00318E  3               :
00318E  3  E6 rr        	inc bufaddr		; look right one cell.
003190  3  D0 02        	bne :+
003192  3  E6 rr        	inc bufaddr+1
003194  3               :
003194  3  20 4D 32     	jsr lrchk 		; do the check.
003197  3  F0 01        	beq :+
003199  3  60           	rts			; impassable.
00319A  3               :
00319A  3  E6 rr        	inc bufaddr		; look right one cell.
00319C  3  D0 02        	bne :+
00319E  3  E6 rr        	inc bufaddr+1
0031A0  3               :
0031A0  3  20 4D 32     	jsr lrchk 		; do the check.
0031A3  3  F0 01        	beq :+
0031A5  3  60           	rts			; impassable.
0031A6  3               :
0031A6  3  A5 rr        	lda dispx		; x coordinate.
0031A8  3  29 01        	and #1			; position straddling block cells.
0031AA  3  D0 01        	bne :+
0031AC  3  60           	rts			; no more checks needed.
0031AD  3               :
0031AD  3  E6 rr        	inc bufaddr		; look to third cell.
0031AF  3  D0 02        	bne :+
0031B1  3  E6 rr        	inc bufaddr+1
0031B3  3               :
0031B3  3  20 4D 32     	jsr lrchk		; do the check.
0031B6  3  60           	rts 			; return with zero flag set accordingly.
0031B7  3               
0031B7  3               ;---------------------------------------------------------
0031B7  3               ; Can go down check.
0031B7  3               ;
0031B7  3               ; Input:
0031B7  3               ;  IX = sprite pointer
0031B7  3               ;
0031B7  3               ; Output:
0031B7  3               ;  A  = 0 is ok, A <>0 is not ok
0031B7  3               ;---------------------------------------------------------
0031B7  3               
0031B7  3               cangd:
0031B7  3  A0 09        	ldy #9
0031B9  3  B1 68        	lda (z80_ix),y 		; x coordinate.
0031BB  3  85 rr        	sta dispx
0031BD  3  A0 08        	ldy #8
0031BF  3  B1 68        	lda (z80_ix),y		; y coordinate.
0031C1  3  18           	clc
0031C2  3               numsp3:
0031C2  3  69 09        	adc #SPR_HGT 		; look down 9 pixels.
0031C4  3  85 rr        	sta dispy		; coords in dispx,dispy.
0031C6  3  20 EA 32     	jsr tstbl 		; get map address.
0031C9  3  20 62 32     	jsr plchk 		; block, platform check.
0031CC  3  F0 01        	beq :+
0031CE  3  60           	rts			; no way through.
0031CF  3               :
0031CF  3  E6 rr        	inc bufaddr		; look right one cell.
0031D1  3  D0 02        	bne :+
0031D3  3  E6 rr        	inc bufaddr+1
0031D5  3               :
0031D5  3  20 62 32     	jsr plchk		; block, platform check.
0031D8  3  F0 01        	beq :+
0031DA  3  60           	rts			; impassable.
0031DB  3               :
0031DB  3  E6 rr        	inc bufaddr		; look right one cell.
0031DD  3  D0 02        	bne :+
0031DF  3  E6 rr        	inc bufaddr+1
0031E1  3               :
0031E1  3  20 62 32     	jsr plchk		; block, platform check.
0031E4  3  F0 01        	beq :+
0031E6  3  60           	rts			; impassable.
0031E7  3               :
0031E7  3  E6 rr        	inc bufaddr		; look right one cell.
0031E9  3  D0 02        	bne :+
0031EB  3  E6 rr        	inc bufaddr+1
0031ED  3               :
0031ED  3  20 62 32     	jsr plchk		; block, platform check.
0031F0  3  F0 01        	beq :+
0031F2  3  60           	rts			; impassable.
0031F3  3               :
0031F3  3  A5 rr        	lda dispx		; x coordinate.
0031F5  3  29 01        	and #1			; position straddling block cells.
0031F7  3  D0 01        	bne :+
0031F9  3  60           	rts			; no more checks needed.
0031FA  3               :
0031FA  3  E6 rr        	inc bufaddr		; look to third cell.
0031FC  3  D0 02        	bne :+
0031FE  3  E6 rr        	inc bufaddr+1
003200  3               :
003200  3  20 62 32     	jsr plchk		; block, platform check.
003203  3  60           	rts			; return with zero flag set accordingly.
003204  3               
003204  3               ;---------------------------------------------------------
003204  3               ; Can go left check.
003204  3               ;
003204  3               ; Input:
003204  3               ;  IX = sprite pointer
003204  3               ;
003204  3               ; Output:
003204  3               ;  A  = 0 is ok, A <>0 is not ok
003204  3               ;---------------------------------------------------------
003204  3               
003204  3               cangl:
003204  3  A0 08        	ldy #8
003206  3  B1 68        	lda (z80_ix),y 		; y coordinate.
003208  3  85 rr        	sta dispy
00320A  3  A0 09        	ldy #9
00320C  3  B1 68        	lda (z80_ix),y 		; x coordinate.
00320E  3  38           	sec
00320F  3  E9 01        	sbc #1			; look left 2 pixels.
003211  3  85 rr        	sta dispx		; coords in dispx,dispy.
003213  3  4C 25 32     	jmp cangh		; test if we can go there.
003216  3               
003216  3               ;---------------------------------------------------------
003216  3               ; Can go right check.
003216  3               ;
003216  3               ; Input:
003216  3               ;  IX = sprite pointer
003216  3               ;
003216  3               ; Output:
003216  3               ;  A  = 0 is ok, A <>0 is not ok
003216  3               ;---------------------------------------------------------
003216  3               
003216  3               cangr:
003216  3  A0 08        	ldy #8
003218  3  B1 68        	lda (z80_ix),y		; y coordinate.
00321A  3  85 rr        	sta dispy
00321C  3  A0 09        	ldy #9
00321E  3  B1 68        	lda (z80_ix),y		; x coordinate.
003220  3  18           	clc
003221  3  69 08        	adc #SPR_WID		; look right 8 pixels.
003223  3  85 rr        	sta dispx		; coords in dispx,dispy.
003225  3               cangh:
003225  3               cangh2:
003225  3  A9 04        	lda #(SPR_HGT/3+1)	; default rows to write.
003227  3  85 63        	sta z80_b
003229  3  A4 rr        	ldy dispy		; y position.
00322B  3  B9 4A DF     	lda V_SPR_PTR,y		; does x straddle cells?
00322E  3  D0 02        	bne cangh0		; yes, loop counter is good.
003230  3  C6 63        	dec z80_b		; one less row to write.
003232  3               cangh0:
003232  3  20 EA 32     	jsr tstbl		; get map address.
003235  3               cangh1:
003235  3  20 4D 32     	jsr lrchk		; standard left/right check.
003238  3  F0 01        	beq :+
00323A  3  60           	rts			; no way through.
00323B  3               :
00323B  3  48           	pha
00323C  3  18           	clc
00323D  3  A5 rr        	lda bufaddr
00323F  3  69 28        	adc #ScrWidth		; look down.
003241  3  85 rr        	sta bufaddr
003243  3  90 02        	bcc :+
003245  3  E6 rr        	inc bufaddr+1
003247  3               :
003247  3  68           	pla
003248  3               
003248  3  C6 63        	dec z80_b
00324A  3  D0 E9        	bne cangh1
00324C  3  60           	rts
00324D  3               
00324D  3               ;-------------------------------------
00324D  3               ; Check left/right movement is okay.
00324D  3               ;
00324D  3               ; Input:
00324D  3               ;  bufaddr = MAP + x/8 + y/8*32
00324D  3               ;
00324D  3               ; Output:
00324D  3               ;  A  = 0 is ok, A <>0 is not ok
00324D  3               ;-------------------------------------
00324D  3               
00324D  3               lrchk:
00324D  3  A0 00        	ldy #0
00324F  3  B1 rr        	lda (bufaddr),y		; fetch map cell.
003251  3  C9 02        	cmp #WALL 		; is it passable?
003253  3  F0 0A        	beq lrchkx		; no.
003255  3               
003255  3  C9 04        	cmp #FODDER		; fodder has to be dug.
003257  3  F0 06        	beq lrchkx		; not passable.
003259  3  A9 00        	lda #0
00325B  3  60           	rts
00325C  3               
00325C  3               ;--------------------------------------------------------------
00325C  3               ; Called by mmenu
00325C  3               ;--------------------------------------------------------------
00325C  3               
00325C  3               always:
00325C  3  A9 FF        	lda #255		; report it as okay.
00325E  3  60           	rts
00325F  3               
00325F  3               lrchkx:
00325F  3  A9 01        	lda #1 			; reset all bits.
003261  3  60           	rts
003262  3               
003262  3               
003262  3               ;--------------------------------------------------------------
003262  3               ; Check platform or solid item is not in way.
003262  3               ;
003262  3               ; Input:
003262  3               ;  bufaddr = MAP + x/2 + y/3*40
003262  3               ;
003262  3               ; Output:
003262  3               ;  A  = 0 is ok, A <>0 is not ok
003262  3               ;--------------------------------------------------------------
003262  3               
003262  3               plchk:
003262  3  A0 00        	ldy #0
003264  3  B1 rr        	lda (bufaddr),y 	; fetch map cell.
003266  3  C9 02        	cmp #WALL 		; is it passable?
003268  3  F0 F5        	beq lrchkx		; no.
00326A  3               .if pflag .or dflag
00326A  3               	cmp #FODDER		; fodder has to be dug.
00326A  3               	beq lrchkx		; not passable.
00326A  3               .endif
00326A  3  C9 01        	cmp #PLATFM		; platform is solid.
00326C  3  F0 03        	beq plchkx		; not passable.
00326E  3               .if lflag
00326E  3               	cmp #LADDER		; is it a ladder?
00326E  3               	beq lrchkx		; on ladder, deny movement.
00326E  3               .endif
00326E  3               plchk0:
00326E  3  A9 00        	lda #0			; report as ok
003270  3  60           	rts
003271  3               plchkx:
003271  3  A4 rr        	ldy dispy		; y coordinate.
003273  3  B9 4A DF     	lda V_SPR_PTR,y		; position straddling blocks.
003276  3  F0 E7        	beq lrchkx		; on platform, deny movement.
003278  3  4C 6E 32     	jmp plchk0
00327B  3               
00327B  3               ;--------------------------------------------------------------
00327B  3               ; Check ladder is available.
00327B  3               ;
00327B  3               ; Input:
00327B  3               ;  bufaddr = MAP + x/8 + y/8*32
00327B  3               ;
00327B  3               ; Output:
00327B  3               ;  A  = 0 is ok, A <>0 is not ok
00327B  3               ;--------------------------------------------------------------
00327B  3               
00327B  3               .if lflag
00327B  3               ldchk:
00327B  3               	ldy #0
00327B  3               	lda (bufaddr),y 	; fetch cell.
00327B  3               	cmp #LADDER 		; is it a ladder?
00327B  3               	beq :+
00327B  3               	lda #1
00327B  3               	rts  			; return with zero flag set accordingly.
00327B  3               :
00327B  3               	lda #0
00327B  3               	rts
00327B  3               .endif
00327B  3               
00327B  3               ;--------------------------------------------------------------
00327B  3               ; Get collectables.
00327B  3               ;--------------------------------------------------------------
00327B  3               
00327B  3               .if cflag
00327B  3               getcol:
00327B  3                       lda #COLECT             ; collectable blocks.
00327B  3                       sta z80_b
00327B  3                       jsr tded                ; test for collectable blocks.
00327B  3                       cmp z80_b               ; did we find one?
00327B  3                       beq :+
00327B  3                       rts                     ; none were found, job done.
00327B  3               :
00327B  3                       jsr gtblk               ; get block.
00327B  3                       jsr evnt20              ; collected block event.
00327B  3                       jmp getcol              ; repeat until none left.
00327B  3               
00327B  3               ; Get collectable block.
00327B  3               
00327B  3               gtblk:
00327B  3               	ldy #0
00327B  3               	lda (bufaddr),y
00327B  3               	sta colpatt		; save collectable block nr
00327B  3               
00327B  3                       lda #0
00327B  3                       sta (bufaddr),y		; make it empty now in MAP.
00327B  3               
00327B  3               	lda bufaddr		; calculate screenaddr
00327B  3               	sta scraddr
00327B  3               	sec
00327B  3               	lda bufaddr+1
00327B  3               	sbc #>(MAP-ScreenAddr)	;$d4
00327B  3               	sta scraddr+1
00327B  3               
00327B  3               	ldy #0			; erase block on screen
00327B  3               	lda (scraddr),y
00327B  3               	eor colpatt
00327B  3               	sta (scraddr),y
00327B  3               
00327B  3               	rts
00327B  3               .endif
00327B  3               
00327B  3               ;--------------------------------------------------------------
00327B  3               ; Touched deadly block check.
00327B  3               ; returns with DEADLY (must be non-zero) in accumulator if true.
00327B  3               ;
00327B  3               ; Input:
00327B  3               ;  IX = sprite address
00327B  3               ;
00327B  3               ; Output:
00327B  3               ;  A  = 0 is ok, A=5 is not ok
00327B  3               ;--------------------------------------------------------------
00327B  3               
00327B  3               ; Calculate map address from dispx,dispy
00327B  3               
00327B  3               tded:
00327B  3  A0 08        	ldy #8
00327D  3  B1 68        	lda (z80_ix),y 		; y coordinate.
00327F  3  85 rr        	sta dispy
003281  3  C8           	iny
003282  3  B1 68        	lda (z80_ix),y 		; x coordinate.
003284  3  85 rr        	sta dispx		; coords in dispx,dispy.
003286  3  20 EA 32     	jsr tstbl		; get map address in bufaddr.
003289  3               
003289  3               ; Set variables
003289  3               
003289  3  A9 00        	lda #0
00328B  3  85 62        	sta z80_c		; reset x-stradding skip flag
00328D  3               
00328D  3  A9 04        	lda #4			; Set nr of sprite columns
00328F  3  85 rr        	sta rcol
003291  3  A5 rr        	lda dispx
003293  3  29 01        	and #1
003295  3  D0 04        	bne :+
003297  3  C6 rr        	dec rcol
003299  3  E6 62        	inc z80_c		; set x-stradding skip flag
00329B  3               :
00329B  3  A5 rr        	lda rcol
00329D  3  85 64        	sta z80_e
00329F  3               
00329F  3  A9 03        	lda #3			; Set nr of sprite rows
0032A1  3  85 rr        	sta rrow
0032A3  3  A4 rr        	ldy dispy
0032A5  3  B9 4A DF     	lda V_SPR_PTR,y
0032A8  3  D0 02        	bne :+
0032AA  3  C6 rr        	dec rrow
0032AC  3               :
0032AC  3  A2 00        	ldx #0
0032AE  3               vspr_loop:
0032AE  3  A5 64        	lda z80_e
0032B0  3  85 rr        	sta rcol
0032B2  3               hspr_loop:
0032B2  3  BC D6 32     	ldy spr_ptr,x
0032B5  3  B1 rr        	lda (bufaddr),y
0032B7  3  C5 63        	cmp z80_b
0032B9  3  F0 0E        	beq end_sprloop
0032BB  3  E8           	inx
0032BC  3  C6 rr        	dec rcol
0032BE  3  10 F2        	bpl hspr_loop
0032C0  3               ;	inx
0032C0  3  A4 62        	ldy z80_c		; Test x-stradding skip flag
0032C2  3  F0 01        	beq :+			; If reset, no skipping
0032C4  3  E8           	inx			; If set, skip 1 byte
0032C5  3               :
0032C5  3  C6 rr        	dec rrow
0032C7  3  10 E5        	bpl vspr_loop
0032C9  3               end_sprloop:
0032C9  3  48           	pha
0032CA  3  18           	clc
0032CB  3  98           	tya
0032CC  3  65 rr        	adc bufaddr
0032CE  3  85 rr        	sta bufaddr
0032D0  3  90 02        	bcc :+
0032D2  3  E6 rr        	inc bufaddr+1
0032D4  3               :
0032D4  3  68           	pla
0032D5  3  60           	rts
0032D6  3               
0032D6  3               spr_ptr:
0032D6  3  00 01 02 03  	.byte   0,  1,  2,  3,  4
0032DA  3  04           
0032DB  3  28 29 2A 2B  	.byte  40, 41, 42, 43, 44
0032DF  3  2C           
0032E0  3  50 51 52 53  	.byte  80, 81, 82, 83, 84
0032E4  3  54           
0032E5  3  78 79 7A 7B  	.byte 120,121,122,123,124
0032E9  3  7C           
0032EA  3               
0032EA  3               ;---------------------------------------------------
0032EA  3               ; Fetch block type at (dispx, dispy).
0032EA  3               ;
0032EA  3               ; Output:
0032EA  3               ;  A = block type
0032EA  3               ;---------------------------------------------------
0032EA  3               
0032EA  3               tstbl:
0032EA  3  A5 rr        	lda dispy 		; fetch y coord.
0032EC  3  AA           	tax
0032ED  3               
0032ED  3  A5 rr        	lda dispx		; x/2
0032EF  3  4A           	lsr a
0032F0  3  85 rr        	sta charx
0032F2  3               
0032F2  3  18           	clc			; Get offset address
0032F3  3  BD 00 DC     	lda SCADTB_lb,x
0032F6  3  65 rr        	adc charx
0032F8  3  85 rr        	sta bufaddr
0032FA  3               
0032FA  3  BD 00 DD     	lda SCADTB_hb,x
0032FD  3  69 D4        	adc #(>MAP->ScreenAddr)	; Get map address
0032FF  3  85 rr        	sta bufaddr+1
003301  3               
003301  3  A0 00        	ldy #0
003303  3  B1 rr        	lda (bufaddr),y 	; fetch byte there.
003305  3  60           	rts
003306  3               
003306  3               ;-------------------------------------------------------------------
003306  3               ; Jump - if we can.
003306  3               ; Requires initial speed to be set up in accumulator prior to call.
003306  3               ;
003306  3               ; Input:
003306  3               ;  IX = sprite address
003306  3               ;-------------------------------------------------------------------
003306  3               
003306  3               jump:
003306  3  A0 0D        	ldy #13
003308  3  B1 68        	lda (z80_ix),y		; jump table low.
00330A  3  A0 0E        	ldy #14
00330C  3  11 68        	ora (z80_ix),y		; jump table high.
00330E  3  F0 01        	beq :+
003310  3  60           	rts			; already in the air.
003311  3               :
003311  3  A9 44        	lda #>jtab
003313  3  A0 0E        	ldy #14
003315  3  91 68        	sta (z80_ix),y		; set jump high.
003317  3  A9 9C        	lda #<jtab		; jump table start.
003319  3  A0 0D        	ldy #13
00331B  3  91 68        	sta (z80_ix),y		; set jump low.
00331D  3  60           	rts
00331E  3               
00331E  3               ; Jump table.
00331E  3               
00331E  3               ;jtab:
00331E  3               ;	.byte 248,250,252
00331E  3               ;	.byte 254,254,255
00331E  3               ;	.byte 255,255,0,0
00331E  3               ;	.byte 0,1,1,1,2,2
00331E  3               ;	.byte 4,6,8,8,8,99
00331E  3               
00331E  3               ;------------------------------------------------
00331E  3               ; Random numbers code.
00331E  3               ; Pseudo-random number generator, 8-bit.
00331E  3               ;
00331E  3               ; Output:
00331E  3               ;  RND = random number
00331E  3               ;------------------------------------------------
00331E  3               
00331E  3               random:
00331E  3  A5 rr        	lda seed
003320  3  F0 05        	beq doEor
003322  3  0A           	asl a
003323  3  F0 04        	beq noEor
003325  3  90 02        	bcc noEor
003327  3  49 1D        doEor:	eor #$1d
003329  3  85 rr        noEor:	sta seed
00332B  3  60           	rts
00332C  3               
00332C  3  A5 rr        	lda seed		; get last random number.
00332E  3  0A           	asl a
00332F  3  0A           	asl a
003330  3  18           	clc
003331  3  65 rr        	adc seed
003333  3  18           	clc
003334  3  69 45        	adc #$45
003336  3  85 rr        	sta seed		; store new seed.
003338  3  85 rr        	sta varrnd		; return number in variable.
00333A  3  60           	rts
00333B  3               
00333B  3               ;--------------------------------------------------------
00333B  3               ; Keys
00333B  3               ;
00333B  3               ; Out: joyval=x65FUDLR (bit cleared if key pressed)
00333B  3               ;             ||||||||
00333B  3               ;             |||||||+> Right    KEY 0  - X
00333B  3               ;             ||||||+-> Left     KEY 1  - Z
00333B  3               ;             |||||+--> Down     KEY 2  - .
00333B  3               ;             ||||+---> Up       KEY 3  - ;
00333B  3               ;             |||+----> Fire1    KEY 4  - SPC
00333B  3               ;             ||+-----> Fire2    KEY 5  - Q
00333B  3               ;             |+------> Fire3    KEY 6  - P
00333B  3               ;             +-------> Not used
00333B  3               ;
00333B  3               ;                       Option1  KEY 7  - 1
00333B  3               ;                       Option2  KEY 8  - 2
00333B  3               ;                       Option3  KEY 9  - 3
00333B  3               ;                       Option4  KEY 10 - 4
00333B  3               ;--------------------------------------------------------
00333B  3               
00333B  3               ;              X   Z   .   ;  SPC  Q   P
00333B  3               ;keys:   .byte $35,$15,$93,$22,$90,$04,$14       ; Keys defined by game designer.
00333B  3               ;        .byte $21,$11,$01,$92                   ; menu options.
00333B  3  03 01 02 04  jkeys:  .byte $03,$01,$02,$04,$00,$04,$14       ; Joykey keys
00333F  3  00 04 14     
003342  3  21 11 01 92          .byte $21,$11,$01,$92                   ; menu options.
003346  3               
003346  3               ;-------------------------------------------------------
003346  3               ; Joystick and keyboard reading routines.
003346  3               ;
003346  3               ; contrl = 0, Keyboard
003346  3               ;          1, JoyKeyb
003346  3               ;          2, JoyMMC
003346  3               ;-------------------------------------------------------
003346  3               
003346  3               joykey:
003346  3  A5 rr        	lda contrl 		; control flag.
003348  3  C9 01        	cmp #1
00334A  3  D0 03        	bne :+
00334C  3  4C B5 45     	jmp joy1 		; read keyboard joystick
00334F  3               :
00334F  3  C9 02        	cmp #2
003351  3  D0 03        	bne :+
003353  3  4C E7 45     	jmp joy2 		; read MMC joystick.
003356  3               :
003356  3               ; Keyboard controls.
003356  3               
003356  3  A9 00        	lda #0		 	; zero reading.
003358  3  85 64        	sta z80_e
00335A  3               
00335A  3  A0 06        	ldy #6	 		; address of last key.
00335C  3               joyke0:
00335C  3  B9 9D 44     	lda keys,y 		; get key from table.
00335F  3  20 E8 45     	jsr ktest		; being pressed?
003362  3  26 64        	rol z80_e 		; rotate into reading.
003364  3               
003364  3  88           	dey		 	; next key.
003365  3  10 F5        	bpl joyke0 		; repeat for all keys.
003367  3  A5 64        	lda z80_e 		; copy e register to accumulator.
003369  3  85 rr        	sta joyval		; remember value.
00336B  3  60           	rts
00336C  3               
00336C  3               ;---------------------------------------------------------------
00336C  3               ; Getkey in column,row format
00336C  3               ;
00336C  3               ; Output:
00336C  3               ;  A = high nibble=row and low nibble=column key in matrix
00336C  3               ;---------------------------------------------------------------
00336C  3               
00336C  3               ;kget:
00336C  3               ;	lda #ScrMode		; high-mono mode.
00336C  3               ;	sta ScrSelAddr		; screen select port
00336C  3               ;	stx xtmp
00336C  3               ;kget4:
00336C  3               ;	jsr READKEY		; read key until pressed
00336C  3               ;	cpy #255
00336C  3               ;	beq kget4
00336C  3               ;	sta rcol		; save column
00336C  3               ;	stx rrow		; determine row
00336C  3               ;kget3:
00336C  3               ;	jsr READKEY		; wait until key released
00336C  3               ;	cpy #255
00336C  3               ;	bne kget3
00336C  3               ;
00336C  3               ;	sec			; calculate matrix row
00336C  3               ;	lda #10
00336C  3               ;	sbc rrow
00336C  3               ;	asl a
00336C  3               ;	asl a
00336C  3               ;	asl a
00336C  3               ;	asl a
00336C  3               ;	sta rrow
00336C  3               ;
00336C  3               ;	ldy #255		; find column mask
00336C  3               ;kget1:
00336C  3               ;	iny
00336C  3               ;	lda keymask,y
00336C  3               ;	cmp rcol
00336C  3               ;	beq kget2
00336C  3               ;	jmp kget1
00336C  3               ;kget2:
00336C  3               ;	tya			; determine column
00336C  3               ;	clc
00336C  3               ;	adc rrow
00336C  3               ;	ldx xtmp
00336C  3               ;	rts
00336C  3               
00336C  3               ;---------------------------------------------------------------
00336C  3               ; Display message.
00336C  3               ;
00336C  3               ; Input:
00336C  3               ;  A = message number
00336C  3               ;---------------------------------------------------------------
00336C  3               
00336C  3               dmsg:
00336C  3  AA           	tax
00336D  3  A9 29        	lda #<msgdat		; pointer to messages.
00336F  3  85 66        	sta z80_l
003371  3  A9 3E        	lda #>msgdat
003373  3  85 67        	sta z80_h
003375  3  20 7F 34     	jsr getwrd		; get message number.
003378  3               dmsg3:
003378  3  20 76 34     	jsr preprt		; pre-printing stuff.
00337B  3  20 C1 2E     	jsr checkx		; make sure we"re in a printable range.
00337E  3  A5 rr        	lda prtmod		; print mode.
003380  3  D0 50        	bne bmsg1		; no, double-height text.
003382  3               
003382  3  AD 1D 3C     	lda fcolour		; Set textcolour
003385  3  20 47 30     	jsr pchar
003388  3  20 4C 34     	jsr nexpos
00338B  3               dmsg0:
00338B  3  A5 67        	lda z80_h		; store string pointer.
00338D  3  48           	pha
00338E  3  A5 66        	lda z80_l
003390  3  48           	pha
003391  3               
003391  3  A0 00        	ldy #0
003393  3  B1 66        	lda (z80_hl),y		; fetch byte to display.
003395  3  29 7F        	and #127		; remove any end marker.
003397  3  C9 0D        	cmp #13
003399  3  F0 24        	beq dmsg1
00339B  3  20 47 30     	jsr pchar		; display character.
00339E  3  20 4C 34     	jsr nexpos 		; display position.
0033A1  3  D0 03        	bne dmsg2		; not on a new line.
0033A3  3  20 68 34     	jsr nexlin		; next line down.
0033A6  3               dmsg2:
0033A6  3  68           	pla			; retrieve string pointer
0033A7  3  85 66        	sta z80_l
0033A9  3  68           	pla
0033AA  3  85 67        	sta z80_h
0033AC  3               
0033AC  3  A0 00        	ldy #0
0033AE  3  B1 66        	lda (z80_hl),y		; fetch last character.
0033B0  3  0A           	asl a  			; was it the end?
0033B1  3  90 03        	bcc :+
0033B3  3  4C 14 2F     	jmp dscor2		; yes, job done.
0033B6  3               :
0033B6  3  E6 66        	inc z80_l		; next character to display.
0033B8  3  D0 02        	bne :+
0033BA  3  E6 67        	inc z80_h
0033BC  3               :
0033BC  3  4C 8B 33     	jmp dmsg0
0033BF  3               dmsg1:
0033BF  3  E6 rr        	inc dispy
0033C1  3  A5 rr        	lda dispy
0033C3  3  C9 19        	cmp #ScrHeight
0033C5  3  90 04        	bcc dmsg4
0033C7  3  A9 00        	lda #0
0033C9  3  85 rr        	sta dispy
0033CB  3               dmsg4:
0033CB  3  A9 00        	lda #0
0033CD  3  85 rr        	sta dispx
0033CF  3  4C A6 33     	jmp dmsg2
0033D2  3               
0033D2  3               ;prtmod:	.byte 0            	; print mode, 0 = standard, 1 = double-height.
0033D2  3               
0033D2  3               ;----------------------------------------------------------
0033D2  3               ; Display message in big text.
0033D2  3               ;
0033D2  3               ; Input:
0033D2  3               ;  HL = string pointer
0033D2  3               ;----------------------------------------------------------
0033D2  3               
0033D2  3               bmsg1:
0033D2  3  AD 1D 3C     	lda fcolour		; Set textcolour
0033D5  3  20 1D 34     	jsr bchar
0033D8  3  A9 0D        	lda #13			; Set double height
0033DA  3  20 1D 34     	jsr bchar
0033DD  3               bmsg4:
0033DD  3  A0 00        	ldy #0
0033DF  3  B1 66        	lda (z80_hl),y 		; get character to display.
0033E1  3  29 7F        	and #127		; only want 7 bits.
0033E3  3  C9 0D        	cmp #13
0033E5  3  F0 21        	beq bmsg2
0033E7  3  20 1D 34     	jsr bchar 		; display big char.
0033EA  3               bmsg3:
0033EA  3  A0 00        	ldy #0
0033EC  3  B1 66        	lda (z80_hl),y 		; look at last character.
0033EE  3  48           	pha
0033EF  3  E6 66        	inc z80_l 		; next character in list.
0033F1  3  D0 02        	bne :+
0033F3  3  E6 67        	inc z80_h
0033F5  3               :
0033F5  3  68           	pla
0033F6  3  0A           	asl a  			; was terminator flag set?
0033F7  3  90 E4        	bcc bmsg4		; no, keep going.
0033F9  3  20 14 2F     	jsr dscor2
0033FC  3  C6 rr        	dec dispx
0033FE  3  E6 rr        	inc dispy
003400  3  20 14 2F     	jsr dscor2
003403  3  C6 rr        	dec dispy
003405  3  C6 rr        	dec chary
003407  3  60           	rts
003408  3               bmsg2:
003408  3  A9 00        	lda #0
00340A  3  85 rr        	sta dispx
00340C  3  E6 rr        	inc dispy
00340E  3  E6 rr        	inc dispy
003410  3  A5 rr        	lda dispy
003412  3  C9 18        	cmp #ScrHeight-1
003414  3  90 D4        	bcc bmsg3
003416  3  A9 00        	lda #0
003418  3  85 rr        	sta dispy
00341A  3  4C EA 33     	jmp bmsg3
00341D  3               
00341D  3               ;----------------------------------------------------------
00341D  3               ; Big character display.
00341D  3               ;
00341D  3               ; Input:
00341D  3               ;  A = character
00341D  3               ;----------------------------------------------------------
00341D  3               
00341D  3               bchar:
00341D  3  20 47 30     	jsr pchar 		; display big char.
003420  3  E6 rr        	inc dispy
003422  3  20 47 30     	jsr pchar
003425  3  C6 rr        	dec dispy
003427  3  20 4C 34     	jsr nexpos		; display position.
00342A  3  60           	rts
00342B  3               
00342B  3               bchar3:
00342B  3  E6 rr        	inc dispy
00342D  3  20 68 34     	jsr nexlin 		; next line check.
003430  3               bchar2:
003430  3  4C 14 2F     	jmp dscor2		; tidy up line and column variables.
003433  3               
003433  3               
003433  3               ;-------------------------------------------------
003433  3               ; Display a character.
003433  3               ;
003433  3               ; Input:
003433  3               ;  A = character
003433  3               ;-------------------------------------------------
003433  3               
003433  3               achar:
003433  3  85 63        	sta z80_b 		; copy to b.
003435  3  20 76 34     	jsr preprt 		; get ready to print.
003438  3  A5 63        	lda z80_b		; character in accumulator.
00343A  3  A6 rr        	ldx prtmod 		; print mode.
00343C  3  F0 03        	beq :+
00343E  3  4C 1D 34     	jmp bchar 		; no, double-height text.
003441  3               :
003441  3  20 47 30     	jsr pchar 		; display character.
003444  3  20 4C 34     	jsr nexpos 		; display position.
003447  3  F0 E2        	beq bchar3		; next line down.
003449  3  4C 30 34     	jmp bchar2 		; tidy up.
00344C  3               
00344C  3               
00344C  3               ;-------------------------------------------------
00344C  3               ; Get next print column position.
00344C  3               ;-------------------------------------------------
00344C  3               
00344C  3               nexpos:
00344C  3  E6 rr        	inc dispx		; move along one position.
00344E  3  A5 rr        	lda prtmod
003450  3  F0 13        	beq skip
003452  3  A5 rr        	lda dispx 		; get coordinate.
003454  3  C9 28        	cmp #40
003456  3  D0 0D        	bne skip
003458  3  E6 rr        	inc dispy
00345A  3  E6 rr        	inc dispy
00345C  3  A9 01        	lda #1
00345E  3  85 rr        	sta dispx
003460  3  A9 0D        	lda #$d
003462  3  20 1D 34     	jsr bchar
003465  3               skip:
003465  3  A5 rr        	lda dispx
003467  3  60           	rts 			; return with status in zero flag.
003468  3               
003468  3               ;-------------------------------------------------
003468  3               ; Get next print line position.
003468  3               ;-------------------------------------------------
003468  3               
003468  3               nexlin:
003468  3  E6 rr        	inc dispy 		; newline.
00346A  3  A5 rr        	lda dispy		; vertical position.
00346C  3  C9 19        	cmp #ScrHeight			; past screen edge?
00346E  3  B0 01        	bcs :+
003470  3  60           	rts			; no, still okay.
003471  3               :
003471  3  A9 00        	lda #0			; restart at top.
003473  3  85 rr        	sta dispy
003475  3  60           	rts
003476  3               
003476  3               ;--------------------------------------------------------
003476  3               ; Pre-print preliminaries.
003476  3               ;--------------------------------------------------------
003476  3               
003476  3               preprt:
003476  3               ;	lda #<(FONT-256)		; font pointer.
003476  3               ;	sta grbase		; set up graphics base.
003476  3               ;	lda #>(FONT-256)
003476  3               ;	sta grbase+1
003476  3               prescr:
003476  3  A5 rr        	lda charx 		; display coordinates.
003478  3  85 rr        	sta dispx		; set up general coordinates.
00347A  3  A5 rr        	lda chary
00347C  3  85 rr        	sta dispy
00347E  3  60           	rts
00347F  3               
00347F  3               ;--------------------------------------------------------------
00347F  3               ; Get messagenr x in hl
00347F  3               ;
00347F  3               ; Input:
00347F  3               ;  HL = pointer to message list
00347F  3               ;  X  = message number.
00347F  3               ;--------------------------------------------------------------
00347F  3               
00347F  3               getwrd:
00347F  3  E0 00        	cpx #0
003481  3  D0 01        	bne:+ 			; first word in list?
003483  3  60           	rts 			; yep, don't search.
003484  3               :
003484  3  A0 00        	ldy #0
003486  3               getwd0:
003486  3  B1 66        	lda (z80_hl),y
003488  3  48           	pha
003489  3  E6 66        	inc z80_l
00348B  3  D0 02        	bne :+
00348D  3  E6 67        	inc z80_h
00348F  3               :
00348F  3  68           	pla
003490  3  C9 80        	cmp #128		; found end?
003492  3  30 F2        	bmi getwd0		; no, carry on.
003494  3  CA           	dex			; until we have right number.
003495  3  D0 EF        	bne getwd0
003497  3  60           	rts
003498  3               
003498  3               ;-----------------------------------------------------------
003498  3               ; Bubble sort.
003498  3               ;-----------------------------------------------------------
003498  3               
003498  3               bsort:
003498  3  A9 0B        	lda #NUMSPR - 1		; sprites to swap.
00349A  3  85 rr        	sta qscnt
00349C  3               
00349C  3  A9 2F        	lda #<sprtab 		; sprite table.
00349E  3  85 68        	sta z80_x
0034A0  3  A9 3B        	lda #>sprtab
0034A2  3  85 69        	sta z80_i
0034A4  3               bsort0:
0034A4  3  A0 00        	ldy #0
0034A6  3  B1 68        	lda (z80_ix),y 		; first sprite type.
0034A8  3  C9 FF        	cmp #255 		; is it switched off?
0034AA  3  F0 30        	beq swemp		; yes, may need to switch another in here.
0034AC  3               
0034AC  3  A0 11        	ldy #TABSIZ
0034AE  3  B1 68        	lda (z80_ix),y 		; check next slot exists.
0034B0  3  C9 FF        	cmp #255 		; is it enabled?
0034B2  3  F0 0A        	beq bsort2 		; no, nothing to swap.
0034B4  3               
0034B4  3  A0 14        	ldy #TABSIZ+3
0034B6  3  B1 68        	lda (z80_ix),y 		; fetch next sprite's coordinate.
0034B8  3  A0 03        	ldy #3
0034BA  3  D1 68        	cmp (z80_ix),y 		; compare with this x coordinate.
0034BC  3  90 10        	bcc bsort1		; next sprite is higher - may need to switch.
0034BE  3               bsort2:
0034BE  3  18           	clc
0034BF  3  A5 68        	lda z80_x
0034C1  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
0034C3  3  85 68        	sta z80_x
0034C5  3  90 02        	bcc :+
0034C7  3  E6 69        	inc z80_i
0034C9  3               :
0034C9  3  C6 rr        	dec qscnt
0034CB  3  D0 D7        	bne bsort0		; repeat for remaining sprites.
0034CD  3  60           	rts
0034CE  3               
0034CE  3               ;qscnt:	.byte 0
0034CE  3               
0034CE  3               bsort1:
0034CE  3  A0 11        	ldy #TABSIZ
0034D0  3  B1 68        	lda (z80_ix),y		; sprite on/off flag.
0034D2  3  C9 FF        	cmp #255		; is it enabled?
0034D4  3  F0 E8        	beq bsort2		; no, nothing to swap.
0034D6  3  20 EA 34     	jsr swspr		; swap positions.
0034D9  3  4C BE 34     	jmp bsort2
0034DC  3               swemp:
0034DC  3  A0 11        	ldy #TABSIZ
0034DE  3  B1 68        	lda (z80_ix),y		; next table entry.
0034E0  3  C9 FF        	cmp #255		; is that one on?
0034E2  3  F0 DA        	beq bsort2		; no, nothing to swap.
0034E4  3  20 EA 34     	jsr swspr		; swap positions.
0034E7  3  4C BE 34     	jmp bsort2
0034EA  3               
0034EA  3               ; Swap sprites.
0034EA  3               
0034EA  3               swspr:
0034EA  3  A5 68        	lda z80_x		; table address
0034EC  3  85 64        	sta z80_e		; copy to de pair.
0034EE  3  85 66        	sta z80_l		; copy to hl pair.
0034F0  3  A5 69        	lda z80_i
0034F2  3  85 67        	sta z80_h
0034F4  3  85 65        	sta z80_d
0034F6  3               
0034F6  3  18           	clc
0034F7  3  A5 66        	lda z80_l
0034F9  3  69 11        	adc #TABSIZ		; distance to second entry.
0034FB  3  85 66        	sta z80_l
0034FD  3  90 02        	bcc :+
0034FF  3  E6 67        	inc z80_h
003501  3               :
003501  3  A9 11        	lda #TABSIZ		; bytes to swap.
003503  3  85 63        	sta z80_b
003505  3  A0 00        	ldy #0
003507  3               swspr0:
003507  3  B1 66        	lda (z80_hl),y		; fetch second byte.
003509  3  48           	pha
00350A  3  B1 64        	lda (z80_de),y 		; fetch first byte.
00350C  3  91 66        	sta (z80_hl),y 		; copy to second.
00350E  3  68           	pla
00350F  3  91 64        	sta (z80_de),y 		; copy to first sprite entry.
003511  3               
003511  3  E6 64        	inc z80_e 		; next byte.
003513  3  D0 02        	bne :+
003515  3  E6 65        	inc z80_d
003517  3               :
003517  3  E6 66        	inc z80_l 		; next byte.
003519  3  D0 02        	bne :+
00351B  3  E6 67        	inc z80_h
00351D  3               :
00351D  3  C6 63        	dec z80_b
00351F  3  D0 E6        	bne swspr0 		; swap all bytes in table entry.
003521  3  60           	rts
003522  3               
003522  3               ;----------------------------------------------------
003522  3               ; Process sprites.
003522  3               ;----------------------------------------------------
003522  3               
003522  3               pspr:
003522  3  A9 0C        	lda #NUMSPR		; sprites to process.
003524  3  85 rr        	sta sprptr
003526  3               
003526  3  A9 2F        	lda #<sprtab 		; sprite table.
003528  3  85 68        	sta z80_x
00352A  3  A9 3B        	lda #>sprtab
00352C  3  85 69        	sta z80_i
00352E  3               pspr1:
00352E  3  A0 00        	ldy #0
003530  3  B1 68        	lda (z80_ix),y		; fetch sprite type.
003532  3  C9 09        	cmp #9 			; within range of sprite types?
003534  3  B0 03        	bcs :+
003536  3  20 49 35     	jsr pspr2 		; yes, process this one.
003539  3               :
003539  3  18           	clc
00353A  3  A5 68        	lda z80_x
00353C  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
00353E  3  85 68        	sta z80_x
003540  3  90 02        	bcc :+
003542  3  E6 69        	inc z80_i		; next sprite.
003544  3               :
003544  3  C6 rr        	dec sprptr 		; repeat for remaining sprites.
003546  3  D0 E6        	bne pspr1
003548  3  60           	rts
003549  3               
003549  3               ;sprptr:	.byte 0
003549  3               
003549  3               pspr2:
003549  3  A5 68        	lda z80_x 		; store original sprite pointer.
00354B  3  85 rr        	sta ogptr
00354D  3  A5 69        	lda z80_i
00354F  3  85 rr        	sta ogptr+1
003551  3  20 5D 35     	jsr pspr3		; do the routine.
003554  3               rtorg:
003554  3  A5 rr        	lda ogptr 		; restore original pointer to sprite.
003556  3  85 68        	sta z80_x
003558  3  A5 rr        	lda ogptr+1
00355A  3  85 69        	sta z80_i
00355C  3               rtorg0:
00355C  3  60           	rts
00355D  3               
00355D  3               pspr3:
00355D  3  A9 92        	lda #<evtyp0		; sprite type events list.
00355F  3  85 66        	sta z80_l
003561  3  A9 35        	lda #>evtyp0
003563  3  85 67        	sta z80_h
003565  3               pspr4:
003565  3  B1 68        	lda (z80_ix),y
003567  3  0A           	asl a			; double accumulator.
003568  3  18           	clc
003569  3  65 66        	adc z80_l
00356B  3  85 66        	sta z80_l
00356D  3  90 02        	bcc :+
00356F  3  E6 67        	inc z80_h
003571  3               :
003571  3  B1 66        	lda (z80_hl),y
003573  3  85 64        	sta z80_e 		; copy to de.
003575  3  48           	pha
003576  3               
003576  3  E6 66        	inc z80_l 		; next byte of address.
003578  3  D0 02        	bne :+
00357A  3  E6 67        	inc z80_h
00357C  3               :
00357C  3  B1 66        	lda (z80_hl),y 		; address high.
00357E  3  85 65        	sta z80_d
003580  3               
003580  3  48           	pha	 		; swap address into hl.
003581  3  A5 67        	lda z80_h
003583  3  85 65        	sta z80_d
003585  3  68           	pla
003586  3  85 67        	sta z80_h
003588  3  68           	pla
003589  3  85 66        	sta z80_l
00358B  3  A5 66        	lda z80_l
00358D  3  85 64        	sta z80_e
00358F  3               
00358F  3  6C 66 00     	jmp (z80_hl) 		; go there.
003592  3               
003592  3               ;ogptr:	.word 0			; original sprite pointer.
003592  3               
003592  3               ; Address of each sprite type's routine.
003592  3               
003592  3  2A 3C        evtyp0:	.word evnt00
003594  3  B5 3D        evtyp1:	.word evnt01
003596  3  B6 3D        evtyp2:	.word evnt02
003598  3  B7 3D        evtyp3:	.word evnt03
00359A  3  B8 3D        evtyp4:	.word evnt04
00359C  3  B9 3D        evtyp5:	.word evnt05
00359E  3  BA 3D        evtyp6:	.word evnt06
0035A0  3  BB 3D        evtyp7:	.word evnt07
0035A2  3  BC 3D        evtyp8:	.word evnt08
0035A4  3               
0035A4  3               ;--------------------------------------------------------------
0035A4  3               ; Display sprites.
0035A4  3               ;
0035A4  3               ; Input:
0035A4  3               ;  IX = sprite table
0035A4  3               ;--------------------------------------------------------------
0035A4  3               
0035A4  3               dspr:
0035A4  3  A9 06        	lda #(NUMSPR/2)		; number of sprites to display.
0035A6  3  85 rr        	sta sprcnt
0035A8  3               dspr0:
0035A8  3  A0 00        	ldy #0
0035AA  3  B1 68        	lda (z80_ix),y 		; get sprite type.
0035AC  3  C9 FF        	cmp #255 		; is it enabled?
0035AE  3  D0 42        	bne dspr1 		; yes, it needs deleting.
0035B0  3               dspr5:
0035B0  3  A0 05        	ldy #5
0035B2  3  B1 68        	lda (z80_ix),y 		; new type.
0035B4  3  C9 FF        	cmp #255		; is it enabled?
0035B6  3  D0 76        	bne dspr3 		; yes, it needs drawing.
0035B8  3               dspr2:
0035B8  3  A0 05        	ldy #5
0035BA  3  B1 68        	lda (z80_ix),y 		; copy new type.
0035BC  3  A0 00        	ldy #0
0035BE  3  91 68        	sta (z80_ix),y
0035C0  3  A0 06        	ldy #6
0035C2  3  B1 68        	lda (z80_ix),y 		; copy new image number.
0035C4  3  A0 01        	ldy #1
0035C6  3  91 68        	sta (z80_ix),y
0035C8  3  A0 07        	ldy #7
0035CA  3  B1 68        	lda (z80_ix),y 		; copy new frame.
0035CC  3  A0 02        	ldy #2
0035CE  3  91 68        	sta (z80_ix),y
0035D0  3  A0 08        	ldy #8
0035D2  3  B1 68        	lda (z80_ix),y 		; copy new y.
0035D4  3  A0 03        	ldy #3
0035D6  3  91 68        	sta (z80_ix),y
0035D8  3  A0 09        	ldy #9
0035DA  3  B1 68        	lda (z80_ix),y 		; copy new x.
0035DC  3  A0 04        	ldy #4
0035DE  3  91 68        	sta (z80_ix),y
0035E0  3               
0035E0  3  18           	clc
0035E1  3  A5 68        	lda z80_x
0035E3  3  69 22        	adc #(TABSIZ*2)		; distance to next odd/even entry.
0035E5  3  85 68        	sta z80_x
0035E7  3  A5 69        	lda z80_i
0035E9  3  69 00        	adc #0
0035EB  3  85 69        	sta z80_i 		; next sprite.
0035ED  3  C6 rr        	dec sprcnt
0035EF  3  D0 B7        	bne dspr0		; repeat for remaining sprites.
0035F1  3  60           	rts
0035F2  3               dspr1:
0035F2  3  A0 05        	ldy #5
0035F4  3  B1 68        	lda (z80_ix),y 		; type of new sprite.
0035F6  3  C9 FF        	cmp #255		; is this enabled?
0035F8  3  D0 06        	bne dspr4 		; yes, display both.
0035FA  3               dspr6:
0035FA  3  20 05 46     	jsr sspria 		; show single sprite.
0035FD  3  4C B8 35     	jmp dspr2
003600  3               
003600  3               ; Displaying two sprites.  Don't bother redrawing if nothing has changed.
003600  3               
003600  3               dspr4:
003600  3  A0 04        	ldy #4
003602  3  B1 68        	lda (z80_ix),y		; old x.
003604  3  A0 09        	ldy #9
003606  3  D1 68        	cmp (z80_ix),y 		; compare with new value.
003608  3  D0 1E        	bne dspr7 		; they differ, need to redraw.
00360A  3               
00360A  3  A0 03        	ldy #3
00360C  3  B1 68        	lda (z80_ix),y		; old y.
00360E  3  A0 08        	ldy #8
003610  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
003612  3  D0 14        	bne dspr7		; they differ, need to redraw.
003614  3               
003614  3  A0 02        	ldy #2
003616  3  B1 68        	lda (z80_ix),y 		; old frame.
003618  3  A0 07        	ldy #7
00361A  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
00361C  3  D0 0A        	bne dspr7 		; they differ, need to redraw.
00361E  3               
00361E  3  A0 01        	ldy #1
003620  3  B1 68        	lda (z80_ix),y 		; old image.
003622  3  A0 06        	ldy #6
003624  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
003626  3  F0 90        	beq dspr2		; everything is the same, don't redraw.
003628  3               dspr7:
003628  3  20 26 46     	jsr sspric 		; delete old sprite, draw new one simultaneously.
00362B  3  4C B8 35     	jmp dspr2
00362E  3               dspr3:
00362E  3  20 20 46     	jsr ssprib 		; show single sprite.
003631  3  4C B8 35     	jmp dspr2
003634  3               
003634  3               ;sprcnt:	.byte 0
003634  3               
003634  3               ;-----------------------------------------
003634  3               ; Get sprite address calculations.
003634  3               ; gspran = new sprite, gsprad = old sprite.
003634  3               ;
003634  3               ; Input:
003634  3               ;  IX = sprite address
003634  3               ;-----------------------------------------
003634  3               
003634  3               gspran:
003634  3  A0 08        	ldy #8
003636  3  B1 68        	lda (z80_ix),y 		; new y coordinate.
003638  3  85 rr        	sta dispy
00363A  3  A0 09        	ldy #9
00363C  3  B1 68        	lda (z80_ix),y 		; new x coordinate.
00363E  3  85 rr        	sta dispx
003640  3  A0 06        	ldy #6
003642  3  B1 68        	lda (z80_ix),y 		; new sprite image.
003644  3  20 51 39     	jsr gfrm		; fetch start frame for this sprite.
003647  3               
003647  3  A0 00        	ldy #0
003649  3  B1 66        	lda (z80_hl),y 		; frame in accumulator.
00364B  3  A0 07        	ldy #7
00364D  3  18           	clc
00364E  3  71 68        	adc (z80_ix),y 		; new add frame number.
003650  3  4C 6F 36     	jmp gspra0
003653  3               
003653  3               ;-----------------------------------------
003653  3               ; Calculate old sprite address
003653  3               ;
003653  3               ; Input:
003653  3               ;  IX = sprite address
003653  3               ;
003653  3               ; Output:
003653  3               ;  B  = right byte mask
003653  3               ;  C  = left byte mask
003653  3               ;  DE = spriteframe address
003653  3               ;  scraddr = screenaddress(dispx,dispy)
003653  3               ;-----------------------------------------
003653  3               
003653  3               gsprad:
003653  3  A0 03        	ldy #3
003655  3  B1 68        	lda (z80_ix),y		; y coordinate.
003657  3  85 rr        	sta dispy
003659  3  A0 04        	ldy #4
00365B  3  B1 68        	lda (z80_ix),y		; x coordinate.
00365D  3  85 rr        	sta dispx
00365F  3  A0 01        	ldy #1
003661  3  B1 68        	lda (z80_ix),y 		; sprite image.
003663  3  20 51 39     	jsr gfrm 		; fetch start frame for this sprite.
003666  3               
003666  3               ; z80_hl = sprite framenr
003666  3               
003666  3  A0 00        	ldy #0
003668  3  B1 66        	lda (z80_hl),y 		; frame in accumulator.
00366A  3               
00366A  3               ; z80_ix+2 = current framenr
00366A  3               
00366A  3  A0 02        	ldy #2
00366C  3  18           	clc
00366D  3  71 68        	adc (z80_ix),y 		; add frame number.
00366F  3               
00366F  3               ; A = sprite framenr + current framenr
00366F  3               ;
00366F  3               ; framestart = z80_d/e = 120 * A (Normal 4 x 32 = 128)
00366F  3               ; framestart = framestart + (x AND 1) * 60
00366F  3               ; framestart = framestart + (reftable(dispy) * 20)
00366F  3               
00366F  3               gspra0:
00366F  3               
00366F  3               ; Calculate framestart = 120 * sprite image
00366F  3               
00366F  3  85 65        	sta z80_d
003671  3  85 rr        	sta tmp
003673  3  A9 00        	lda #0
003675  3  85 64        	sta z80_e
003677  3  85 rr        	sta tmp+1
003679  3               
003679  3  46 65        	lsr z80_d	; a * 128
00367B  3  66 64        	ror z80_e
00367D  3               
00367D  3  06 rr        	asl tmp		; a x 8
00367F  3  26 rr        	rol tmp+1
003681  3  06 rr        	asl tmp
003683  3  26 rr        	rol tmp+1
003685  3  06 rr        	asl tmp
003687  3  26 rr        	rol tmp+1
003689  3               
003689  3  38           	sec		; a*128 - a*8
00368A  3  A5 64        	lda z80_e
00368C  3  E5 rr        	sbc tmp
00368E  3  85 64        	sta z80_e
003690  3  A5 65        	lda z80_d
003692  3  E5 rr        	sbc tmp+1
003694  3  85 65        	sta z80_d
003696  3               
003696  3               ;.if bflag
003696  3               ;	lsr tmp1
003696  3               ;	ror tmp2
003696  3               ;	clc
003696  3               ;	lda tmp2
003696  3               ;	adc z80_e
003696  3               ;	sta z80_e
003696  3               ;	lda tmp1
003696  3               ;	adc z80_d
003696  3               ;	sta z80_d
003696  3               ;.endif
003696  3               
003696  3               ; Add spritedata address
003696  3               
003696  3  18           	clc 			; address of play sprites.
003697  3  A5 64        	lda z80_e
003699  3  69 B3        	adc #<sprgfx
00369B  3  85 64        	sta z80_e
00369D  3  A5 65        	lda z80_d
00369F  3  69 3E        	adc #>sprgfx
0036A1  3  85 65        	sta z80_d
0036A3  3               
0036A3  3               ; Check for x-shift
0036A3  3               
0036A3  3  A5 rr        	lda dispx 		; x coordinate.
0036A5  3  29 01        	and #1
0036A7  3  F0 0B        	beq chk_y_shift
0036A9  3  18           	clc			; Point to odd frame
0036AA  3  A5 64        	lda z80_e
0036AC  3  69 3C        	adc #60
0036AE  3  85 64        	sta z80_e
0036B0  3  90 02        	bcc :+
0036B2  3  E6 65        	inc z80_d
0036B4  3               :
0036B4  3               ; SCheck for y-shift
0036B4  3               
0036B4  3               chk_y_shift:
0036B4  3  A6 rr        	ldx dispy
0036B6  3  BD 4A DF     	lda V_SPR_PTR,x
0036B9  3  18           	clc
0036BA  3  65 64        	adc z80_e
0036BC  3  85 64        	sta z80_e
0036BE  3  90 02        	bcc :+
0036C0  3  E6 65        	inc z80_d
0036C2  3               :
0036C2  3               
0036C2  3               ;------------------------------------------------------------------
0036C2  3               ; Drop into screen address routine.
0036C2  3               ; This routine returns a screen address for (dispx, dispy) in scraddr.
0036C2  3               ;------------------------------------------------------------------
0036C2  3               
0036C2  3               ; Check for bottom of screen
0036C2  3               
0036C2  3               scadd:
0036C2  3  A6 rr        	ldx dispy
0036C4  3  E0 4C        	cpx #76
0036C6  3  90 02        	bcc :+
0036C8  3  A2 4C        	ldx #76
0036CA  3               :
0036CA  3               
0036CA  3  A5 rr        	lda dispx
0036CC  3  4A           	lsr a
0036CD  3  18           	clc
0036CE  3  7D 00 DC     	adc SCADTB_lb,x
0036D1  3  85 rr        	sta scraddr
0036D3  3  BD 00 DD     	lda SCADTB_hb,x
0036D6  3  69 00        	adc #0
0036D8  3  85 rr        	sta scraddr+1
0036DA  3  60           	rts
0036DB  3               
0036DB  3               spmask:
0036DB  3  FF 00        	.byte $ff,$00
0036DD  3  6A 35        	.byte $6a,$35
0036DF  3               
0036DF  3  00           tmp1:	.byte 0
0036E0  3  00           tmp2:	.byte 0
0036E1  3               
0036E1  3               
0036E1  3               ;----------------------------------------------------------------------
0036E1  3               ; Line drawn, now work out next target address.
0036E1  3               ;----------------------------------------------------------------------
0036E1  3               
0036E1  3               nline:
0036E1  3  18           	clc
0036E2  3  A5 rr        	lda scraddr 		; get low byte of address.
0036E4  3  69 28        	adc #ScrWidth
0036E6  3  85 rr        	sta scraddr 		; new low byte of address.
0036E8  3  90 02        	bcc :+
0036EA  3  E6 rr        	inc scraddr+1 		; new high byte of address.
0036EC  3               :
0036EC  3  60           	rts
0036ED  3               
0036ED  3               ;-----------------------------------------------------------
0036ED  3               ; Animates a sprite.
0036ED  3               ;
0036ED  3               ; Input:
0036ED  3               ;  IX = sprite address
0036ED  3               ;  HL = last sprite address
0036ED  3               ;-----------------------------------------------------------
0036ED  3               
0036ED  3               animsp:
0036ED  3  25 rr        	and frmno
0036EF  3  F0 01        	beq :+
0036F1  3  60           	rts
0036F2  3               :
0036F2  3  A0 06        	ldy #6
0036F4  3  B1 68        	lda (z80_ix),y		; sprite image
0036F6  3  20 51 39     	jsr gfrm		; get frame data.
0036F9  3               
0036F9  3  E6 66        	inc z80_l		; point to frames.
0036FB  3  D0 02        	bne :+
0036FD  3  E6 67        	inc z80_h
0036FF  3               :
0036FF  3  A0 07        	ldy #7
003701  3  B1 68        	lda (z80_ix),y		; sprite frame.
003703  3  18           	clc
003704  3  69 01        	adc #1			; next one along.
003706  3  A0 00        	ldy #0
003708  3  D1 66        	cmp (z80_hl),y		; reached the last frame?
00370A  3  90 02        	bcc anims0		; no, not yet.
00370C  3  A9 00        	lda #0			; start at first frame.
00370E  3               anims0:
00370E  3  A0 07        	ldy #7
003710  3  91 68        	sta (z80_ix),y		; new frame.
003712  3  60           	rts
003713  3               
003713  3               ;--------------------------------------------------------------
003713  3               ; Animate back
003713  3               ;
003713  3               ; Input:
003713  3               ;  IX = sprite address
003713  3               ;  HL = last sprite address
003713  3               ;--------------------------------------------------------------
003713  3               
003713  3               animbk:
003713  3  25 rr        	and frmno
003715  3  F0 01        	beq :+
003717  3  60           	rts
003718  3               :
003718  3  A0 06        	ldy #6
00371A  3  B1 68        	lda (z80_ix),y		; sprite image.
00371C  3  20 51 39     	jsr gfrm		; get frame data.
00371F  3               
00371F  3  E6 66        	inc z80_l 		; point to frames.
003721  3  D0 02        	bne :+
003723  3  E6 67        	inc z80_h
003725  3               :
003725  3  A0 07        	ldy #7
003727  3  B1 68        	lda (z80_ix),y 		; sprite frame.
003729  3  F0 03        	beq :+
00372B  3  4C 32 37     	jmp rtanb0 		; yes, start at end.
00372E  3               :
00372E  3  A0 00        	ldy #0
003730  3  B1 66        	lda (z80_hl),y 		; last sprite.
003732  3               rtanb0:
003732  3  38           	sec
003733  3  E9 01        	sbc #1			; next one along.
003735  3  4C 0E 37     	jmp anims0		; set new frame.
003738  3               
003738  3               ;--------------------------------------------------------------
003738  3               ; Check for collision with other sprite, strict enforcement.
003738  3               ;
003738  3               ; Input:
003738  3               ;  b		= sprite to test for
003738  3               ;  ix		= current sprite pointer
003738  3               ;
003738  3               ; global:	b
003738  3               ; local:	x,y,hl,de,skptr
003738  3               ; calls:	-
003738  3               ;--------------------------------------------------------------
003738  3               
003738  3               sktyp:
003738  3  A9 2F        	lda #<sprtab				; sprite table.
00373A  3  85 66        	sta z80_l
00373C  3  A9 3B        	lda #>sprtab
00373E  3  85 67        	sta z80_h
003740  3               numsp2:
003740  3  A9 0C        	lda #NUMSPR				; number of sprites.
003742  3  85 rr        	sta sktptr
003744  3               sktyp0:
003744  3  A5 66        	lda z80_l 				; store pointer to sprite.
003746  3  85 rr        	sta skptr
003748  3  A5 67        	lda z80_h
00374A  3  85 rr        	sta skptr+1
00374C  3               
00374C  3  A0 00        	ldy #0
00374E  3  B1 66        	lda (z80_hl),y 				; get sprite type.
003750  3  C5 63        	cmp z80_b				; is it the type we seek?
003752  3  F0 1D        	beq coltyp				; yes, we can use this one.
003754  3               sktyp1:
003754  3  18           	clc
003755  3  A5 rr        	lda skptr				; retrieve sprite pointer.
003757  3  69 11        	adc #TABSIZ				; size of each entry.
003759  3  85 66        	sta z80_l
00375B  3  A5 rr        	lda skptr+1
00375D  3  69 00        	adc #0
00375F  3  85 67        	sta z80_h
003761  3  C6 rr        	dec sktptr				; one less iteration.
003763  3  D0 DF        	bne sktyp0				; keep going until we find a slot.
003765  3  A9 00        	lda #0					; default to ROM address - no sprite.
003767  3  85 66        	sta z80_l
003769  3  85 67        	sta z80_h
00376B  3  85 rr        	sta skptr				; store pointer to sprite.
00376D  3  85 rr        	sta skptr+1
00376F  3               
00376F  3  18           	clc					; don't return with zero flag set.
003770  3  60           	rts 					; didn't find one.
003771  3               
003771  3               coltyp:
003771  3  A0 00        	ldy #0
003773  3  B1 68        	lda (z80_ix),y				; current sprite type.
003775  3  C5 63        	cmp z80_b				; seeking sprite of same type?
003777  3  F0 3D        	beq colty1				; yes, need to check we're not detecting ourselves.
003779  3               colty0:
003779  3  A0 09        	ldy #9					; distance to x position in table.
00377B  3  B1 66        	lda (z80_hl),y				; fetch x coordinate.
00377D  3  85 64        	sta z80_e
00377F  3  88           	dey
003780  3  B1 66        	lda (z80_hl),y				; fetch y coordinate.
003782  3  85 65        	sta z80_d
003784  3               
003784  3               ; Drop into collision detection.
003784  3               
003784  3               colc16:
003784  3  A0 09        	ldy #9
003786  3  B1 68        	lda (z80_ix),y			 	; x coord.
003788  3  38           	sec					; subtract x.
003789  3  E5 64        	sbc z80_e
00378B  3  B0 05        	bcs  colc1a 				; result is positive.
00378D  3  49 FF        	eor #$ff				; make negative positive.
00378F  3  18           	clc
003790  3  69 01        	adc #1
003792  3               colc1a:
003792  3  C9 08        	cmp #SPR_WID				; within x range?
003794  3  B0 BE        	bcs sktyp1				; no - they"ve missed.
003796  3  85 62        	sta z80_c				; store difference.
003798  3               
003798  3  A0 08        	ldy #8
00379A  3  B1 68        	lda (z80_ix),y				; y coord.
00379C  3  38           	sec
00379D  3  E5 65        	sbc z80_d				; subtract y.
00379F  3  B0 05        	bcs colc1b				; result is positive.
0037A1  3  49 FF        	eor #$ff				; make negative positive.
0037A3  3  18           	clc
0037A4  3  69 01        	adc #1
0037A6  3               colc1b:
0037A6  3  C9 09        	cmp #SPR_HGT				; within y range?
0037A8  3  B0 AA        	bcs sktyp1 				; no - they've missed.
0037AA  3  18           	clc					; add x difference.
0037AB  3  65 62        	adc z80_c
0037AD  3  C9 0D        	cmp #SPR_HGT+SPR_WID-4			; only 4 corner pixels touching?
0037AF  3  B0 02        	bcs :+
0037B1  3  38           	sec
0037B2  3  60           	rts 					; carry set if there's a collision.
0037B3  3               :
0037B3  3  4C 54 37     	jmp sktyp1				; try next sprite in table.
0037B6  3               colty1:
0037B6  3  A5 68        	lda z80_x  				; compare the two.
0037B8  3  C5 66        	cmp z80_l
0037BA  3  D0 09        	bne end_col
0037BC  3  A5 69        	lda z80_i
0037BE  3  C5 67        	cmp z80_h
0037C0  3  D0 03        	bne end_col
0037C2  3  4C 54 37     	jmp sktyp1 				; addresses are identical.
0037C5  3               end_col:
0037C5  3  4C 79 37     	jmp colty0
0037C8  3               
0037C8  3               ;-----------------------------------------------------------
0037C8  3               ; Display number, left aligned
0037C8  3               ;
0037C8  3               ; Input:
0037C8  3               ;  a		= number
0037C8  3               ;
0037C8  3               ; global:	-
0037C8  3               ; local:	a,y,bc,hl,displ0
0037C8  3               ; calls:	num2ch,dmsg3
0037C8  3               ;-----------------------------------------------------------
0037C8  3               
0037C8  3               disply:
0037C8  3  85 61        	sta z80_a
0037CA  3  A9 F0        	lda #<displ0				; display workspace.
0037CC  3  85 62        	sta z80_c
0037CE  3  A9 37        	lda #>displ0
0037D0  3  85 63        	sta z80_b
0037D2  3  A5 61        	lda z80_a
0037D4  3  20 4E 2C     	jsr num2ch				; convert accumulator to string.
0037D7  3               displ1:
0037D7  3  C6 62        	dec z80_c				; back one character.
0037D9  3  D0 02        	bne :+
0037DB  3  C6 63        	dec z80_b
0037DD  3               :
0037DD  3  A0 00        	ldy #0
0037DF  3  B1 62        	lda (z80_bc),y				; fetch digit.
0037E1  3  09 80        	ora #128				; insert end marker.
0037E3  3  91 62        	sta (z80_bc),y				; new value.
0037E5  3               
0037E5  3  A9 F0        	lda #<displ0				; display space.
0037E7  3  85 66        	sta z80_l
0037E9  3  A9 37        	lda #>displ0
0037EB  3  85 67        	sta z80_h
0037ED  3               
0037ED  3  4C 78 33     	jmp dmsg3				; display the string.
0037F0  3               
0037F0  3  00 00 00 8D  displ0:	.byte 0,0,0,13+128
0037F4  3               
0037F4  3               ;----------------------------------------------------------------
0037F4  3               ; Initialise screen.
0037F4  3               ;
0037F4  3               ; global:	roomtb,scno
0037F4  3               ; local:	-
0037F4  3               ; calls:	tstcs
0037F4  3               ;----------------------------------------------------------------
0037F4  3               
0037F4  3               initsc:
0037F4  3  AD 0C 3C     	lda roomtb 			; whereabouts in the map are we?
0037F7  3  20 01 38     	jsr tstsc 			; find displacement.
0037FA  3  C9 FF        	cmp #255 			; is it valid?
0037FC  3  F0 02        	beq init_end 			; no, it's rubbish.
0037FE  3  85 rr        	sta scno			; store new room number.
003800  3               init_end:
003800  3  60           	rts
003801  3               
003801  3               ;----------------------------------------------------------------
003801  3               ; Test screen.
003801  3               ;
003801  3               ; global:	-
003801  3               ; local:	x
003801  3               ; calls:	-
003801  3               ;----------------------------------------------------------------
003801  3               
003801  3               tstsc:
003801  3  85 rr        	sta tmproom
003803  3  18           	clc
003804  3  69 03        	adc #MAPWID 			; add width in case we"re negative.
003806  3  AA           	tax 				; add displacement to map data.
003807  3  BD 20 3C     	lda mapdat-MAPWID,x 		; find room number there.
00380A  3  60           	rts
00380B  3               
00380B  3               ;tmproom:	.byte 0
00380B  3               
00380B  3               ;--------------------------
00380B  3               ; Screen left.
00380B  3               ;--------------------------
00380B  3               
00380B  3               scrl:
00380B  3  AD 0C 3C     	lda roomtb 			; present room table pointer.
00380E  3  38           	sec
00380F  3  E9 01        	sbc #1				; room left.
003811  3               scrl0:
003811  3  20 01 38     	jsr tstsc			; test screen.
003814  3  C9 FF        	cmp #255			; is there a screen this way?
003816  3  D0 01        	bne :+
003818  3  60           	rts				; no, return to loop.
003819  3               :
003819  3  A5 rr        	lda tmproom			; restore room displacement.
00381B  3  8D 0C 3C     	sta roomtb			; new room table position.
00381E  3               scrl1:
00381E  3  20 F4 37     	jsr initsc 			; set new screen.
003821  3  A9 02        	lda #2
003823  3  85 rr        	sta restfl 			; set it.
003825  3  60           	rts
003826  3               scrr:
003826  3  AD 0C 3C     	lda roomtb 			; room table pointer.
003829  3  18           	clc
00382A  3  69 01        	adc #1				; room right.
00382C  3  4C 11 38     	jmp scrl0
00382F  3               scru:
00382F  3  AD 0C 3C     	lda roomtb 			; room table pointer.
003832  3  38           	sec
003833  3  E9 03        	sbc #MAPWID 			; room up.
003835  3  4C 11 38     	jmp scrl0
003838  3               scrd:
003838  3  AD 0C 3C     	lda roomtb 			; room table pointer.
00383B  3  18           	clc
00383C  3  69 03        	adc #MAPWID 			; room down.
00383E  3  4C 11 38     	jmp scrl0
003841  3               
003841  3               ;-----------------------------------------
003841  3               ; Jump to new screen.
003841  3               ;-----------------------------------------
003841  3               
003841  3               nwscr:
003841  3  A2 00        	ldx #0				; start of map data.
003843  3               nwscr0:
003843  3  DD 23 3C     	cmp mapdat,x
003846  3  F0 06        	beq nwscr1			; have we found a match for screen?
003848  3  E8           	inx 				; next room.
003849  3  E0 50        	cpx #80				; zero room count, 80 to search.
00384B  3  D0 F6        	bne nwscr0			; keep looking.
00384D  3  60           	rts
00384E  3               nwscr1:
00384E  3  8E 0C 3C     	stx roomtb			; set the map position.
003851  3  4C 1E 38     	jmp scrl1			; draw new room.
003854  3               
003854  3               
003854  3               ;----------------------------------------------------------
003854  3               ; Gravity processing.
003854  3               ;----------------------------------------------------------
003854  3               
003854  3               grav:
003854  3  A0 0D        	ldy #13
003856  3  B1 68        	lda (z80_ix),y			; jump pointer low.
003858  3  85 66        	sta z80_l
00385A  3  A0 0E        	ldy #14
00385C  3  B1 68        	lda (z80_ix),y			; jump pointer high.
00385E  3  85 67        	sta z80_h
003860  3  05 66        	ora z80_l			; merge in low byte.
003862  3  D0 01        	bne :+
003864  3  60           	rts				; if neither is set, we're not in the air.
003865  3               :
003865  3  A0 00        	ldy #0
003867  3  B1 66        	lda (z80_hl),y			; pixels to move.
003869  3  85 61        	sta z80_a
00386B  3  C9 63        	cmp #99				; reached the end?
00386D  3  D0 0C        	bne grav0			; no, continue.
00386F  3               grav2:
00386F  3  C6 66        	dec z80_l			; go back to previous value.
003871  3  C9 FF        	cmp #$ff
003873  3  D0 02        	bne :+
003875  3  C6 67        	dec z80_h
003877  3               :
003877  3  B1 66        	lda (z80_hl),y			; fetch that from table.
003879  3  85 61        	sta z80_a
00387B  3               grav0:
00387B  3  E6 66        	inc z80_l			; point to next table entry.
00387D  3  D0 02        	bne :+
00387F  3  E6 67        	inc z80_h
003881  3               :
003881  3  A5 66        	lda z80_l
003883  3  A0 0D        	ldy #13
003885  3  91 68        	sta (z80_ix),y			; store new pointer low.
003887  3  A5 67        	lda z80_h
003889  3  A0 0E        	ldy #14
00388B  3  91 68        	sta (z80_ix),y			; store new pointer high.
00388D  3               grav1:
00388D  3  A5 61        	lda z80_a
00388F  3  D0 01        	bne :+				; any movement required?
003891  3  60           	rts				; no, not this time.
003892  3               :
003892  3  A5 61        	lda z80_a
003894  3  C9 80        	cmp #128			; is it up or down?
003896  3  B0 15        	bcs gravu			; it's up.
003898  3               gravd:
003898  3  85 63        	sta z80_b			; set pixels to move.
00389A  3               gravd0:
00389A  3  20 B7 31     	jsr cangd			; can we go down?
00389D  3  D0 28        	bne gravst			; can't move down, so stop.
00389F  3  A0 08        	ldy #8
0038A1  3  B1 68        	lda (z80_ix),y			; adjust new x coord.
0038A3  3  18           	clc
0038A4  3  69 01        	adc #1
0038A6  3  91 68        	sta (z80_ix),y
0038A8  3  C6 63        	dec z80_b
0038AA  3  D0 EE        	bne gravd0
0038AC  3  60           	rts
0038AD  3               gravu:
0038AD  3  49 FF        	eor #$ff			; flip the sign so it's positive.
0038AF  3  18           	clc
0038B0  3  69 01        	adc #1
0038B2  3  85 63        	sta z80_b			; set pixels to move.
0038B4  3               gravu0:
0038B4  3  20 6A 31     	jsr cangu			; can we go up?
0038B7  3  D0 6E        	bne ifalls			; can't move up, go down next.
0038B9  3  A0 08        	ldy #8
0038BB  3  B1 68        	lda (z80_ix),y
0038BD  3  38           	sec
0038BE  3  E9 01        	sbc #1
0038C0  3  91 68        	sta (z80_ix),y			; adjust new x coord.
0038C2  3  C6 63        	dec z80_b
0038C4  3  D0 EE        	bne gravu0
0038C6  3  60           	rts
0038C7  3               gravst:
0038C7  3  A0 0D        	ldy #13
0038C9  3  B1 68        	lda (z80_ix),y			; jump pointer low.
0038CB  3  85 66        	sta z80_l
0038CD  3  A0 0E        	ldy #14
0038CF  3  B1 68        	lda (z80_ix),y			; jump pointer high.
0038D1  3  85 67        	sta z80_h
0038D3  3               
0038D3  3  A9 00        	lda #0				; null value in pointer.
0038D5  3  A0 0D        	ldy #13
0038D7  3  91 68        	sta (z80_ix),y			; store new pointer low.
0038D9  3  C8           	iny
0038DA  3  91 68        	sta (z80_ix),y			; store new pointer high.
0038DC  3               
0038DC  3  A0 00        	ldy #0
0038DE  3  B1 66        	lda (z80_hl),y			; fetch byte from table.
0038E0  3  C9 63        	cmp #99				; is it the end marker?
0038E2  3               evftf:
0038E2  3  F0 01        	beq :+				; yes, fallen too far.
0038E4  3  60           	rts
0038E5  3               :
0038E5  3  4C ED 3D     	jmp evnt15			; EVENT FELLTOOFAR
0038E8  3               
0038E8  3               ;------------------------------------------------
0038E8  3               ; Initiate fall check.
0038E8  3               ;------------------------------------------------
0038E8  3               
0038E8  3               ifall:
0038E8  3  A0 0D        	ldy #13
0038EA  3  B1 68        	lda (z80_ix),y 			; jump pointer low.
0038EC  3  85 66        	sta z80_l
0038EE  3  A0 0E        	ldy #14
0038F0  3  B1 68        	lda (z80_ix),y 			; jump pointer high.
0038F2  3  85 67        	sta z80_h			; high byte in accumulator.
0038F4  3  05 66        	ora z80_l			; merge in low byte.
0038F6  3  F0 01        	beq :+
0038F8  3  60           	rts				; if either is set, we're already in the air.
0038F9  3               :
0038F9  3  A0 09        	ldy #9
0038FB  3  B1 68        	lda (z80_ix),y			; y coordinate.
0038FD  3  85 rr        	sta dispx
0038FF  3  A0 08        	ldy #8
003901  3  B1 68        	lda (z80_ix),y			; look x coordinate.
003903  3  18           	clc
003904  3               numsp7:
003904  3  69 09        	adc #SPR_HGT			; add 16 pixels.
003906  3  85 rr        	sta dispy			; set up test coordinates.
003908  3  20 EA 32     	jsr tstbl			; get map address.
00390B  3  20 62 32     	jsr plchk			; block, platform check.
00390E  3  F0 01        	beq :+
003910  3  60           	rts				; it's solid, don't fall.
003911  3               :
003911  3  E6 rr        	inc bufaddr			; look right one cell.
003913  3  20 62 32     	jsr plchk			; block, platform check.
003916  3  F0 01        	beq :+
003918  3  60           	rts				; it's solid, don't fall.
003919  3               :
003919  3  A5 rr        	lda dispx			; y coordinate.
00391B  3  29 07        	and #7				; position straddling block cells.
00391D  3  F0 08        	beq ifalls			; no more checks needed.
00391F  3  E6 rr        	inc bufaddr			; look to third cell.
003921  3  20 62 32     	jsr plchk			; block, platform check.
003924  3  F0 01        	beq :+
003926  3  60           	rts				; it's solid, don't fall.
003927  3               :
003927  3               ifalls:
003927  3  A9 9C        	lda #<jtab			; jump table start.
003929  3  85 66        	sta z80_l
00392B  3  A9 44        	lda #>jtab
00392D  3  85 67        	sta z80_h
00392F  3               ifal0:
00392F  3  E6 66        	inc z80_l			; point to next value.
003931  3  D0 02        	bne :+
003933  3  E6 67        	inc z80_h
003935  3               :
003935  3  A0 00        	ldy #0
003937  3  B1 66        	lda (z80_hl),y			; fetch value.
003939  3  F0 F4        	beq ifal0			; no, get next value.
00393B  3  C9 63        	cmp #99				; reached end of table?
00393D  3  D0 01        	bne :+
00393F  3  60           	rts				; yes, don't fall.
003940  3               :
003940  3  C9 80        	cmp #128			; is it going up?
003942  3  B0 EB        	bcs ifal0			; yes, looking for first movement down.
003944  3               
003944  3  A0 0D        	ldy #13
003946  3  A5 66        	lda z80_l
003948  3  91 68        	sta (z80_ix),y 			; set jump low.
00394A  3  A0 0E        	ldy #14
00394C  3  A5 67        	lda z80_h
00394E  3  91 68        	sta (z80_ix),y 			; set jump high.
003950  3  60           	rts
003951  3               
003951  3               
003951  3               ;----------------------------------------------------
003951  3               ; Get frame data for a particular sprite.
003951  3               ; Input:
003951  3               ;  a		= framenumer
003951  3               ; Output:
003951  3               ;  hl		= frame address
003951  3               ;
003951  3               ; global:	hl,frmptr
003951  3               ; local:	-
003951  3               ; calls:	-
003951  3               ;----------------------------------------------------
003951  3               
003951  3               gfrm:
003951  3  0A           	asl a	 		 	; multiple of 2.
003952  3  18           	clc
003953  3  6D 17 28     	adc frmptr 			; frames used by game.
003956  3  85 66        	sta z80_l
003958  3  AD 18 28     	lda frmptr+1
00395B  3  69 00        	adc #0
00395D  3  85 67        	sta z80_h 			; point to frame start.
00395F  3  60           	rts
003960  3               
003960  3               ;----------------------------------------------------
003960  3               ; Find sprite list for current room.
003960  3               ;
003960  3               ; global:	hl
003960  3               ; local:	x,y
003960  3               ; calls:	-
003960  3               ;----------------------------------------------------
003960  3               
003960  3               sprlst:
003960  3  A9 07        	lda #<nmedat 			; list of enemy sprites.
003962  3  85 66        	sta z80_l
003964  3  A9 41        	lda #>nmedat
003966  3  85 67        	sta z80_h
003968  3  A6 rr        	ldx scno 			; screen number.
00396A  3  D0 01        	bne sprls2 			; is it the first screen?
00396C  3  60           	rts 				; yes, don't need to search data.
00396D  3               sprls2:
00396D  3  A0 00        	ldy #0
00396F  3               sprls1:
00396F  3  B1 66        	lda (z80_hl),y 			; fetch type of sprite.
003971  3  C9 FF        	cmp #255			; is it an end marker?
003973  3  F0 0E        	beq sprls0 			; yes, end of this room.
003975  3               
003975  3  18           	clc 				; point to next sprite in list.
003976  3  A5 66        	lda z80_l
003978  3  69 04        	adc #NMESIZ
00397A  3  85 66        	sta z80_l
00397C  3  90 02        	bcc :+
00397E  3  E6 67        	inc z80_h
003980  3               :
003980  3  4C 6F 39     	jmp sprls1 			; continue until end of room.
003983  3               sprls0:
003983  3  E6 66        	inc z80_l 			; point to start of next screen.s
003985  3  D0 02        	bne :+
003987  3  E6 67        	inc z80_h
003989  3               :
003989  3  CA           	dex
00398A  3  D0 E3        	bne sprls1 			; continue until room found.
00398C  3  60           	rts
00398D  3               
00398D  3               
00398D  3               ;----------------------------------------------------
00398D  3               ; Clear all but a single player sprite.
00398D  3               ;
00398D  3               ; global:	-
00398D  3               ; local:	x,y,ix
00398D  3               ; calls:	-
00398D  3               ;----------------------------------------------------
00398D  3               
00398D  3               nspr:
00398D  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
00398F  3  85 rr        	sta sprcnt
003991  3  A9 2F        	lda #<sprtab 			; sprite table.
003993  3  85 68        	sta z80_x
003995  3  A9 3B        	lda #>sprtab
003997  3  85 69        	sta z80_i
003999  3               nspr0:
003999  3  A0 00        	ldy #0 				; fetch sprite type.
00399B  3  B1 68        	lda (z80_ix),y 			; is it a player?
00399D  3  F0 1A        	beq nspr1 			; yes, keep this one.
00399F  3               
00399F  3  A9 FF        	lda #255
0039A1  3  A0 00        	ldy #0 				; fetch sprite type.
0039A3  3  91 68        	sta (z80_ix),y 			; delete sprite.
0039A5  3  A0 05        	ldy #5
0039A7  3  91 68        	sta (z80_ix),y 			; remove next type.
0039A9  3               
0039A9  3  18           	clc	 			; next sprite.
0039AA  3  A5 68        	lda z80_x
0039AC  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0039AE  3  85 68        	sta z80_x
0039B0  3  90 02        	bcc :+
0039B2  3  E6 69        	inc z80_i
0039B4  3               :
0039B4  3  C6 rr        	dec sprcnt	 			; one less space in the table.
0039B6  3  D0 E1        	bne nspr0
0039B8  3  60           	rts
0039B9  3               nspr1:
0039B9  3  A9 FF        	lda #255
0039BB  3  A0 00        	ldy #0
0039BD  3  91 68        	sta (z80_ix),y 			; delete sprite.
0039BF  3               
0039BF  3  18           	clc	 			; point to next sprite.
0039C0  3  A5 68        	lda z80_x
0039C2  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0039C4  3  85 68        	sta z80_x
0039C6  3  90 02        	bcc :+
0039C8  3  E6 69        	inc z80_i
0039CA  3               :
0039CA  3  C6 rr        	dec sprcnt	 			; one less to do.
0039CC  3  D0 01        	bne nspr2
0039CE  3  60           	rts
0039CF  3               nspr2:
0039CF  3  A9 FF        	lda #255
0039D1  3  A0 00        	ldy #0
0039D3  3  91 68        	sta (z80_ix),y 			; delete sprite.
0039D5  3  A0 05        	ldy #5
0039D7  3  91 68        	sta (z80_ix),y 			; remove next type.
0039D9  3               
0039D9  3  18           	clc	 			; next sprite.
0039DA  3  A5 68        	lda z80_x
0039DC  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0039DE  3  85 68        	sta z80_x
0039E0  3  90 02        	bcc :+
0039E2  3  E6 69        	inc z80_i
0039E4  3               :
0039E4  3  C6 rr        	dec sprcnt	 			; one less space in table.
0039E6  3  D0 E7        	bne nspr2
0039E8  3  60           	rts
0039E9  3               
0039E9  3               ;----------------------------------------------------------
0039E9  3               ; Two initialisation routines.
0039E9  3               ; Initialise sprites - copy everything from list to table.
0039E9  3               ;
0039E9  3               ; global:	-
0039E9  3               ; local:	x,y,ix
0039E9  3               ; calls:	cpsp
0039E9  3               ;----------------------------------------------------------
0039E9  3               
0039E9  3               ispr:
0039E9  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
0039EB  3  85 rr        	sta sprcnt
0039ED  3  A9 2F        	lda #<sprtab			; sprite table.
0039EF  3  85 68        	sta z80_x
0039F1  3  A9 3B        	lda #>sprtab
0039F3  3  85 69        	sta z80_i
0039F5  3               ispr2:
0039F5  3  A0 00        	ldy #0
0039F7  3  B1 66        	lda (z80_hl),y 			; fetch byte.
0039F9  3  C9 FF        	cmp #255 			; is it an end marker?
0039FB  3  D0 01        	bne :+
0039FD  3  60           	rts 				; yes, no more to do.
0039FE  3               :
0039FE  3               ispr1:
0039FE  3  A0 00        	ldy #0
003A00  3  B1 68        	lda (z80_ix),y 			; fetch sprite type.
003A02  3  C9 FF        	cmp #255 			; is it enabled yet?
003A04  3  D0 08        	bne ispr4			; yes, try another slot.
003A06  3               
003A06  3  A0 05        	ldy #5
003A08  3  B1 68        	lda (z80_ix),y		 	; next type.
003A0A  3  C9 FF        	cmp #255 			; is it enabled yet?
003A0C  3  F0 10        	beq ispr3 			; no, process this one.
003A0E  3               ispr4:
003A0E  3  18           	clc 				; next sprite.
003A0F  3  A5 68        	lda z80_x
003A11  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
003A13  3  85 68        	sta z80_x
003A15  3  90 02        	bcc :+
003A17  3  E6 69        	inc z80_i
003A19  3               :
003A19  3  C6 rr        	dec sprcnt
003A1B  3  D0 E1        	bne ispr1 			; repeat for remaining sprites.
003A1D  3  60           	rts  				; no more room in table.
003A1E  3               ispr3:
003A1E  3  20 71 3A     	jsr cpsp			; initialise a sprite.
003A21  3  C6 rr        	dec sprcnt			; one less space in the table.
003A23  3  D0 D0        	bne ispr2
003A25  3  60           	rts
003A26  3               
003A26  3               
003A26  3               ;-----------------------------------------------------------------------
003A26  3               ; Initialise sprites - but not player, we're keeping the old one.
003A26  3               ;
003A26  3               ; global:	-
003A26  3               ; local:	x,y,ix
003A26  3               ; calls:	cpsp
003A26  3               ;-----------------------------------------------------------------------
003A26  3               
003A26  3               kspr:
003A26  3  A2 0C        	ldx #NUMSPR			; sprite slots in table.
003A28  3  A9 2F        	lda #<sprtab 			; sprite table.
003A2A  3  85 68        	sta z80_x
003A2C  3  A9 3B        	lda #>sprtab
003A2E  3  85 69        	sta z80_i
003A30  3               kspr2:
003A30  3  A0 00        	ldy #0
003A32  3  B1 66        	lda (z80_hl),y 			; fetch byte.
003A34  3  C9 FF        	cmp #255 			; is it an end marker?
003A36  3  D0 01        	bne :+
003A38  3  60           	rts 				; yes, no more to do.
003A39  3               :
003A39  3  C9 00        	cmp #0
003A3B  3  D0 0E        	bne kspr1 			; no, add to table as normal.
003A3D  3               
003A3D  3  18           	clc 				; next sprite.
003A3E  3  A5 66        	lda z80_l
003A40  3  69 04        	adc #NMESIZ		 	; distance to next odd/even entry.
003A42  3  85 66        	sta z80_l
003A44  3  90 02        	bcc :+
003A46  3  E6 67        	inc z80_h
003A48  3               :
003A48  3  4C 30 3A     	jmp kspr2
003A4B  3               kspr1:
003A4B  3  A0 00        	ldy #0 				; fetch sprite type.
003A4D  3  B1 68        	lda (z80_ix),y
003A4F  3  C9 FF        	cmp #255 			; is it enabled yet?
003A51  3  D0 08        	bne kspr4 			; yes, try another slot.
003A53  3               
003A53  3  A0 05        	ldy #5 				; next type.
003A55  3  B1 68        	lda (z80_ix),y
003A57  3  C9 FF        	cmp #255 			; is it enabled yet?
003A59  3  F0 0F        	beq kspr3 			; no, process this one.
003A5B  3               kspr4:
003A5B  3  18           	clc 				; next sprite.
003A5C  3  A5 68        	lda z80_x
003A5E  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
003A60  3  85 68        	sta z80_x
003A62  3  90 02        	bcc :+
003A64  3  E6 69        	inc z80_i
003A66  3               :
003A66  3  CA           	dex	 			; repeat for remaining sprites.
003A67  3  D0 E2        	bne kspr1
003A69  3  60           	rts  				; no more room in table.
003A6A  3               kspr3:
003A6A  3  20 71 3A     	jsr cpsp 			; copy sprite to table.
003A6D  3  CA           	dex	 			; one less space in the table.
003A6E  3  D0 C0        	bne kspr2
003A70  3  60           	rts
003A71  3               
003A71  3               ;----------------------------------------------
003A71  3               ; Copy sprite from list to table.
003A71  3               ;
003A71  3               ; global:	hl,ix
003A71  3               ; local:	y
003A71  3               ; calls:	evnt09
003A71  3               ;----------------------------------------------
003A71  3               
003A71  3               cpsp:
003A71  3  A0 00        	ldy #0				; fetch byte from table.
003A73  3  B1 66        	lda (z80_hl),y
003A75  3  91 68        	sta (z80_ix),y			; set up type.
003A77  3  A0 05        	ldy #PAM1ST
003A79  3  91 68        	sta (z80_ix),y 			; set up type.
003A7B  3               
003A7B  3  E6 66        	inc z80_l 			; move to next byte.
003A7D  3  D0 02        	bne :+
003A7F  3  E6 67        	inc z80_h
003A81  3               :
003A81  3  A0 00        	ldy #0 				; fetch byte from table.
003A83  3  B1 66        	lda (z80_hl),y
003A85  3  A0 06        	ldy #6
003A87  3  91 68        	sta (z80_ix),y			; set up image.
003A89  3               
003A89  3  E6 66        	inc z80_l 			; move to next byte.
003A8B  3  D0 02        	bne :+
003A8D  3  E6 67        	inc z80_h
003A8F  3               :
003A8F  3  A0 00        	ldy #0
003A91  3  B1 66        	lda (z80_hl),y 			; fetch byte from table.
003A93  3  A0 08        	ldy #8
003A95  3  91 68        	sta (z80_ix),y 			; set up coordinate.
003A97  3               
003A97  3  A9 C8        	lda #200 			; set initial coordinate off screen.
003A99  3  A0 03        	ldy #3
003A9B  3  91 68        	sta (z80_ix),y
003A9D  3               
003A9D  3  E6 66        	inc z80_l 			; move to next byte.
003A9F  3  D0 02        	bne :+
003AA1  3  E6 67        	inc z80_h
003AA3  3               :
003AA3  3  A0 00        	ldy #0 				; fetch byte from table.
003AA5  3  B1 66        	lda (z80_hl),y
003AA7  3  A0 09        	ldy #9
003AA9  3  91 68        	sta (z80_ix),y 			; set up coordinate.
003AAB  3               
003AAB  3  E6 66        	inc z80_l 			; move to next byte.
003AAD  3  D0 02        	bne :+
003AAF  3  E6 67        	inc z80_h
003AB1  3               :
003AB1  3  A9 00        	lda #0				; zeroes in accumulator.
003AB3  3  A0 07        	ldy #7 				; reset frame number.
003AB5  3  91 68        	sta (z80_ix),y
003AB7  3  A0 0A        	ldy #10 			; reset direction.
003AB9  3  91 68        	sta (z80_ix),y
003ABB  3  A0 0D        	ldy #13				; reset jump pointer low.
003ABD  3  91 68        	sta (z80_ix),y
003ABF  3  A0 0E        	ldy #14	 			; reset jump pointer high.
003AC1  3  91 68        	sta (z80_ix),y
003AC3  3               
003AC3  3  A9 FF        	lda #255 			; reset data pointer to auto-restore.
003AC5  3  A0 10        	ldy #16
003AC7  3  91 68        	sta (z80_ix),y
003AC9  3               evis0:
003AC9  3  A5 69        	lda z80_i
003ACB  3  48           	pha
003ACC  3  A5 68        	lda z80_x
003ACE  3  48           	pha
003ACF  3  A5 67        	lda z80_h
003AD1  3  48           	pha
003AD2  3  A5 66        	lda z80_l
003AD4  3  48           	pha
003AD5  3               
003AD5  3  20 BD 3D     	jsr evnt09 			; perform event.
003AD8  3               
003AD8  3  68           	pla
003AD9  3  85 66        	sta z80_l
003ADB  3  68           	pla
003ADC  3  85 67        	sta z80_h
003ADE  3  68           	pla
003ADF  3  85 68        	sta z80_x
003AE1  3  68           	pla
003AE2  3  85 69        	sta z80_i
003AE4  3               
003AE4  3  18           	clc
003AE5  3  A5 68        	lda z80_x 			; distance to next odd/even entry.
003AE7  3  69 11        	adc #TABSIZ		 	; next sprite.
003AE9  3  85 68        	sta z80_x
003AEB  3  90 02        	bcc :+
003AED  3  E6 69        	inc z80_i
003AEF  3               :
003AEF  3  60           	rts
003AF0  3               
003AF0  3               
003AF0  3               ;-------------------------------------
003AF0  3               ; Clear the play area window.
003AF0  3               ;-------------------------------------
003AF0  3               
003AF0  3               clw:
003AF0  3  AD 1F 28     	lda wintop			; get coordinates of window.
003AF3  3  85 rr        	sta dispy			; put into dispx for calculation.
003AF5  3  AD 20 28     	lda winlft
003AF8  3  85 rr        	sta dispx
003AFA  3               
003AFA  3  AD 21 28     	lda winhgt			; height of window.
003AFD  3  85 rr        	sta rrow			; copy to b register.
003AFF  3               clw3:
003AFF  3  AD 22 28     	lda winwid 			; width of window.
003B02  3  85 rr        	sta rcol
003B04  3               clw2:
003B04  3  20 17 30     	jsr gprad 			; get print address.
003B07  3  A9 00        	lda #0				; zero byte to write.
003B09  3  A2 07        	ldx #7				; pixel height of each cell.
003B0B  3               clw1:
003B0B  3  BC 51 30     	ldy scrtab,x
003B0E  3  91 rr        	sta (scraddr),y 			; copy to screen.
003B10  3  CA           	dex				; next screen row down.
003B11  3  10 F8        	bpl clw1
003B13  3               
003B13  3  E6 rr        	inc dispx			; next column.
003B15  3  C6 rr        	dec rcol			; one less to do.
003B17  3  D0 EB        	bne clw2			; repeat for remaining columns.
003B19  3               
003B19  3  AD 20 28     	lda winlft			; get left edge.
003B1C  3  85 rr        	sta dispx 			; reset x.
003B1E  3  E6 rr        	inc dispy 			; next line down.
003B20  3               
003B20  3  C6 rr        	dec rrow
003B22  3  D0 DB        	bne clw3			; repeat down the screen.
003B24  3               
003B24  3  AD 1F 28     	lda wintop			; get coordinates of window.
003B27  3  85 rr        	sta chary			; put into display position.
003B29  3  AD 20 28     	lda winlft
003B2C  3  85 rr        	sta charx
003B2E  3  60           	rts
003B2F  3               
003B2F  3               
003B2F  3               ;----------------------------------------------------------
003B2F  3               ; Effects code.
003B2F  3               ; Ticker routine is called 25 times per second.
003B2F  3               ;
003B2F  3               ; HL = txtscr = left text screen address
003B2F  3               ; DE = txtscr+txtwid-1 = right text screen address
003B2F  3               ; BC = txtpos = text scroller position
003B2F  3               ;
003B2F  3               ;----------------------------------------------------------
003B2F  3               
003B2F  3               .if sflag
003B2F  3               scrly:
003B2F  3               	rts
003B2F  3               	.word txtscr         	; get left screen address.
003B2F  3               	sta scr_l
003B2F  3               	lda txtscr+1
003B2F  3               	sta scr_l+1
003B2F  3               	sta scr_r+1
003B2F  3               
003B2F  3               	stx xtmp
003B2F  3               
003B2F  3               	clc         		; get right screen address.
003B2F  3               	lda scr_l
003B2F  3               	adc txtwid
003B2F  3               	sta scr_r
003B2F  3               	dec scr_r
003B2F  3               scrly1:
003B2F  3               	ldy txtwid		; set txtwide
003B2F  3               	dey
003B2F  3               	clc
003B2F  3               scrly0:
003B2F  3               	lda (scr_l),y		; scroll 1 line
003B2F  3               	rol a
003B2F  3               	sta (scr_l),y
003B2F  3               	dey
003B2F  3               	bpl scrly0
003B2F  3               
003B2F  3               	clc			; point to next line
003B2F  3               	lda scr_l
003B2F  3               	adc #32
003B2F  3               	sta scr_l
003B2F  3               	bcc scrly1		; repeat 8 times
003B2F  3               
003B2F  3               	lda txtpos 		; get text pointer.
003B2F  3               	sta scr_txt
003B2F  3               	lda txtpos+1
003B2F  3               	sta scr_txt+1
003B2F  3               
003B2F  3               	ldy #0
003B2F  3               	lda (scr_txt),y 		; find character we're displaying.
003B2F  3               	and #127 		; remove end marker bit if applicable.
003B2F  3               	cmp #13			; is it newline?
003B2F  3               	bne scrly5 		; no, it's okay.
003B2F  3               	lda #32			; convert to a space instead.
003B2F  3               scrly5:
003B2F  3               	sta fntaddr		; calculate char address
003B2F  3               	lda #0
003B2F  3               	sta fntaddr+1
003B2F  3               	asl fntaddr  		; multiply char by 8.
003B2F  3               	rol fntaddr+1
003B2F  3               	asl fntaddr
003B2F  3               	rol fntaddr+1
003B2F  3               	asl fntaddr
003B2F  3               	rol fntaddr+1
003B2F  3               	lda fntaddr
003B2F  3               	clc
003B2F  3               	adc #<(FONT-256)
003B2F  3               	sta scrly3+1		; that's the low byte.
003B2F  3               	lda fntaddr+1
003B2F  3               	adc #>(FONT-256)
003B2F  3               	sta scrly3+2		; add displacement.
003B2F  3               
003B2F  3               	ldx #0
003B2F  3               scrly3:
003B2F  3               	lda $3333,x		; get image of char line.
003B2F  3               	and txtbit
003B2F  3               	beq scrly2		; don't plot pixel
003B2F  3               	ldy scrline,x
003B2F  3               	lda (scr_r),y
003B2F  3               	clc
003B2F  3               	ora #1
003B2F  3               	sta (scr_r),y		; plot pixel
003B2F  3               scrly2:
003B2F  3               	inx			; next line of char.
003B2F  3               	cpx #8
003B2F  3               	bne scrly3
003B2F  3               
003B2F  3               	lsr txtbit		; bit of text to display.
003B2F  3               	bcs :+
003B2F  3               	rts
003B2F  3               :
003B2F  3               	ldy #0
003B2F  3               	lda (scr_txt),y 	; what was the character?
003B2F  3               	asl a	  		; end of message?
003B2F  3               	bcs scrly4
003B2F  3               	inc txtpos
003B2F  3               	bne :+
003B2F  3               	inc txtpos+1
003B2F  3               :
003B2F  3               	jmp scrly6 		; not yet - continue.
003B2F  3               scrly4:
003B2F  3               	lda txtini 		; start of scrolling message.
003B2F  3               	sta txtpos
003B2F  3               	lda txtini+1
003B2F  3               	sta txtpos+1
003B2F  3               scrly6:
003B2F  3               	lda #128
003B2F  3               	sta txtbit
003B2F  3               	ldx xtmp
003B2F  3               	rts
003B2F  3               
003B2F  3               scrline:	.byte $00,$20,$40,$60,$80,$a0,$c0,$e0
003B2F  3               
003B2F  3               ;-------------------------------------------------------
003B2F  3               ; Entry TICKER command
003B2F  3               ;
003B2F  3               ; Entry:
003B2F  3               ;  z80_b = message nr
003B2F  3               ;  z80_c = width
003B2F  3               ;-------------------------------------------------------
003B2F  3               
003B2F  3               iscrly:
003B2F  3               	jsr prescr 		; set up display position.
003B2F  3               
003B2F  3               	lda #<msgdat 		; text messages.
003B2F  3               	sta z80_l
003B2F  3               	lda #>msgdat
003B2F  3               	sta z80_h
003B2F  3               
003B2F  3               	lda z80_c 		; width.
003B2F  3               	sec
003B2F  3               	sbc #1			; subtract one.
003B2F  3               	cmp #32 		; is it between 1 and 32?
003B2F  3               	bcc :+
003B2F  3               	lda #$60
003B2F  3               	jmp iscrl0		; no, disable messages.
003B2F  3               :
003B2F  3               	ldx z80_b		; message number.
003B2F  3               	jsr getwrd 		; find message start.
003B2F  3               
003B2F  3               	lda z80_l		; set initial text position.
003B2F  3               	sta txtini
003B2F  3               	lda z80_h
003B2F  3               	sta txtini+1
003B2F  3               
003B2F  3               	lda #$ad		; code for lda adrr
003B2F  3               iscrl0:
003B2F  3               	sta scrly		; enable/disable scrolling routine.
003B2F  3               
003B2F  3               	jsr prescr 		; set up display position.
003B2F  3               	jsr gprad 		; get print address.
003B2F  3               
003B2F  3               	lda scraddr 		; set text screen address.
003B2F  3               	sta txtscr
003B2F  3               	lda scraddr+1
003B2F  3               	sta txtscr+1
003B2F  3               
003B2F  3               	lda z80_c		; width.
003B2F  3               	sta txtwid		; set width in working storage.
003B2F  3               
003B2F  3               	lda #128 		; start with leftmost bit.
003B2F  3               	sta txtbit
003B2F  3               
003B2F  3               	jmp scrly4
003B2F  3               .endif
003B2F  3               
003B2F  3               ;------------------------------------------------------------------
003B2F  3               ; Dig routine, conditional assembly depending on dflag
003B2F  3               ;------------------------------------------------------------------
003B2F  3               .if dflag
003B2F  3               dig:
003B2F  3               	and #3
003B2F  3               	beq digr		; dig right
003B2F  3               	cmp #1
003B2F  3               	beq digl		; dig left
003B2F  3               	cmp #2
003B2F  3               	beq digd		; dig down
003B2F  3               
003B2F  3               ; Dig up.
003B2F  3               
003B2F  3               digu:				; dig up
003B2F  3               	ldy #8
003B2F  3               	lda (z80_ix),y
003B2F  3               	sec
003B2F  3               	sbc #2
003B2F  3               	sta dispy		; set y
003B2F  3               
003B2F  3               	iny
003B2F  3               	lda (z80_ix),y
003B2F  3               	sta dispx		; set x
003B2F  3               	jmp digv
003B2F  3               
003B2F  3               ; Dig down.
003B2F  3               
003B2F  3               digd:
003B2F  3               	ldy #9
003B2F  3               	lda (z80_ix),y
003B2F  3               	sta dispx		; set x
003B2F  3               
003B2F  3               	dey
003B2F  3               	clc
003B2F  3               	lda (z80_ix),y
003B2F  3               	adc #SPR_HGT
003B2F  3               	sta dispy		; set y
003B2F  3               	jmp digv
003B2F  3               
003B2F  3               ; Dig left.
003B2F  3               
003B2F  3               digl:
003B2F  3               	ldy #8
003B2F  3               	lda (z80_ix),y
003B2F  3               	sta dispy		; set y
003B2F  3               
003B2F  3               	iny
003B2F  3               	lda (z80_ix),y
003B2F  3               	sec
003B2F  3               	sbc #2			; x=x-2
003B2F  3               	sta dispx		; set x
003B2F  3               	jmp digh
003B2F  3               
003B2F  3               ; Dig right.
003B2F  3               
003B2F  3               digr:
003B2F  3               	ldy #8
003B2F  3               	lda (z80_ix),y
003B2F  3               	sta dispy		; set y
003B2F  3               
003B2F  3               	iny
003B2F  3               	lda (z80_ix),y
003B2F  3               	clc
003B2F  3               	adc #SPR_WID
003B2F  3               	sta dispx		; set x+16
003B2F  3               	jmp digh
003B2F  3               
003B2F  3               ; Vertical digging
003B2F  3               
003B2F  3               digv:
003B2F  3               	jsr tstbl		; check blocktype in MAP
003B2F  3               	jsr fdchk		; remove if FODDER
003B2F  3               
003B2F  3               	inc dispx
003B2F  3               	inc dispx
003B2F  3               	jsr tstbl		; check blocktype in MAP
003B2F  3               	jsr fdchk		; remove if FODDER
003B2F  3               
003B2F  3               	inc dispx
003B2F  3               	inc dispx
003B2F  3               	jsr tstbl		; check blocktype in MAP
003B2F  3               	jsr fdchk		; remove if FODDER
003B2F  3               
003B2F  3               	inc dispx
003B2F  3               	inc dispx
003B2F  3               	jsr tstbl		; check blocktype in MAP
003B2F  3               	jsr fdchk		; remove if FODDER
003B2F  3               
003B2F  3               	lda dispx
003B2F  3               	and #1
003B2F  3               	bne :+
003B2F  3               	rts
003B2F  3               :
003B2F  3               	inc dispx
003B2F  3               	inc dispx
003B2F  3               	jsr tstbl		; check blocktype in MAP
003B2F  3               	jmp fdchk		; remove if FODDER
003B2F  3               
003B2F  3               ; Horizontal digging
003B2F  3               
003B2F  3               digh:
003B2F  3               	jsr tstbl		; check blocktype in MAP
003B2F  3               	jsr fdchk		; remove if FODDER
003B2F  3               
003B2F  3               	inc dispy		; look 1 cell down
003B2F  3               	inc dispy		; look 1 cell down
003B2F  3               	inc dispy		; look 1 cell down
003B2F  3               	jsr tstbl		; check blocktype in MAP
003B2F  3               	jsr fdchk		; remove if FODDER
003B2F  3               
003B2F  3               	inc dispy		; look 1 cell down
003B2F  3               	inc dispy		; look 1 cell down
003B2F  3               	inc dispy		; look 1 cell down
003B2F  3               	jsr tstbl		; check blocktype in MAP
003B2F  3               	jsr fdchk		; remove if FODDER
003B2F  3               
003B2F  3               	ldy dispy
003B2F  3               	lda V_SPR_PTR,y
003B2F  3               	bne :+
003B2F  3               	rts
003B2F  3               :
003B2F  3               	inc dispy		; look 1 cell down
003B2F  3               	inc dispy		; look 1 cell down
003B2F  3               	inc dispy		; look 1 cell down
003B2F  3               	jsr tstbl		; check blocktype in MAP
003B2F  3               	jmp fdchk		; remove if FODDER
003B2F  3               
003B2F  3               digcnt:	.byte 0
003B2F  3               
003B2F  3               .endif
003B2F  3               
003B2F  3               ;------------------------------------------------------------------
003B2F  3               ; Sprite table
003B2F  3               ;------------------------------------------------------------------
003B2F  3               
003B2F  3               
003B2F  3               ; ix+0  = type.
003B2F  3               ; ix+1  = sprite image number.
003B2F  3               ; ix+2  = frame.
003B2F  3               ; ix+3  = y coord.
003B2F  3               ; ix+4  = x coord.
003B2F  3               
003B2F  3               ; ix+5  = new type.
003B2F  3               ; ix+6  = new image number.
003B2F  3               ; ix+7  = new frame.
003B2F  3               ; ix+8  = new y coord.
003B2F  3               ; ix+9  = new x coord.
003B2F  3               
003B2F  3               ; ix+10 = direction.
003B2F  3               ; ix+11 = parameter 1.
003B2F  3               ; ix+12 = parameter 2.
003B2F  3               ; ix+13 = jump pointer low.
003B2F  3               ; ix+14 = jump pointer high.
003B2F  3               ; ix+15 = data pointer low.
003B2F  3               ; ix+16 = data pointer high.
003B2F  3               
003B2F  3               ; block NUMSPR * TABSIZ,255
003B2F  3               
003B2F  3  FF FF FF FF  sprtab:	.res NUMSPR*TABSIZ,255
003B33  3  FF FF FF FF  
003B37  3  FF FF FF FF  
003BFB  3  FF FF FF FF  ssprit:	.byte 255,255,255,255,255,255,255,0,192,120,0,0,0,255,255,255,255
003BFF  3  FF FF FF 00  
003C03  3  C0 78 00 00  
003C0C  3  07           roomtb:	.byte 7                      ; start room map offset.
003C0D  3               
003C0D  3               ; User routine.  Put your own code in here to be called with USER instruction.
003C0D  3               ; if USER has an argument it will be passed in the accumulator.
003C0D  3               
003C0D  3               user:
003C0D  3               	.include "user.inc"
003C0D  4  60           	rts
003C0E  4               
003C0E  3               
003C0E  3               setfgcol:
003C0E  3  29 07        	and #7
003C10  3  8D 1D 3C     	sta fcolour
003C13  3  60           	rts
003C14  3               
003C14  3               setbgcol:
003C14  3  29 07        	and #7
003C16  3  18           	clc
003C17  3  69 10        	adc #16
003C19  3  8D 1E 3C     	sta bcolour
003C1C  3  60           	rts
003C1D  3               
003C1D  3  07           fcolour:	.byte t_white
003C1E  3  17           bcolour:	.byte g_white
003C1F  3               
003C1F  3               ; Everything below here will be generated by the editors.
003C1F  3               
003C1F  3  60                   rts
003C20  3               WINDOWTOP = 2
003C20  3               WINDOWLFT = 1
003C20  3               WINDOWHGT = 23
003C20  3               WINDOWWID = 39 ;
003C20  3               MAPWID = 3
003C20  3  FF FF FF             .byte 255,255,255
003C23  3               mapdat:
003C23  3  FF 00 FF             .byte 255,0,255
003C26  3  FF FF FF             .byte 255,255,255
003C29  3  01           stmap:  .byte 1
003C2A  3               
003C2A  3               evnt00:
003C2A  3  A9 00                lda #0
003C2C  3  85 rr                sta varm
003C2E  3  A5 rr                lda joyval	; KEY
003C30  3  29 08                and #8
003C32  3  F0 03                beq :+
003C34  3  4C 4C 3C             jmp a00078
003C37  3               :
003C37  3  A9 01                lda #1
003C39  3  85 rr                sta varm
003C3B  3  20 6A 31             jsr cangu	; CANGOUP
003C3E  3  F0 03                beq :+
003C40  3  4C 4C 3C             jmp a00078
003C43  3               :
003C43  3  A0 08                ldy #8 		; SPRITEUP
003C45  3  B1 68                lda (z80_ix),y
003C47  3  38                   sec
003C48  3  E9 01                sbc #1
003C4A  3  91 68                sta (z80_ix),y
003C4C  3  A5 rr        a00078: lda joyval	; KEY
003C4E  3  29 04                and #4
003C50  3  F0 03                beq :+
003C52  3  4C 6A 3C             jmp a00147
003C55  3               :
003C55  3  A9 01                lda #1
003C57  3  85 rr                sta varm
003C59  3  20 B7 31             jsr cangd	; CANGODOWN
003C5C  3  F0 03                beq :+
003C5E  3  4C 6A 3C             jmp a00147
003C61  3               :
003C61  3  A0 08                ldy #8 		; SPRITEDOWN
003C63  3  B1 68                lda (z80_ix),y
003C65  3  18                   clc
003C66  3  69 01                adc #1
003C68  3  91 68                sta (z80_ix),y
003C6A  3  A5 rr        a00147: lda joyval	; KEY
003C6C  3  29 02                and #2
003C6E  3  F0 03                beq :+
003C70  3  4C 88 3C             jmp a00216
003C73  3               :
003C73  3  A9 01                lda #1
003C75  3  85 rr                sta varm
003C77  3  20 04 32             jsr cangl	; CANGOLEFT
003C7A  3  F0 03                beq :+
003C7C  3  4C 88 3C             jmp a00216
003C7F  3               :
003C7F  3  A0 09                ldy #9 		; SPRITELEFT
003C81  3  B1 68                lda (z80_ix),y
003C83  3  38                   sec
003C84  3  E9 01                sbc #1
003C86  3  91 68                sta (z80_ix),y
003C88  3  A5 rr        a00216: lda joyval	; KEY
003C8A  3  29 01                and #1
003C8C  3  F0 03                beq :+
003C8E  3  4C A6 3C             jmp a00286
003C91  3               :
003C91  3  A9 01                lda #1
003C93  3  85 rr                sta varm
003C95  3  20 16 32             jsr cangr	; CANGORIGHT
003C98  3  F0 03                beq :+
003C9A  3  4C A6 3C             jmp a00286
003C9D  3               :
003C9D  3  A0 09                ldy #9 		; SPRITERIGHT
003C9F  3  B1 68                lda (z80_ix),y
003CA1  3  18                   clc
003CA2  3  69 01                adc #1
003CA4  3  91 68                sta (z80_ix),y
003CA6  3  A9 00        a00286: lda #0
003CA8  3  C5 rr                cmp varm
003CAA  3  90 03                bcc *+5
003CAC  3  4C B4 3C             jmp a00314
003CAF  3  A9 00                lda #0		; ANIMATE
003CB1  3  20 ED 36             jsr animsp
003CB4  3               a00314: ; SPRITEINK command
003CB4  3  20 C1 2D             jsr skobj	; DETECTOBJECT
003CB7  3  85 rr                sta varobj
003CB9  3  A9 00                lda #0
003CBB  3  85 rr                sta chary
003CBD  3  A9 1F                lda #31
003CBF  3  85 rr                sta charx
003CC1  3  A5 rr                lda varobj	; DISPLAY
003CC3  3  20 C8 37             jsr disply
003CC6  3  A9 06                lda #6		; PRINT
003CC8  3  20 6C 33             jsr dmsg
003CCB  3  A9 03                lda #3
003CCD  3  C5 rr                cmp varobj
003CCF  3  F0 03                beq *+5
003CD1  3  4C D9 3C             jmp a00401
003CD4  3  A5 rr                lda varobj	; GET
003CD6  3  20 40 2D             jsr getob
003CD9  3  A9 04        a00401: lda #4
003CDB  3  C5 rr                cmp varobj
003CDD  3  F0 03                beq *+5
003CDF  3  4C E7 3C             jmp a00429
003CE2  3  A5 rr                lda varobj	; GET
003CE4  3  20 40 2D             jsr getob
003CE7  3  A9 05        a00429: lda #5
003CE9  3  C5 rr                cmp varobj
003CEB  3  F0 03                beq *+5
003CED  3  4C F5 3C             jmp a00457
003CF0  3  A5 rr                lda varobj	; GET
003CF2  3  20 40 2D             jsr getob
003CF5  3  A9 06        a00457: lda #6
003CF7  3  C5 rr                cmp varobj
003CF9  3  F0 03                beq *+5
003CFB  3  4C 08 3D             jmp a00495
003CFE  3  A9 01                lda #1	; REMOVEOBJ
003D00  3  20 2B 2D             jsr remob
003D03  3  A9 01                lda #1	; GET
003D05  3  20 40 2D             jsr getob
003D08  3  A9 07        a00495: lda #7
003D0A  3  C5 rr                cmp varobj
003D0C  3  F0 03                beq *+5
003D0E  3  4C 2A 3D             jmp a00563
003D11  3  A9 01                lda #1		; GOT
003D13  3  20 6F 2D             jsr gotob
003D16  3  C9 FF                cmp #255
003D18  3  F0 03                beq :+
003D1A  3  4C 2A 3D             jmp a00563
003D1D  3               :
003D1D  3  A9 0C                lda #12	; PUT
003D1F  3  85 rr                sta dispx
003D21  3  A9 26                lda #38
003D23  3  85 rr                sta dispy
003D25  3  A9 01                lda #1
003D27  3  20 A0 2D             jsr drpob
003D2A  3  A5 rr        a00563: lda joyval	; KEY
003D2C  3  29 10                and #16
003D2E  3  F0 03                beq :+
003D30  3  4C B4 3D             jmp a00860
003D33  3               :
003D33  3  A9 07                lda #7		; INVENTORY
003D35  3  AA                   tax
003D36  3  20 28 28             jsr minve
003D39  3  A9 03                lda #3
003D3B  3  C5 rr                cmp varopt
003D3D  3  F0 03                beq *+5
003D3F  3  4C 62 3D             jmp a00684
003D42  3  A0 09                ldy #9
003D44  3  B1 68                lda (z80_ix),y
003D46  3  85 rr                sta vard
003D48  3  A9 08                lda #8
003D4A  3  85 62                sta z80_c
003D4C  3  A5 rr                lda vard
003D4E  3  18                   clc
003D4F  3  65 62                adc z80_c
003D51  3  85 rr                sta vard
003D53  3  A5 rr                lda vard	; PUT
003D55  3  85 rr                sta dispx
003D57  3  A0 08                ldy #8
003D59  3  B1 68                lda (z80_ix),y
003D5B  3  85 rr                sta dispy
003D5D  3  A9 03                lda #3
003D5F  3  20 A0 2D             jsr drpob
003D62  3  A9 04        a00684: lda #4
003D64  3  C5 rr                cmp varopt
003D66  3  F0 03                beq *+5
003D68  3  4C 8B 3D             jmp a00772
003D6B  3  A0 09                ldy #9
003D6D  3  B1 68                lda (z80_ix),y
003D6F  3  85 rr                sta vard
003D71  3  A9 08                lda #8
003D73  3  85 62                sta z80_c
003D75  3  A5 rr                lda vard
003D77  3  18                   clc
003D78  3  65 62                adc z80_c
003D7A  3  85 rr                sta vard
003D7C  3  A5 rr                lda vard	; PUT
003D7E  3  85 rr                sta dispx
003D80  3  A0 08                ldy #8
003D82  3  B1 68                lda (z80_ix),y
003D84  3  85 rr                sta dispy
003D86  3  A9 04                lda #4
003D88  3  20 A0 2D             jsr drpob
003D8B  3  A9 05        a00772: lda #5
003D8D  3  C5 rr                cmp varopt
003D8F  3  F0 03                beq *+5
003D91  3  4C B4 3D             jmp a00860
003D94  3  A0 09                ldy #9
003D96  3  B1 68                lda (z80_ix),y
003D98  3  85 rr                sta vard
003D9A  3  A9 08                lda #8
003D9C  3  85 62                sta z80_c
003D9E  3  A5 rr                lda vard
003DA0  3  18                   clc
003DA1  3  65 62                adc z80_c
003DA3  3  85 rr                sta vard
003DA5  3  A5 rr                lda vard	; PUT
003DA7  3  85 rr                sta dispx
003DA9  3  A0 08                ldy #8
003DAB  3  B1 68                lda (z80_ix),y
003DAD  3  85 rr                sta dispy
003DAF  3  A9 05                lda #5
003DB1  3  20 A0 2D             jsr drpob
003DB4  3  60           a00860: rts
003DB5  3               evnt01:
003DB5  3  60                   rts
003DB6  3               evnt02:
003DB6  3  60                   rts
003DB7  3               evnt03:
003DB7  3  60                   rts
003DB8  3               evnt04:
003DB8  3  60                   rts
003DB9  3               evnt05:
003DB9  3  60                   rts
003DBA  3               evnt06:
003DBA  3  60                   rts
003DBB  3               evnt07:
003DBB  3  60                   rts
003DBC  3               evnt08:
003DBC  3  60                   rts
003DBD  3               evnt09:
003DBD  3  60                   rts
003DBE  3               evnt10:
003DBE  3  60                   rts
003DBF  3               evnt11:
003DBF  3  60                   rts
003DC0  3               evnt12:
003DC0  3  60                   rts
003DC1  3               evnt13:
003DC1  3  60                   rts
003DC2  3               evnt14:
003DC2  3  20 43 45             jsr cls		; CLS
003DC5  3  A9 01                lda #1 	; INK
003DC7  3  20 0E 3C             jsr setfgcol
003DCA  3  A9 01                lda #1		; PRINTMODE
003DCC  3  85 rr                sta prtmod
003DCE  3  A9 00                lda #0
003DD0  3  85 rr                sta chary
003DD2  3  A9 01                lda #1
003DD4  3  85 rr                sta charx
003DD6  3  A9 08                lda #8		; PRINT
003DD8  3  20 6C 33             jsr dmsg
003DDB  3  A9 00                lda #0		; PRINTMODE
003DDD  3  85 rr                sta prtmod
003DDF  3  A9 00                lda #0
003DE1  3  85 rr                sta chary
003DE3  3  A9 0F                lda #15
003DE5  3  85 rr                sta charx
003DE7  3  A9 09                lda #9		; PRINT
003DE9  3  20 6C 33             jsr dmsg
003DEC  3  60                   rts
003DED  3               evnt15:
003DED  3  60                   rts
003DEE  3               evnt16:
003DEE  3  60                   rts
003DEF  3               evnt17:
003DEF  3  A9 01                lda #1		; PRINTMODE
003DF1  3  85 rr                sta prtmod
003DF3  3  A9 08                lda #8
003DF5  3  85 rr                sta chary
003DF7  3  A9 0D                lda #13
003DF9  3  85 rr                sta charx
003DFB  3  A9 0A                lda #10		; PRINT
003DFD  3  20 6C 33             jsr dmsg
003E00  3  A9 02                lda #2
003E02  3  85 62                sta z80_c
003E04  3  A5 rr                lda chary
003E06  3  18                   clc
003E07  3  65 62                adc z80_c
003E09  3  85 rr                sta chary
003E0B  3  A9 0D                lda #13
003E0D  3  85 rr                sta charx
003E0F  3  A9 0B                lda #11		; PRINT
003E11  3  20 6C 33             jsr dmsg
003E14  3  20 FA 45             jsr prskey	; WAITKEY
003E17  3  60                   rts
003E18  3               evnt18:
003E18  3  60                   rts
003E19  3               evnt19:
003E19  3  A9 0E                lda #14
003E1B  3  85 rr                sta chary
003E1D  3  A9 08                lda #8
003E1F  3  85 rr                sta charx
003E21  3  A9 0C                lda #12		; PRINT
003E23  3  20 6C 33             jsr dmsg
003E26  3  60                   rts
003E27  3               evnt20:
003E27  3  60                   rts
003E28  3  60           ptcusr: rts
003E29  3               msgdat:
003E29  3  53 43 4F 52          .byte "SCOR",197
003E2D  3  C5           
003E2E  3  20 20 48 49          .byte "  HIG",200
003E32  3  47 C8        
003E34  3  44 4F 44 47          .byte "DODGY GEEZ",197
003E38  3  59 20 47 45  
003E3C  3  45 5A C5     
003E3F  3  20 47 41 4D          .byte " GAM",197
003E43  3  C5           
003E44  3  20 4F 56 45          .byte " OVE",210
003E48  3  D2           
003E49  3  20 4E 45 57          .byte " NEW HIGH SCOR",197
003E4D  3  20 48 49 47  
003E51  3  48 20 53 43  
003E58  3  A0                   .byte 160
003E59  3  4F 42 4A 30          .byte "OBJ0,OBJ1,OBJ2,OBJ3,OBJ4,OBJ",181
003E5D  3  2C 4F 42 4A  
003E61  3  31 2C 4F 42  
003E76  3  4F 42 4A 45          .byte "OBJECT DEM",207
003E7A  3  43 54 20 44  
003E7E  3  45 4D CF     
003E81  3  48 49 54 54          .byte "HITTING OBJECT",186
003E85  3  49 4E 47 20  
003E89  3  4F 42 4A 45  
003E90  3  20 47 41 4D          .byte " GAME",160
003E94  3  45 A0        
003E96  3  20 4F 56 45          .byte " OVER",160
003E9A  3  52 A0        
003E9C  3  20 4E 45 57          .byte " NEW HIGH SCORE",160
003EA0  3  20 48 49 47  
003EA4  3  48 20 53 43  
003EAC  3               nummsg:
003EAC  3  0D                   .byte 13
003EAD  3               chgfx:
003EAD  3  00 01                .byte 0,1
003EAF  3  7F 01                .byte 127,1
003EB1  3               bprop:
003EB1  3  00                   .byte 0
003EB2  3  02                   .byte 2
003EB3  3               sprgfx:
003EB3  3  28 7B 39 20          .byte 40,123,57,32,0,56,126,60,48,0,97,53,117,33,0,0,0,0,0,0
003EB7  3  00 38 7E 3C  
003EBB  3  30 00 61 35  
003EC7  3  40 4C 44 00          .byte 64,76,68,0,0,64,91,81,0,0,5,23,21,5,0,2,1,3,0,0
003ECB  3  00 40 5B 51  
003ECF  3  00 00 05 17  
003EDB  3  00 50 10 00          .byte 0,80,16,0,0,2,78,6,0,0,22,31,23,20,0,8,5,13,0,0
003EDF  3  00 02 4E 06  
003EE3  3  00 00 16 1F  
003EEF  3  00 46 57 04          .byte 0,70,87,4,0,64,76,93,68,0,2,90,74,18,0,0,0,0,0,0
003EF3  3  00 40 4C 5D  
003EF7  3  44 00 02 5A  
003F03  3  00 18 1C 10          .byte 0,24,28,16,0,0,82,87,16,0,10,74,75,10,0,0,3,2,1,0
003F07  3  00 00 52 57  
003F0B  3  10 00 0A 4A  
003F17  3  00 40 50 00          .byte 0,64,80,0,0,0,9,29,1,0,72,75,79,73,0,0,14,10,4,0
003F1B  3  00 00 09 1D  
003F1F  3  01 00 48 4B  
003F2B  3  28 7B 39 20          .byte 40,123,57,32,0,56,126,60,48,0,97,53,45,33,0,0,0,0,0,0
003F2F  3  00 38 7E 3C  
003F33  3  30 00 61 35  
003F3F  3  40 4C 44 00          .byte 64,76,68,0,0,64,91,81,0,0,5,23,85,5,0,2,1,0,0,0
003F43  3  00 40 5B 51  
003F47  3  00 00 05 17  
003F53  3  00 50 10 00          .byte 0,80,16,0,0,2,78,6,0,0,22,31,23,20,0,8,5,3,0,0
003F57  3  00 02 4E 06  
003F5B  3  00 00 16 1F  
003F67  3  00 46 57 04          .byte 0,70,87,4,0,64,76,93,68,0,2,90,10,6,0,0,0,0,0,0
003F6B  3  00 40 4C 5D  
003F6F  3  44 00 02 5A  
003F7B  3  00 18 1C 10          .byte 0,24,28,16,0,0,82,87,16,0,10,74,75,26,0,0,3,0,0,0
003F7F  3  00 00 52 57  
003F83  3  10 00 0A 4A  
003F8F  3  00 40 50 00          .byte 0,64,80,0,0,0,9,29,1,0,72,75,79,73,0,0,14,2,1,0
003F93  3  00 00 09 1D  
003F97  3  01 00 48 4B  
003FA3  3  28 7B 39 20          .byte 40,123,57,32,0,56,126,60,48,0,97,53,117,33,0,0,0,0,0,0
003FA7  3  00 38 7E 3C  
003FAB  3  30 00 61 35  
003FB7  3  40 4C 44 00          .byte 64,76,68,0,0,64,91,81,0,0,5,23,21,5,0,2,1,3,0,0
003FBB  3  00 40 5B 51  
003FBF  3  00 00 05 17  
003FCB  3  00 50 10 00          .byte 0,80,16,0,0,2,78,6,0,0,22,31,23,20,0,8,5,13,0,0
003FCF  3  00 02 4E 06  
003FD3  3  00 00 16 1F  
003FDF  3  00 46 57 04          .byte 0,70,87,4,0,64,76,93,68,0,2,90,74,18,0,0,0,0,0,0
003FE3  3  00 40 4C 5D  
003FE7  3  44 00 02 5A  
003FF3  3  00 18 1C 10          .byte 0,24,28,16,0,0,82,87,16,0,10,74,75,10,0,0,3,2,1,0
003FF7  3  00 00 52 57  
003FFB  3  10 00 0A 4A  
004007  3  00 40 50 00          .byte 0,64,80,0,0,0,9,29,1,0,72,75,79,73,0,0,14,10,4,0
00400B  3  00 00 09 1D  
00400F  3  01 00 48 4B  
00401B  3  28 7B 39 20          .byte 40,123,57,32,0,56,126,60,48,0,41,37,117,33,0,0,0,0,0,0
00401F  3  00 38 7E 3C  
004023  3  30 00 29 25  
00402F  3  40 4C 44 00          .byte 64,76,68,0,0,64,91,81,0,0,69,23,21,5,0,0,0,3,0,0
004033  3  00 40 5B 51  
004037  3  00 00 45 17  
004043  3  00 50 10 00          .byte 0,80,16,0,0,2,78,6,0,0,22,31,23,20,0,2,1,13,0,0
004047  3  00 02 4E 06  
00404B  3  00 00 16 1F  
004057  3  00 46 57 04          .byte 0,70,87,4,0,64,76,93,68,0,2,14,74,18,0,0,0,0,0,0
00405B  3  00 40 4C 5D  
00405F  3  44 00 02 0E  
00406B  3  00 18 1C 10          .byte 0,24,28,16,0,0,82,87,16,0,10,90,75,10,0,0,0,2,1,0
00406F  3  00 00 52 57  
004073  3  10 00 0A 5A  
00407F  3  00 40 50 00          .byte 0,64,80,0,0,0,9,29,1,0,72,75,79,73,0,0,3,10,4,0
004083  3  00 00 09 1D  
004087  3  01 00 48 4B  
004093  3               frmlst:
004093  3  00 04 04 00          .byte 0,4,4,0
004097  3               scdat:
004097  3  6D 00                .word 109
004099  3  FF 01 28 FF          .byte 255,1,40,255,0,37,1,1,255,0,37,1,1,255,0,37,1,1,255,0,37,1,1,255,0,37,1,1,255,0,37,1,1
00409D  3  00 25 01 01  
0040A1  3  FF 00 25 01  
0040BA  3  FF 00 25 01          .byte 255,0,37,1,1,255,0,37,1,1,255,0,37,1,1,255,0,37,1,1,255,0,37,1,1,255,0,37,1,1,255,0,37
0040BE  3  01 FF 00 25  
0040C2  3  01 01 FF 00  
0040DB  3  01 01 FF 00          .byte 1,1,255,0,37,1,1,255,0,37,1,1,255,0,37,1,1,255,0,37,1,1,255,0,37,1,1,255,0,37,1,1,255,0,37
0040DF  3  25 01 01 FF  
0040E3  3  00 25 01 01  
0040FE  3  01 01 FF 00          .byte 1,1,255,0,37,255,1,40
004102  3  25 FF 01 28  
004106  3               numsc:
004106  3  01                   .byte 1
004107  3               nmedat:
004107  3  00 00 24 26          .byte 0,0,36,38,255
00410B  3  FF           
00410C  3               NUMOBJ = 8
00410C  3               objdta:
00410C  3  3F 33 63 6F          .byte 63,51,99,111,53,106,53,106,125,113,114,126,0,18,24,0,18,24
004110  3  35 6A 35 6A  
004114  3  7D 71 72 7E  
00411E  3  37 63 33 6B          .byte 55,99,51,107,53,117,122,106,117,113,114,122,0,38,12,0,38,12
004122  3  35 75 7A 6A  
004126  3  75 71 72 7A  
004130  3  3F 33 63 6F          .byte 63,51,99,111,53,106,53,106,125,113,114,126,0,56,24,0,56,24
004134  3  35 6A 35 6A  
004138  3  7D 71 72 7E  
004142  3  37 73 33 6B          .byte 55,115,51,107,53,32,102,106,117,115,113,122,0,18,50,0,18,50
004146  3  35 20 66 6A  
00414A  3  75 73 71 7A  
004154  3  37 63 23 6B          .byte 55,99,35,107,53,118,112,106,117,112,113,122,0,38,50,0,38,50
004158  3  35 76 70 6A  
00415C  3  75 70 71 7A  
004166  3  37 73 73 6B          .byte 55,115,115,107,53,41,100,106,117,115,113,122,0,56,50,0,56,50
00416A  3  35 29 64 6A  
00416E  3  75 73 71 7A  
004178  3  37 73 33 6B          .byte 55,115,51,107,53,61,102,106,117,113,114,122,0,38,62,0,38,62
00417C  3  35 3D 66 6A  
004180  3  75 71 72 7A  
00418A  3  37 73 33 6B          .byte 55,115,51,107,53,61,38,106,117,113,112,122,0,38,24,0,38,24
00418E  3  35 3D 26 6A  
004192  3  75 71 70 7A  
00419C  3               font:
00419C  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
0041A0  3  00 00 00 00  
0041A4  3  00 30 30 30          .byte 0,48,48,48,48,0,48,0
0041A8  3  30 00 30 00  
0041AC  3  00 6C 6C 00          .byte 0,108,108,0,0,0,0,0
0041B0  3  00 00 00 00  
0041B4  3  00 6C FE 6C          .byte 0,108,254,108,108,254,108,0
0041B8  3  6C FE 6C 00  
0041BC  3  00 18 7E 78          .byte 0,24,126,120,126,30,126,24
0041C0  3  7E 1E 7E 18  
0041C4  3  00 E6 EC 18          .byte 0,230,236,24,48,110,206,0
0041C8  3  30 6E CE 00  
0041CC  3  00 30 78 30          .byte 0,48,120,48,126,204,126,0
0041D0  3  7E CC 7E 00  
0041D4  3  00 18 30 00          .byte 0,24,48,0,0,0,0,0
0041D8  3  00 00 00 00  
0041DC  3  00 0C 18 18          .byte 0,12,24,24,24,24,12,0
0041E0  3  18 18 0C 00  
0041E4  3  00 60 30 30          .byte 0,96,48,48,48,48,96,0
0041E8  3  30 30 60 00  
0041EC  3  00 00 3C 18          .byte 0,0,60,24,126,24,60,0
0041F0  3  7E 18 3C 00  
0041F4  3  00 00 18 18          .byte 0,0,24,24,126,24,24,0
0041F8  3  7E 18 18 00  
0041FC  3  00 00 00 00          .byte 0,0,0,0,0,24,24,48
004200  3  00 18 18 30  
004204  3  00 00 00 00          .byte 0,0,0,0,126,0,0,0
004208  3  7E 00 00 00  
00420C  3  00 00 00 00          .byte 0,0,0,0,0,56,56,0
004210  3  00 38 38 00  
004214  3  00 00 06 0C          .byte 0,0,6,12,24,48,96,0
004218  3  18 30 60 00  
00421C  3  00 7C CE DE          .byte 0,124,206,222,246,230,124,0
004220  3  F6 E6 7C 00  
004224  3  00 38 78 18          .byte 0,56,120,24,24,24,126,0
004228  3  18 18 7E 00  
00422C  3  00 7C C6 06          .byte 0,124,198,6,124,192,254,0
004230  3  7C C0 FE 00  
004234  3  00 7C C6 1C          .byte 0,124,198,28,6,198,124,0
004238  3  06 C6 7C 00  
00423C  3  00 18 38 78          .byte 0,24,56,120,216,254,24,0
004240  3  D8 FE 18 00  
004244  3  00 FE C0 FC          .byte 0,254,192,252,6,198,124,0
004248  3  06 C6 7C 00  
00424C  3  00 7C C0 FC          .byte 0,124,192,252,198,198,124,0
004250  3  C6 C6 7C 00  
004254  3  00 FE 06 0C          .byte 0,254,6,12,24,48,48,0
004258  3  18 30 30 00  
00425C  3  00 7C C6 7C          .byte 0,124,198,124,198,198,124,0
004260  3  C6 C6 7C 00  
004264  3  00 7C C6 C6          .byte 0,124,198,198,126,6,124,0
004268  3  7E 06 7C 00  
00426C  3  00 00 00 30          .byte 0,0,0,48,0,0,48,0
004270  3  00 00 30 00  
004274  3  00 00 30 00          .byte 0,0,48,0,0,48,48,96
004278  3  00 30 30 60  
00427C  3  00 00 0C 18          .byte 0,0,12,24,48,24,12,0
004280  3  30 18 0C 00  
004284  3  00 00 00 7E          .byte 0,0,0,126,0,126,0,0
004288  3  00 7E 00 00  
00428C  3  00 00 30 18          .byte 0,0,48,24,12,24,48,0
004290  3  0C 18 30 00  
004294  3  00 7C C6 0C          .byte 0,124,198,12,24,0,24,0
004298  3  18 00 18 00  
00429C  3  00 7C DE FE          .byte 0,124,222,254,254,192,124,0
0042A0  3  FE C0 7C 00  
0042A4  3  00 7C C6 C6          .byte 0,124,198,198,254,198,198,0
0042A8  3  FE C6 C6 00  
0042AC  3  00 FC C6 FC          .byte 0,252,198,252,198,198,252,0
0042B0  3  C6 C6 FC 00  
0042B4  3  00 7C C6 C0          .byte 0,124,198,192,192,198,124,0
0042B8  3  C0 C6 7C 00  
0042BC  3  00 F8 CC C6          .byte 0,248,204,198,198,204,248,0
0042C0  3  C6 CC F8 00  
0042C4  3  00 FE C0 FC          .byte 0,254,192,252,192,192,254,0
0042C8  3  C0 C0 FE 00  
0042CC  3  00 FE C0 FC          .byte 0,254,192,252,192,192,192,0
0042D0  3  C0 C0 C0 00  
0042D4  3  00 7C C6 C0          .byte 0,124,198,192,222,198,124,0
0042D8  3  DE C6 7C 00  
0042DC  3  00 C6 C6 FE          .byte 0,198,198,254,198,198,198,0
0042E0  3  C6 C6 C6 00  
0042E4  3  00 7E 18 18          .byte 0,126,24,24,24,24,126,0
0042E8  3  18 18 7E 00  
0042EC  3  00 06 06 06          .byte 0,6,6,6,198,198,124,0
0042F0  3  C6 C6 7C 00  
0042F4  3  00 CC D8 F0          .byte 0,204,216,240,216,204,198,0
0042F8  3  D8 CC C6 00  
0042FC  3  00 C0 C0 C0          .byte 0,192,192,192,192,192,254,0
004300  3  C0 C0 FE 00  
004304  3  00 C6 EE FE          .byte 0,198,238,254,198,198,198,0
004308  3  C6 C6 C6 00  
00430C  3  00 C6 E6 F6          .byte 0,198,230,246,222,206,198,0
004310  3  DE CE C6 00  
004314  3  00 7C C6 C6          .byte 0,124,198,198,198,198,124,0
004318  3  C6 C6 7C 00  
00431C  3  00 FC C6 C6          .byte 0,252,198,198,252,192,192,0
004320  3  FC C0 C0 00  
004324  3  00 7C C6 C6          .byte 0,124,198,198,246,222,124,0
004328  3  F6 DE 7C 00  
00432C  3  00 FC C6 C6          .byte 0,252,198,198,252,204,198,0
004330  3  FC CC C6 00  
004334  3  00 7C C0 7C          .byte 0,124,192,124,6,198,124,0
004338  3  06 C6 7C 00  
00433C  3  00 FE 30 30          .byte 0,254,48,48,48,48,48,0
004340  3  30 30 30 00  
004344  3  00 C6 C6 C6          .byte 0,198,198,198,198,198,124,0
004348  3  C6 C6 7C 00  
00434C  3  00 C6 C6 C6          .byte 0,198,198,198,198,108,56,0
004350  3  C6 6C 38 00  
004354  3  00 C6 C6 C6          .byte 0,198,198,198,198,254,108,0
004358  3  C6 FE 6C 00  
00435C  3  00 C6 6C 38          .byte 0,198,108,56,56,108,198,0
004360  3  38 6C C6 00  
004364  3  00 86 CC 78          .byte 0,134,204,120,48,48,48,0
004368  3  30 30 30 00  
00436C  3  00 FE 0C 18          .byte 0,254,12,24,48,96,254,0
004370  3  30 60 FE 00  
004374  3  00 1E 18 18          .byte 0,30,24,24,24,24,30,0
004378  3  18 18 1E 00  
00437C  3  00 00 C0 60          .byte 0,0,192,96,48,24,12,0
004380  3  30 18 0C 00  
004384  3  00 F0 30 30          .byte 0,240,48,48,48,48,240,0
004388  3  30 30 F0 00  
00438C  3  00 30 78 FC          .byte 0,48,120,252,48,48,48,0
004390  3  30 30 30 00  
004394  3  00 00 00 00          .byte 0,0,0,0,0,0,0,255
004398  3  00 00 00 FF  
00439C  3  00 3C 66 F8          .byte 0,60,102,248,96,96,254,0
0043A0  3  60 60 FE 00  
0043A4  3  00 00 78 0C          .byte 0,0,120,12,124,204,124,0
0043A8  3  7C CC 7C 00  
0043AC  3  00 60 60 7C          .byte 0,96,96,124,102,102,124,0
0043B0  3  66 66 7C 00  
0043B4  3  00 00 3C 60          .byte 0,0,60,96,96,96,60,0
0043B8  3  60 60 3C 00  
0043BC  3  00 0C 0C 7C          .byte 0,12,12,124,204,204,124,0
0043C0  3  CC CC 7C 00  
0043C4  3  00 00 78 CC          .byte 0,0,120,204,248,192,124,0
0043C8  3  F8 C0 7C 00  
0043CC  3  00 1C 30 38          .byte 0,28,48,56,48,48,48,0
0043D0  3  30 30 30 00  
0043D4  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,120
0043D8  3  CC 7C 0C 78  
0043DC  3  00 C0 C0 F8          .byte 0,192,192,248,204,204,204,0
0043E0  3  CC CC CC 00  
0043E4  3  00 30 00 70          .byte 0,48,0,112,48,48,120,0
0043E8  3  30 30 78 00  
0043EC  3  00 0C 00 0C          .byte 0,12,0,12,12,12,108,56
0043F0  3  0C 0C 6C 38  
0043F4  3  00 60 78 70          .byte 0,96,120,112,112,120,108,0
0043F8  3  70 78 6C 00  
0043FC  3  00 30 30 30          .byte 0,48,48,48,48,48,28,0
004400  3  30 30 1C 00  
004404  3  00 00 F8 FC          .byte 0,0,248,252,252,252,252,0
004408  3  FC FC FC 00  
00440C  3  00 00 F8 CC          .byte 0,0,248,204,204,204,204,0
004410  3  CC CC CC 00  
004414  3  00 00 78 CC          .byte 0,0,120,204,204,204,120,0
004418  3  CC CC 78 00  
00441C  3  00 00 F8 CC          .byte 0,0,248,204,204,248,192,192
004420  3  CC F8 C0 C0  
004424  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,14
004428  3  CC 7C 0C 0E  
00442C  3  00 00 3C 60          .byte 0,0,60,96,96,96,96,0
004430  3  60 60 60 00  
004434  3  00 00 78 C0          .byte 0,0,120,192,120,12,248,0
004438  3  78 0C F8 00  
00443C  3  00 30 78 30          .byte 0,48,120,48,48,48,28,0
004440  3  30 30 1C 00  
004444  3  00 00 CC CC          .byte 0,0,204,204,204,204,120,0
004448  3  CC CC 78 00  
00444C  3  00 00 CC CC          .byte 0,0,204,204,120,120,48,0
004450  3  78 78 30 00  
004454  3  00 00 CC FC          .byte 0,0,204,252,252,252,120,0
004458  3  FC FC 78 00  
00445C  3  00 00 CC 78          .byte 0,0,204,120,48,120,204,0
004460  3  30 78 CC 00  
004464  3  00 00 CC CC          .byte 0,0,204,204,204,124,12,120
004468  3  CC 7C 0C 78  
00446C  3  00 00 FC 18          .byte 0,0,252,24,48,96,252,0
004470  3  30 60 FC 00  
004474  3  00 1E 18 70          .byte 0,30,24,112,24,24,30,0
004478  3  18 18 1E 00  
00447C  3  00 18 18 18          .byte 0,24,24,24,24,24,24,0
004480  3  18 18 18 00  
004484  3  00 F0 30 1C          .byte 0,240,48,28,48,48,240,0
004488  3  30 30 F0 00  
00448C  3  00 3C 78 00          .byte 0,60,120,0,0,0,0,0
004490  3  00 00 00 00  
004494  3  7C C6 BB E3          .byte 124,198,187,227,227,187,198,124
004498  3  E3 BB C6 7C  
00449C  3               jtab:
00449C  3  63                   .byte 99
00449D  3  50 4F 41 51  keys:   .byte 80,79,65,81,32,78,77,49,50,51,52
0044A1  3  20 4E 4D 31  
0044A5  3  32 33 34     
0044A8  3               
0044A8  2               
0044A8  1               	.include "lib.inc"
0044A8  2               ;----------------------------------------------------------------------
0044A8  2               ; System 5 depending variables and routines
0044A8  2               ;----------------------------------------------------------------------
0044A8  2               
0044A8  2               ; Flags
0044A8  2               
0044A8  2               	real		= 0		; 0=emulator, 1=real system5
0044A8  2               
0044A8  2               ; Global variables
0044A8  2               
0044A8  2               	t_red		= 1		; Text colour definition filters
0044A8  2               	t_green		= 2
0044A8  2               	t_yellow	= 3
0044A8  2               	t_blue		= 4
0044A8  2               	t_magenta	= 5
0044A8  2               	t_cyan		= 6
0044A8  2               	t_white		= 7
0044A8  2               
0044A8  2               	g_red		= 17		; Graphics colour definition filters
0044A8  2               	g_green		= 18
0044A8  2               	g_yellow	= 19
0044A8  2               	g_blue		= 20
0044A8  2               	g_magenta	= 21
0044A8  2               	g_cyan		= 22
0044A8  2               	g_white		= 23
0044A8  2               
0044A8  2               	ScrWidth	= 40
0044A8  2               	ScrHeight	= 25
0044A8  2               
0044A8  2               .if real=1
0044A8  2               	IRQtime		= 20000		; 50Hz at 1Mhz clock
0044A8  2               .else
0044A8  2               	IRQtime		= 40000		; 50Hz at 2Mhz clock
0044A8  2               .endif
0044A8  2               
0044A8  2               ; System constants
0044A8  2               
0044A8  2               	IRQVEC		= $0204		; Interrupt vector
0044A8  2               	ScreenAddr	= $0400		; Startaddress video RAM
0044A8  2               
0044A8  2               	MC6845_Reg	= $0800		; MC6845 CRT controller register ptr
0044A8  2               	MC6845_Dat	= $0801		; MC6845 CRT controller data
0044A8  2               
0044A8  2               	VIA1		= $0e20
0044A8  2               	PORT_A		= VIA1+$1	; Keyboard
0044A8  2               	Timer1_Low  	= VIA1+$4	; Timer 1 low byte
0044A8  2               	Timer1_High 	= VIA1+$5	; Timer 1 high byte
0044A8  2               	Timer2_Low	= VIA1+$8	; Timer 2 low byte
0044A8  2               	Timer2_High	= VIA1+$9	; Timer 2 high byte
0044A8  2               	ACR		= VIA1+$b	; Auxiliary Control Register
0044A8  2               	PCR		= VIA1+$c	; Peripheral Control Register
0044A8  2               	IFR		= VIA1+$d 	; Interrupt Flag Register
0044A8  2               	IER		= VIA1+$e	; Interupt Enable Register
0044A8  2               
0044A8  2               	MAP 		= $D800		; properties map buffer (4x256 bytes)
0044A8  2               	SCADTB_lb 	= $DC00		; screen address table lo-byte (256 bytes)
0044A8  2               	SCADTB_hb 	= $DD00		; screen address table hi-byte (256 bytes)
0044A8  2               	SHRAPN 		= $DE00		; shrapnel table (55x6 bytes)
0044A8  2               	V_SPR_PTR	= $DF4A		; Vertical spriteframe pointer (75 bytes)
0044A8  2               
0044A8  2               ; System calls
0044A8  2               
0044A8  2               	OS_CLI   = $FFF7
0044A8  2               	OSBYTE   = $FFF4
0044A8  2               	OSWORD   = $FFF1
0044A8  2               	OSWRCH   = $FFEE
0044A8  2               	OSWRCR   = $FFEC
0044A8  2               	OSNEWL   = $FFE7
0044A8  2               	OSASCI   = $FFE3
0044A8  2               	OSRDCH   = $FFE0
0044A8  2               	OSFILE   = $FFDD
0044A8  2               	OSARGS   = $FFDA
0044A8  2               	OSBGET   = $FFD7
0044A8  2               	OSBPUT   = $FFD4
0044A8  2               	OSGBPB   = $FFD1
0044A8  2               	OSFIND   = $FFCE
0044A8  2               
0044A8  2               ; To be removed
0044A8  2               
0044A8  2               	SCRSYNC	= $fff4
0044A8  2               
0044A8  2               ;======================================================================
0044A8  2               ; System depending routines
0044A8  2               ;======================================================================
0044A8  2               
0044A8  2               ;----------------------------------------------------------------------
0044A8  2               ; Init hardware
0044A8  2               ;----------------------------------------------------------------------
0044A8  2               
0044A8  2               init:
0044A8  2               
0044A8  2               ; Set up screen address table.
0044A8  2               
0044A8  2               setsat:
0044A8  2  A9 00        	lda #<ScreenAddr	; start of screen.
0044AA  2  85 rr        	sta scraddr
0044AC  2  A9 04        	lda #>ScreenAddr
0044AE  2  85 rr        	sta scraddr+1
0044B0  2               
0044B0  2  A2 00        	ldx #0
0044B2  2  A0 00        	ldy #0			; vertical lines on screen.
0044B4  2               setsa0:
0044B4  2  A5 rr        	lda scraddr
0044B6  2  99 00 DC     	sta SCADTB_lb,y		; write low byte.
0044B9  2  A5 rr        	lda scraddr+1
0044BB  2  C0 4B        	cpy #ScrHeight*3		; vertical lines on screen.
0044BD  2  90 02        	bcc :+
0044BF  2  09 F0        	ora #$F0		; plot sprites in rom if of screen
0044C1  2               :
0044C1  2  99 00 DD     	sta SCADTB_hb,y		; write high byte.
0044C4  2  E8           	inx
0044C5  2  E0 03        	cpx #3
0044C7  2  D0 05        	bne :+
0044C9  2  20 E1 36     	jsr nline		; next line down.
0044CC  2  A2 00        	ldx #0
0044CE  2               :
0044CE  2  C8           	iny			; next position in table.
0044CF  2  D0 E3        	bne setsa0
0044D1  2               
0044D1  2               ; Set up vertical sprite pointer table
0044D1  2               
0044D1  2  A0 00        	ldy #0
0044D3  2  A9 00        	lda #0
0044D5  2               vspriteloop:
0044D5  2  99 4A DF     	sta V_SPR_PTR,y
0044D8  2  18           	clc
0044D9  2  69 14        	adc #20
0044DB  2  C9 3C        	cmp #60
0044DD  2  D0 02        	bne :+
0044DF  2  A9 00        	lda #0
0044E1  2               :
0044E1  2  C8           	iny
0044E2  2  C0 4B        	cpy #75
0044E4  2  D0 EF        	bne vspriteloop
0044E6  2               
0044E6  2               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0044E6  2               ; Hack for MAME to use VDU40x25
0044E6  2               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0044E6  2               
0044E6  2               ; Init VDU40x25
0044E6  2               
0044E6  2  A0 0F        	ldy #$f
0044E8  2               loops:
0044E8  2  8C 00 08     	sty MC6845_Reg
0044EB  2  B9 33 45     	lda CRTTAB,y
0044EE  2  8D 01 08     	sta MC6845_Dat
0044F1  2  88           	dey
0044F2  2  10 F4        	bpl loops
0044F4  2               
0044F4  2               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0044F4  2               
0044F4  2               ; Disable cursor
0044F4  2               
0044F4  2  A9 0A        	lda #$0a
0044F6  2  8D 00 08     	sta MC6845_Reg
0044F9  2  A9 20        	lda #$20
0044FB  2  8D 01 08     	sta MC6845_Dat
0044FE  2               
0044FE  2  20 43 45     	jsr cls
004501  2               
004501  2               ; Set new interrupt routine to sync at 25Hz
004501  2               
004501  2  A9 21        	lda #<irq_handler	; New interrupt handler
004503  2  8D 04 02     	sta IRQVEC
004506  2  A9 45        	lda #>irq_handler
004508  2  8D 05 02     	sta IRQVEC+1
00450B  2               
00450B  2  A9 40        	lda #<IRQtime		; Interrupt at 25Hz
00450D  2  8D 24 0E     	sta Timer1_Low
004510  2  A9 9C        	lda #>IRQtime
004512  2  8D 25 0E     	sta Timer1_High
004515  2  A9 40        	lda #%01000000
004517  2  8D 2B 0E     	sta ACR
00451A  2  A9 C0        	lda #%11000000
00451C  2  8D 2E 0E     	sta IER
00451F  2  58           	cli
004520  2               
004520  2  60           	rts
004521  2               
004521  2               irq_handler:
004521  2  AD 24 0E     	lda Timer1_Low		; Reset irqflag
004524  2               
004524  2  8A           	txa			; Save x,y
004525  2  48           	pha
004526  2  98           	tya
004527  2  48           	pha
004528  2               
004528  2  EE 31 45     	inc frames_passed	; Nr of frames past
00452B  2               
00452B  2  68           	pla			; Restore x,y,a
00452C  2  A8           	tay
00452D  2  68           	pla
00452E  2  AA           	tax
00452F  2  68           	pla
004530  2  40           	rti
004531  2               
004531  2  00           frames_passed:	.byte 0
004532  2               
004532  2  60           	rts
004533  2               
004533  2  3F 28 33 44  CRTTAB:	.byte $3f,$28,$33,$44
004537  2  1E 02 19 1B  	.byte $1e,$02,$19,$1b
00453B  2  03 12 72 13  	.byte $03,$12,$72,$13
00453F  2  04 00 07 FF  	.byte $04,$00,$07,$ff
004543  2               
004543  2               ;======================================================================
004543  2               ; Screen routines
004543  2               ;======================================================================
004543  2               
004543  2               ;----------------------------------------------------------------------
004543  2               ; Clear screen routine.
004543  2               ;
004543  2               ; Fill screenmem $0400-$07ff with ScrFillByte
004543  2               ; Set semigraphics at 1st column every line
004543  2               ;----------------------------------------------------------------------
004543  2               
004543  2               cls:
004543  2               
004543  2               ; Fill screen with 0
004543  2               
004543  2  A9 00        	lda #0
004545  2  A0 00        	ldy #0
004547  2               clsloop:
004547  2  99 00 04     	sta ScreenAddr,y
00454A  2  99 00 05     	sta ScreenAddr+256,y
00454D  2  99 00 06     	sta ScreenAddr+512,y
004550  2  99 00 07     	sta ScreenAddr+768,y
004553  2  C8           	iny
004554  2  D0 F1        	bne clsloop
004556  2               
004556  2               ; Init every row as graphics
004556  2               
004556  2  A0 00        	ldy #0
004558  2  A2 19        	ldx #ScrHeight
00455A  2  AD 00 DC     	lda SCADTB_lb
00455D  2  85 rr        	sta scraddr
00455F  2  AD 00 DD     	lda SCADTB_hb
004562  2  85 rr        	sta scraddr+1
004564  2  AD 1E 3C     	lda bcolour
004567  2               colloop:
004567  2  91 rr        	sta (scraddr),y
004569  2  48           	pha
00456A  2  A5 rr        	lda scraddr
00456C  2  18           	clc
00456D  2  69 28        	adc #ScrWidth
00456F  2  85 rr        	sta scraddr
004571  2  90 02        	bcc :+
004573  2  E6 rr        	inc scraddr+1
004575  2               :
004575  2  68           	pla
004576  2  CA           	dex
004577  2  D0 EE        	bne colloop
004579  2               
004579  2  60           	rts
00457A  2               
00457A  2               ;-------------------------------------------------------------
00457A  2               ; Colour background line
00457A  2               ;-------------------------------------------------------------
00457A  2               
00457A  2               linecol:
00457A  2  85 rr        	sta dispy
00457C  2  A9 00        	lda #0
00457E  2  85 rr        	sta dispx
004580  2  20 17 30     	jsr gprad
004583  2               
004583  2               ;	tay
004583  2               ;	lda SCADTB_lb,y
004583  2               ;	sta scraddr
004583  2               ;	lda SCADTB_hb,y
004583  2               ;	sta scraddr+1
004583  2  A0 00        	ldy #0
004585  2  AD 1E 3C     	lda bcolour		; set background colour
004588  2  91 rr        	sta (scraddr),y
00458A  2  C8           	iny
00458B  2  A9 1D        	lda #$1d		; set new background colour
00458D  2  91 rr        	sta (scraddr),y
00458F  2  60           	rts
004590  2               
004590  2               
004590  2               ;-------------------------------------------------------------
004590  2               ; Screen synchronisation.
004590  2               ;
004590  2               ;  - read joystick/keyboard
004590  2               ;  - handle sound
004590  2               ;  - sync framerate at 25Hz
004590  2               ;  - handle shrapnel every even frame
004590  2               ;-------------------------------------------------------------
004590  2               
004590  2               vsync:
004590  2  48           	pha
004591  2  98           	tya
004592  2  48           	pha
004593  2  8A           	txa
004594  2  48           	pha
004595  2  20 46 33     	jsr joykey		; read joystick/keyboard.
004598  2               
004598  2               ; Sync framerate to 25 Hz
004598  2               
004598  2               vsync1:
004598  2  AD 31 45     	lda frames_passed	; Wait 2 frames at 50Hz
00459B  2  C9 02        	cmp #2
00459D  2  90 F9        	bcc vsync1
00459F  2               
00459F  2  A9 00        	lda #0			; sync framerate 25 Hz
0045A1  2  8D 31 45     	sta frames_passed
0045A4  2               
0045A4  2               
0045A4  2  A5 rr        	lda clock
0045A6  2  29 01        	and #1
0045A8  2  D0 03        	bne:+
0045AA  2  20 11 2B     	jsr proshr		; handle shrapnel every even frame
0045AD  2               :
0045AD  2               ;	lda sndtyp
0045AD  2               ;	beq sndskip
0045AD  2               ;sndloop:
0045AD  2               ;	lda SpeakerBit		; handle sound
0045AD  2               ;	ldy sndtyp
0045AD  2               ;sndwait:
0045AD  2               ;	dey
0045AD  2               ;	bne sndwait
0045AD  2               ;	eor #4
0045AD  2               ;	sta SpeakerBit
0045AD  2               ;	dec sndtyp
0045AD  2               ;	bne sndloop
0045AD  2               ;sndskip:
0045AD  2               
0045AD  2  68           	pla
0045AE  2  AA           	tax
0045AF  2  68           	pla
0045B0  2  A8           	tay
0045B1  2  68           	pla
0045B2  2  60           	rts
0045B3  2               
0045B3  2  00           sndtyp:	.byte 0
0045B4  2               
0045B4  2               ;======================================================================
0045B4  2               ; Joystick routines
0045B4  2               ;======================================================================
0045B4  2               
0045B4  2               joyinit:
0045B4  2  60           	rts
0045B5  2               
0045B5  2               joy1:
0045B5  2  AD 2C 0E     	lda PCR			; Switch to joystick, CA2=0
0045B8  2  29 F1        	and #%11110001
0045BA  2  09 0C        	ora #%00001100
0045BC  2               
0045BC  2  AD 21 0E     	lda PORT_A		; Read FUDLR joystick
0045BF  2  29 7F        	and #$7f
0045C1  2  85 rr        	sta joyval
0045C3  2               
0045C3  2  AD 2C 0E     	lda PCR			; Switch to keyboard, CA2=1
0045C6  2  29 F1        	and #%11110001
0045C8  2  09 0E        	ora #%00001110
0045CA  2               
0045CA  2  AD A2 44     	lda keys+5		; Check FIRE2
0045CD  2  20 E8 45     	jsr ktest
0045D0  2  B0 06        	bcs :+
0045D2  2  A5 rr        	lda joyval
0045D4  2  29 DF        	and #%11011111
0045D6  2  85 rr        	sta joyval
0045D8  2               :
0045D8  2  AD A3 44     	lda keys+6		; Check FIRE3
0045DB  2  20 E8 45     	jsr ktest
0045DE  2  B0 06        	bcs :+
0045E0  2  A5 rr        	lda joyval
0045E2  2  29 BF        	and #%10111111
0045E4  2  85 rr        	sta joyval
0045E6  2               :
0045E6  2  60           	rts
0045E7  2               
0045E7  2               joy2:
0045E7  2  60           	rts
0045E8  2               
0045E8  2               ;======================================================================
0045E8  2               ; Keyboard routines
0045E8  2               ;======================================================================
0045E8  2               
0045E8  2               ;----------------------------------------------------------------------
0045E8  2               ; KTEST
0045E8  2               ; Check if key in A is pressed
0045E8  2               ; 	return clc if pressed
0045E8  2               ; 	return sec if not pressed
0045E8  2               ;----------------------------------------------------------------------
0045E8  2               
0045E8  2               ktest:
0045E8  2  85 rr        	sta tmp
0045EA  2  2C 21 0E     	bit PORT_A
0045ED  2               ;.if real=1
0045ED  2               ;	bpl not_pressed
0045ED  2               ;.else
0045ED  2  30 07        	bmi not_pressed	; BUG MAME, bit 7 not set ....
0045EF  2               ;.endif
0045EF  2  AD 21 0E     	lda PORT_A
0045F2  2  C5 rr        	cmp tmp
0045F4  2  F0 02        	beq pressed
0045F6  2               not_pressed:
0045F6  2  38           	sec
0045F7  2  60           	rts
0045F8  2               pressed:
0045F8  2  18           	clc
0045F9  2  60           	rts
0045FA  2               
0045FA  2               ;======================================================================
0045FA  2               ; PRSKEY
0045FA  2               ; Wait for keypress and release
0045FA  2               ;======================================================================
0045FA  2               
0045FA  2               prskey:
0045FA  2  2C 21 0E     	bit PORT_A
0045FD  2  10 FB        	bpl prskey
0045FF  2               relkey:
0045FF  2  2C 21 0E     	bit PORT_A
004602  2  30 FB        	bmi relkey
004604  2  60           	rts
004605  2               
004605  2               ;======================================================================
004605  2               ; Sprite routines
004605  2               ;======================================================================
004605  2               
004605  2               ;-----------------------------------------------------------------
004605  2               ; These are the sprite routines.
004605  2               ; sspria = single sprite, old (ix).
004605  2               ; ssprib = single sprite, new (ix+5).
004605  2               ; sspric = both sprites, old (ix) and new (ix+5).
004605  2               ;-----------------------------------------------------------------
004605  2               
004605  2               sspria:
004605  2  20 53 36     	jsr gsprad		; get old sprite address.
004608  2               sspri2:
004608  2  A5 64        	lda z80_e
00460A  2  8D 61 46     	sta dline1+1		; Set spritedata address
00460D  2  A5 65        	lda z80_d
00460F  2  8D 62 46     	sta dline1+2
004612  2               
004612  2  86 rr        	stx xtmp
004614  2  A2 00        	ldx #0			; vertical lines.
004616  2               sspri0:
004616  2  20 59 46     	jsr dline		; draw a line.
004619  2               
004619  2               ;.if bflag
004619  2               ;	cpx #16			; Detect end of line 3
004619  2               ;.else
004619  2  E0 14        	cpx #20			; Detect end of line 2
00461B  2               ;.endif
00461B  2               
00461B  2  D0 F9        	bne sspri0		; no, repeat
00461D  2  A6 rr        	ldx xtmp
00461F  2  60           	rts
004620  2               
004620  2               ;-----------------------------------------------------------------
004620  2               ; ssprib = single sprite, new (ix).
004620  2               ;-----------------------------------------------------------------
004620  2               
004620  2               ssprib:
004620  2  20 34 36     	jsr gspran 		; get new sprite address.
004623  2               				; z80_de = new sprite address
004623  2  4C 08 46     	jmp sspri2
004626  2               
004626  2               ;-----------------------------------------------------------------
004626  2               ; sspric = erase old sprite and plot new sprite line by line
004626  2               ;-----------------------------------------------------------------
004626  2               
004626  2               sspric:
004626  2  20 53 36     	jsr gsprad 		; get old sprite address.
004629  2               				; z80_de = old sprite address
004629  2  A5 64        	lda z80_e
00462B  2  8D 7A 46     	sta ddline1+1		; Set spritedata address
00462E  2  A5 65        	lda z80_d
004630  2  8D 7B 46     	sta ddline1+2
004633  2  20 9F 46     	jsr exx  		; store addresses.
004636  2               
004636  2  20 34 36     	jsr gspran 		; get new sprite addresses.
004639  2               				; z80_de = old sprite address
004639  2  A5 64        	lda z80_e
00463B  2  8D 61 46     	sta dline1+1		; Set spritedata address
00463E  2  A5 65        	lda z80_d
004640  2  8D 62 46     	sta dline1+2
004643  2               
004643  2  86 rr        	stx xtmp
004645  2  A2 00        	ldx #0			; vertical lines.
004647  2               lloop:
004647  2  20 59 46     	jsr dline 		; draw a line.
00464A  2  CA           	dex
00464B  2  CA           	dex
00464C  2  CA           	dex
00464D  2  CA           	dex
00464E  2  CA           	dex
00464F  2  20 72 46     	jsr ddline 		; delete a line.
004652  2               
004652  2               ;.if bflag
004652  2               ;	cpx #16			; Detect end of line 3
004652  2               ;.else
004652  2  E0 14        	cpx #20			; Detect end of line 2
004654  2               ;.endif
004654  2  D0 F1        	bne lloop		; no, repeat
004656  2  A6 rr        	ldx xtmp
004658  2  60           	rts
004659  2               
004659  2               ;-----------------------------------------------------------------
004659  2               ; Erase sprite line
004659  2               ;-----------------------------------------------------------------
004659  2               
004659  2               dline:
004659  2  BC 8B 46     	ldy sprline,x		; point to screenleft
00465C  2               
00465C  2  A9 05        	lda #5
00465E  2  85 rr        	sta rrow
004660  2               dline1:
004660  2  BD 0C 41     	lda objdta,x		; fetch spriteleft byte
004663  2  F0 06        	beq :+
004665  2  51 rr        	eor (scraddr),y		; merge with screenleft
004667  2  09 20        	ora #$20		; Set bit 5
004669  2  91 rr        	sta (scraddr),y		; write screenleft
00466B  2               :
00466B  2  E8           	inx			; next spritebyte
00466C  2  C8           	iny			; point to screenmiddle
00466D  2               
00466D  2  C6 rr        	dec rrow
00466F  2  D0 EF        	bne dline1
004671  2  60           	rts
004672  2               
004672  2               ;-----------------------------------------------------------------
004672  2               ; Draw sprite line
004672  2               ;-----------------------------------------------------------------
004672  2               
004672  2               ddline:
004672  2  BC 8B 46     	ldy sprline,x		; point to screenleft
004675  2               
004675  2  A9 05        	lda #5
004677  2  85 rr        	sta rrow
004679  2               ddline1:
004679  2  BD 0C 41     	lda objdta,x		; fetch spriteleft byte
00467C  2  F0 06        	beq :+
00467E  2  51 72        	eor (z80_hlp),y		; merge with screenleft
004680  2  09 20        	ora #$20		; Set bit 5
004682  2  91 72        	sta (z80_hlp),y		; write spritedata0
004684  2               :
004684  2  E8           	inx			; next spritebyte
004685  2  C8           	iny			; point to screenmiddle
004686  2               
004686  2  C6 rr        	dec rrow
004688  2  D0 EF        	bne ddline1
00468A  2  60           	rts
00468B  2               
00468B  2               ;-----------------------------------------------------------------
00468B  2               ; Spritebyte location on screen
00468B  2               ;-----------------------------------------------------------------
00468B  2               
00468B  2               sprline:
00468B  2  00 01 02 03  	.byte $00,$01,$02,$03,$04
00468F  2  04           
004690  2  28 29 2A 2B  	.byte $28,$29,$2a,$2b,$2c
004694  2  2C           
004695  2  50 51 52 53  	.byte $50,$51,$52,$53,$54
004699  2  54           
00469A  2  78 79 7A 7B  	.byte $78,$79,$7a,$7b,$7c
00469E  2  7C           
00469F  2               
00469F  1               	.include "z80.asm"
00469F  2               ;------------------------------------------------------
00469F  2               ; z80.asm
00469F  2               ; spectrum stuff
00469F  2               ; adresses
00469F  2               
00469F  2               
00469F  2               ; Contains seperatly 1 bit set
00469F  2               
00469F  2               _bitmem0	= $f8
00469F  2               _bitmem1	= $f9
00469F  2               _bitmem2	= $fa
00469F  2               _bitmem3	= $fb
00469F  2               _bitmem4	= $fc
00469F  2               _bitmem5	= $fd
00469F  2               _bitmem6	= $fe
00469F  2               _bitmem7	= $ff
00469F  2               
00469F  2               ; constants
00469F  2               _bitvalue0	= $01
00469F  2               _bitvalue1	= $02
00469F  2               _bitvalue2	= $04
00469F  2               _bitvalue3	= $08
00469F  2               _bitvalue4	= $10
00469F  2               _bitvalue5	= $20
00469F  2               _bitvalue6	= $40
00469F  2               _bitvalue7	= $80
00469F  2               
00469F  2               _notbitvalue0	= $fe
00469F  2               _notbitvalue1	= $fd
00469F  2               _notbitvalue2	= $fb
00469F  2               _notbitvalue3	= $f7
00469F  2               _notbitvalue4	= $ef
00469F  2               _notbitvalue5	= $df
00469F  2               _notbitvalue6	= $bf
00469F  2               _notbitvalue7	= $7f
00469F  2               
00469F  2               
00469F  2               exx:
00469F  2  A5 62        		lda z80_c
0046A1  2  A4 6E        		ldy z80_cp
0046A3  2  84 62        		sty z80_c
0046A5  2  85 6E        		sta z80_cp
0046A7  2  A5 63        		lda z80_b
0046A9  2  A4 6F        		ldy z80_bp
0046AB  2  84 63        		sty z80_b
0046AD  2  85 6F        		sta z80_bp
0046AF  2  A5 64        		lda z80_e
0046B1  2  A4 70        		ldy z80_ep
0046B3  2  84 64        		sty z80_e
0046B5  2  85 70        		sta z80_ep
0046B7  2  A5 65        		lda z80_d
0046B9  2  A4 71        		ldy z80_dp
0046BB  2  84 65        		sty z80_d
0046BD  2  85 71        		sta z80_dp
0046BF  2  A5 rr        		lda scraddr
0046C1  2  A4 72        		ldy z80_lp
0046C3  2  84 rr        		sty scraddr
0046C5  2  85 72        		sta z80_lp
0046C7  2  A5 rr        		lda scraddr+1
0046C9  2  A4 73        		ldy z80_hp
0046CB  2  84 rr        		sty scraddr+1
0046CD  2  85 73        		sta z80_hp
0046CF  2  60           		rts
0046D0  2               
0046D0  2               
0046D0  1               eind_asm:
0046D0  1               eop:					; End Of Program
0046D0  1               
0046D0  1               .out .sprintf("Gamecode size = %d bytes, free space = %d bytes", (eind_asm - start_asm),(49152-eind_asm + start_asm))
0046D0  1               
